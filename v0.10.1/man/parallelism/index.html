<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallelism in julia · MPSKit.jl</title><meta name="title" content="Parallelism in julia · MPSKit.jl"/><meta property="og:title" content="Parallelism in julia · MPSKit.jl"/><meta property="twitter:title" content="Parallelism in julia · MPSKit.jl"/><meta name="description" content="Documentation for MPSKit.jl."/><meta property="og:description" content="Documentation for MPSKit.jl."/><meta property="twitter:description" content="Documentation for MPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Prerequisites</a></li><li><a class="tocitem" href="../states/">States</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../environments/">Environments</a></li><li class="is-active"><a class="tocitem" href>Parallelism in julia</a><ul class="internal"><li><a class="tocitem" href="#Julia-threads-vs-BLAS-threads"><span>Julia threads vs BLAS threads</span></a></li><li><a class="tocitem" href="#MPSKit-multithreading"><span>MPSKit multithreading</span></a></li><li><a class="tocitem" href="#TensorKit-multithreading"><span>TensorKit multithreading</span></a></li><li><a class="tocitem" href="#Memory-management"><span>Memory management</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../lib/lib/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Parallelism in julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallelism in julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maartenvd/MPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maartenvd/MPSKit.jl/blob/master/docs/src/man/parallelism.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parallelism-in-julia"><a class="docs-heading-anchor" href="#Parallelism-in-julia">Parallelism in julia</a><a id="Parallelism-in-julia-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelism-in-julia" title="Permalink"></a></h1><p>Julia has great <a href="https://julialang.org/blog/2019/07/multithreading/">parallelism infrastructure</a>, but there is a caveat that is relevant for all algorithms implemented in MPSKit. The Julia threads do not play nicely together with the BLAS threads, which are the threads used for many of the linear algebra routines, and in particular for <code>gemm</code> (general matrix-matrix multiplication). As this is a core routine in MPSKit, this has a significant impact on the overall performance.</p><h2 id="Julia-threads-vs-BLAS-threads"><a class="docs-heading-anchor" href="#Julia-threads-vs-BLAS-threads">Julia threads vs BLAS threads</a><a id="Julia-threads-vs-BLAS-threads-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-threads-vs-BLAS-threads" title="Permalink"></a></h2><p>A lot of the confusion stems from the fact that the BLAS threading behaviour is not consistent between different vendors. Additionally, performance behaviour is severely dependent on hardware, the specifics of the problem, and the availability of other resources such as total memory, or memory bandwith. This means that there is no one size fits all solution, and that you will have to experiment with the settings to get optimal performance. Nevertheless, there are some general guidelines that can be followed, which seem to at least work well in most cases.</p><p>The number of threads that are set by <code>BLAS.set_num_threads()</code>, in the case of OpenBLAS (the default vendor), is equal to the <strong>total number</strong> of BLAS threads that is kept in a pool, which is then shared by all Julia threads. This means that if you have 4 julia threads and 4 BLAS threads, then all julia threads will share the same 4 BLAS threads. On the other hand, using <code>BLAS.set_num_threads(1)</code>, OpenBLAS will now utilize the julia threads to run the BLAS jobs. Thus, for OpenBLAS, very often setting the number of BLAS threads to 1 is the best option, which will then maximally utilize the julia threading infrastructure of MPSKit.</p><p>In the case of <a href>MKL.jl</a>, which often outperforms OpenBLAS, the situation is a bit different. Here, the number of BLAS threads corresponds to the number of threads that are spawned by <strong>each</strong> julia thread. Thus, if you have 4 julia threads and 4 BLAS threads, then each julia thread will spawn 4 BLAS threads, for a total of 16 BLAS threads. As such, it might become necessary to adapt the settings to avoid oversubscription of the cores.</p><p>A careful analysis of the different cases and benefits can be inspected by making use of <a href="https://github.com/carstenbauer/ThreadPinning.jl"><code>ThreadPinning.jl</code></a>&#39;s tool <code>threadinfo(; blas=true, info=true)</code>. In particular, the following might demonstrate the difference between OpenBLAS and MKL:</p><pre><code class="language-julia-repl hljs">julia&gt; Threads.nthreads()
4

julia&gt; using ThreadPinning; threadinfo(; blas=true, hints=true)

System: 8 cores (2-way SMT), 1 sockets, 1 NUMA domains

| 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 | 

# = Julia thread, # = HT, # = Julia thread on HT, | = Socket seperator

Julia threads: 4
├ Occupied CPU-threads: 4
└ Mapping (Thread =&gt; CPUID): 1 =&gt; 8, 2 =&gt; 5, 3 =&gt; 9, 4 =&gt; 2,

BLAS: libopenblas64_.so
└ openblas_get_num_threads: 8

[ Info: jlthreads != 1 &amp;&amp; blasthreads &lt; cputhreads. You should either set BLAS.set_num_threads(1) (recommended!) or at least BLAS.set_num_threads(16).
[ Info: jlthreads &lt; cputhreads. Perhaps increase number of Julia threads to 16?
julia&gt; using MKL; threadinfo(; blas=true, hints=true)

System: 8 cores (2-way SMT), 1 sockets, 1 NUMA domains

| 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 | 

# = Julia thread, # = HT, # = Julia thread on HT, | = Socket seperator

Julia threads: 4
├ Occupied CPU-threads: 4
└ Mapping (Thread =&gt; CPUID): 1 =&gt; 11, 2 =&gt; 12, 3 =&gt; 1, 4 =&gt; 2,

BLAS: libmkl_rt.so
├ mkl_get_num_threads: 8
└ mkl_get_dynamic: true

┌ Warning: blasthreads_per_jlthread &gt; cputhreads_per_jlthread. You should decrease the number of MKL threads, i.e. BLAS.set_num_threads(4).
└ @ ThreadPinning ~/.julia/packages/ThreadPinning/qV2Cd/src/threadinfo.jl:256
[ Info: jlthreads &lt; cputhreads. Perhaps increase number of Julia threads to 16?</code></pre><h2 id="MPSKit-multithreading"><a class="docs-heading-anchor" href="#MPSKit-multithreading">MPSKit multithreading</a><a id="MPSKit-multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#MPSKit-multithreading" title="Permalink"></a></h2><p>Within MPSKit, when Julia is started with multiple threads, by default the <code>Threads.@spawn</code> machinery will be used to parallelize the code as much as possible. In particular, there are three main places where this is happening, which can be disabled separately through a preference-based system.</p><ol><li><p>During the process of some algorithms (e.g. VUMPS), local updates can take place at each site in parallel. This can be controlled by the <code>parallelize_sites</code> preference.</p></li><li><p>During the calculation of the environments, when the MPO is block-sparse, it is possible to parallelize over these blocks. This can be enabled or disabled by the <code>parallelize_environments</code> preference.</p></li><li><p>During the calculation of the derivatives, when the MPO is block-sparse, it is possible to parallelize over these blocks. This can be enabled or disabled by the <code>parallelize_derivatives</code> preference.</p></li></ol><p>For convenience, these preferences can be set via <a href="@ref"><code>MPSKit.Defaults.set_parallelization</code></a>, which takes as input pairs of preferences and booleans. For example, to disable all parallelization, one can call</p><pre><code class="language-julia hljs">Defaults.set_parallelization(&quot;sites&quot; =&gt; false, &quot;environments&quot; =&gt; false, &quot;derivatives&quot; =&gt; false)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>These settings are statically set at compile-time, and for changes to take effect the Julia session must be restarted.</p></div></div><h2 id="TensorKit-multithreading"><a class="docs-heading-anchor" href="#TensorKit-multithreading">TensorKit multithreading</a><a id="TensorKit-multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#TensorKit-multithreading" title="Permalink"></a></h2><p>Finally, when dealing with tensors that have some internal symmetry, it is also possible to parallelize over the symmetry sectors. This is handled by TensorKit, and more information can be found in its documentation (Soon TM).</p><h2 id="Memory-management"><a class="docs-heading-anchor" href="#Memory-management">Memory management</a><a id="Memory-management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-management" title="Permalink"></a></h2><p>Because of the way julia threads work, it is possible that the total memory usage of your program becomes rather high. This seems to be because of the fact that MPSKit spawns several tasks (in a nested way), which each allocate and deallocate quite a bit of memory in a tight loop. This seems to lead to a situation where the garbage collector is not able to keep up, and can even fail to clear the garbage before an <code>OutOfMemory</code> error occurs. In this case, often the best thing to do is disable the multithreading of MPSKit, specifically for the <code>derivatives</code>, as this seems to be the most memory intensive part. This is something that is under investigation, and hopefully will be fixed in the future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environments/">« Environments</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Sunday 29 October 2023 21:39">Sunday 29 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
