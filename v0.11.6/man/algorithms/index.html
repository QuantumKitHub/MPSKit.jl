<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · MPSKit.jl</title><meta name="title" content="Algorithms · MPSKit.jl"/><meta property="og:title" content="Algorithms · MPSKit.jl"/><meta property="twitter:title" content="Algorithms · MPSKit.jl"/><meta name="description" content="Documentation for MPSKit.jl."/><meta property="og:description" content="Documentation for MPSKit.jl."/><meta property="twitter:description" content="Documentation for MPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Prerequisites</a></li><li><a class="tocitem" href="../states/">States</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Minimizing-the-energy"><span>Minimizing the energy</span></a></li><li><a class="tocitem" href="#Time-evolution"><span>Time evolution</span></a></li><li><a class="tocitem" href="#Excitations"><span>Excitations</span></a></li><li><a class="tocitem" href="#changebonds"><span><code>changebonds</code></span></a></li><li><a class="tocitem" href="#leading-boundary"><span>leading boundary</span></a></li><li><a class="tocitem" href="#approximate"><span><code>approximate</code></span></a></li><li><a class="tocitem" href="#Varia"><span>Varia</span></a></li></ul></li><li><a class="tocitem" href="../environments/">Environments</a></li><li><a class="tocitem" href="../parallelism/">Parallelism in julia</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../lib/lib/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/master/docs/src/man/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="um_algorithms"><a class="docs-heading-anchor" href="#um_algorithms">Algorithms</a><a id="um_algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#um_algorithms" title="Permalink"></a></h1><h2 id="Minimizing-the-energy"><a class="docs-heading-anchor" href="#Minimizing-the-energy">Minimizing the energy</a><a id="Minimizing-the-energy-1"></a><a class="docs-heading-anchor-permalink" href="#Minimizing-the-energy" title="Permalink"></a></h2><p>There are a number of different possible energy-minimization algorithms, depending on the system size. Exclusive to finite systems are</p><pre><code class="nohighlight hljs">- DMRG

- DMRG2</code></pre><p>Exclusive to infinite systems are</p><pre><code class="nohighlight hljs">- IDMRG

- IDMRG2

- VUMPS</code></pre><p>with a last algorithm - GradientGrassmann - implemented for both finite and infinite systems.</p><p>WindowMPS, which is a finite patch of mutable tensors embedded in an infinite MPS, is handled as a finite system where we only optimize over the patch of mutable tensors.</p><h3 id="DMRG"><a class="docs-heading-anchor" href="#DMRG">DMRG</a><a id="DMRG-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG" title="Permalink"></a></h3><pre><code class="language-julia hljs">state = FiniteMPS(20,ℂ^2,ℂ^10);
operator = nonsym_ising_ham();
(groundstate,environments,delta) = find_groundstate!(state,operator,DMRG())</code></pre><p>The DMRG algorithm sweeps through the system, optimizing every site. Because of its single-site behaviour, this will always keep the bond dimension fixed. If you do want to increase the bond dimension dynamically, then there are two options. Either you use the two-site variant of DMRG (DMRG2()), or you make use of the finalize option. Finalize is a function that gets called at the end of every DMRG iteration. Within that function call one can modify the state.</p><pre><code class="language-julia hljs">function my_finalize(iter,state,H,envs)
    println(&quot;Hello from iteration $iter&quot;)
    return state,envs;
end

(groundstate,environments,delta) = find_groundstate!(state,operator,DMRG(finalize = my_finalize))</code></pre><h3 id="DMRG2"><a class="docs-heading-anchor" href="#DMRG2">DMRG2</a><a id="DMRG2-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG2" title="Permalink"></a></h3><pre><code class="language-julia hljs">state = FiniteMPS(20,ℂ^2,ℂ^10);
operator = nonsym_ising_ham();
(groundstate,environments,delta) = find_groundstate!(state,operator,DMRG2(trscheme=truncbelow(1e-7)));</code></pre><p>The twosite variant of DMRG, which optimizes blocks of two sites and then decomposes them into 2 MPS tensors using the svd decomposition. By truncating the singular values up to a desired precision, one can dynamically grow and shrink the bond dimension as needed. However, this truncation in turn introduces an error, which is why a state converged with DMRG2 can often be slightly further converged by subsequently using DMRG.</p><h3 id="IDMRG"><a class="docs-heading-anchor" href="#IDMRG">IDMRG</a><a id="IDMRG-1"></a><a class="docs-heading-anchor-permalink" href="#IDMRG" title="Permalink"></a></h3><pre><code class="language-julia hljs">state = InfiniteMPS([ℂ^2],[ℂ^10]);
operator = nonsym_ising_ham();
(groundstate,environments,delta) = find_groundstate(state,operator,IDMRG1())</code></pre><p>The DMRG algorithm for finite systems can be generalized to infinite MPS. The idea is to start with a finite system and grow the system size, while we are sweeping through the system. This is again a single site algorithm, and therefore preserves the initial bond dimension.</p><h3 id="IDMRG2"><a class="docs-heading-anchor" href="#IDMRG2">IDMRG2</a><a id="IDMRG2-1"></a><a class="docs-heading-anchor-permalink" href="#IDMRG2" title="Permalink"></a></h3><pre><code class="language-julia hljs">state = InfiniteMPS([ℂ^2,ℂ^2],[ℂ^10,ℂ^10]);
operator = repeat(nonsym_ising_ham(),2);
(groundstate,environments,delta) = find_groundstate(state,operator,IDMRG2(trscheme=truncbelow(1e-5)))</code></pre><p>The generalization of DMRG2 to infinite systems has the same caveats as its finite counterpart. We furthermore require a unitcell ≥ 2. As a rule of thumb, a truncation cutoff of 1e-5 is already really good.</p><h3 id="VUMPS"><a class="docs-heading-anchor" href="#VUMPS">VUMPS</a><a id="VUMPS-1"></a><a class="docs-heading-anchor-permalink" href="#VUMPS" title="Permalink"></a></h3><p>VUMPS is an (I)DMRG inspired algorithm that can be used to find the groundstate of infinite matrix product states</p><pre><code class="language-julia hljs">state = InfiniteMPS([ℂ^2],[ℂ^10]);
operator = nonsym_ising_ham();
(groundstate,environments,delta) = find_groundstate(state,operator,VUMPS())</code></pre><p>much like DMRG, it cannot modify the bond dimension, and this has to be done manually in the finalize function.</p><h3 id="Gradient-descent"><a class="docs-heading-anchor" href="#Gradient-descent">Gradient descent</a><a id="Gradient-descent-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-descent" title="Permalink"></a></h3><p>Both finite and infinite matrix product states can be parametrized by a set of unitary matrices, and we can then perform gradient descent on this unitary manifold. Due to some technical reasons (gauge freedom), this manifold further restricts to a grassmann manifold.</p><pre><code class="language-julia hljs">state = InfiniteMPS([ℂ^2],[ℂ^10]);
operator = nonsym_ising_ham();
(groundstate,environments,delta) = find_groundstate(state,operator,GradientGrassmann())</code></pre><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><h3 id="TDVP"><a class="docs-heading-anchor" href="#TDVP">TDVP</a><a id="TDVP-1"></a><a class="docs-heading-anchor-permalink" href="#TDVP" title="Permalink"></a></h3><p>There is an implementation of the one-site TDVP scheme for finite and infinite MPS:</p><pre><code class="language-julia hljs">(newstate,environments) = timestep(state,operator,dt,TDVP())</code></pre><p>and the two-site scheme for finite MPS (TDVP2()). Similarly to DMRG, the one site scheme will preserve the bond dimension, and expansion has to be done manually.</p><h3 id="Time-evolution-MPO"><a class="docs-heading-anchor" href="#Time-evolution-MPO">Time evolution MPO</a><a id="Time-evolution-MPO-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution-MPO" title="Permalink"></a></h3><p>We have rudimentary support for turning an MPO hamiltonian into a time evolution MPO.</p><pre><code class="language-julia hljs">make_time_mpo(H,dt,alg::WI)
make_time_mpo(H,dt,alg::WII)</code></pre><p>two algorithms are available, corresponding to different orders of precision. It is possible to then multiply a state by this MPO, or to approximate (MPO,state) by a new state</p><pre><code class="language-julia hljs">state = InfiniteMPS([ℂ^2],[ℂ^10]);
operator = nonsym_ising_ham();
mpo = make_time_mpo(operator, 0.1, WII());
approximate(state, (mpo, state), VUMPS())</code></pre><p>This feature is at the moment not very well supported.</p><h2 id="Excitations"><a class="docs-heading-anchor" href="#Excitations">Excitations</a><a id="Excitations-1"></a><a class="docs-heading-anchor-permalink" href="#Excitations" title="Permalink"></a></h2><h3 id="Quasiparticle-Ansatz"><a class="docs-heading-anchor" href="#Quasiparticle-Ansatz">Quasiparticle Ansatz</a><a id="Quasiparticle-Ansatz-1"></a><a class="docs-heading-anchor-permalink" href="#Quasiparticle-Ansatz" title="Permalink"></a></h3><p>The Quasiparticle Ansatz offers an approach to compute low-energy eigenstates in quantum systems, playing a key role in both finite and infinite systems. It leverages localized perturbations for approximations, as detailed in <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.111.080401">this paper</a>.</p><h4 id="Finite-Systems:"><a class="docs-heading-anchor" href="#Finite-Systems:">Finite Systems:</a><a id="Finite-Systems:-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Systems:" title="Permalink"></a></h4><p>In finite systems, we approximate low-energy states by altering a single tensor in the Matrix Product State (MPS) for each site, and summing these across all sites. This method introduces additional gauge freedoms, utilized to ensure orthogonality to the ground state. Optimizing within this framework translates to solving an eigenvalue problem. For example, in the transverse field Ising model, we calculate the first excited state as shown in the provided code snippet, amd check the accuracy against theoretical values. Some deviations are expected, both due to finite-bond-dimension and finite-size effects.</p><pre><code class="language-julia hljs"># Model parameters
g = 10.0
L = 16
H = transverse_field_ising(; g)

# Finding the ground state
ψ₀ = FiniteMPS(L, ℂ^2, ℂ^32)
ψ, = find_groundstate(ψ₀, H; verbosity=0)

# Computing excitations using the Quasiparticle Ansatz
Es, ϕs = excitations(H, QuasiparticleAnsatz(), ψ; num=1)
isapprox(Es[1], 2(g - 1); rtol=1e-2)</code></pre><h4 id="Infinite-Systems:"><a class="docs-heading-anchor" href="#Infinite-Systems:">Infinite Systems:</a><a id="Infinite-Systems:-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Systems:" title="Permalink"></a></h4><p>The ansatz in infinite systems maintains translational invariance by perturbing every site in the unit cell in a plane-wave superposition, requiring momentum specification. The <a href="https://iopscience.iop.org/article/10.1088/0953-8984/1/19/001">Haldane gap</a> computation in the Heisenberg model illustrates this approach.</p><pre><code class="language-julia hljs"># Setting up the model and momentum
momentum = π
H = heisenberg_XXX()

# Ground state computation
ψ₀ = InfiniteMPS(ℂ^3, ℂ^48)
ψ, = find_groundstate(ψ₀, H; verbosity=0)

# Excitation calculations
Es, ϕs = excitations(H, QuasiparticleAnsatz(), momentum, ψ)
isapprox(Es[1], 0.41047925; atol=1e-4)</code></pre><h4 id="Charged-excitations:"><a class="docs-heading-anchor" href="#Charged-excitations:">Charged excitations:</a><a id="Charged-excitations:-1"></a><a class="docs-heading-anchor-permalink" href="#Charged-excitations:" title="Permalink"></a></h4><p>When dealing with symmetric systems, the default optimization is for eigenvectors with trivial total charge. However, quasiparticles with different charges can be obtained using the sector keyword. For instance, in the transverse field Ising model, we consider an excitation built up of flipping a single spin, aligning with <code>Z2Irrep(1)</code>.</p><pre><code class="language-julia hljs">g = 10.0
L = 16
H = transverse_field_ising(Z2Irrep; g)
ψ₀ = FiniteMPS(L, Z2Space(0 =&gt; 1, 1 =&gt; 1), Z2Space(0 =&gt; 16, 1 =&gt; 16))
ψ, = find_groundstate(ψ₀, H; verbosity=0)
Es, ϕs = excitations(H, QuasiparticleAnsatz(), ψ; num=1, sector=Z2Irrep(1))
isapprox(Es[1], 2(g - 1); rtol=1e-2) # infinite analytical result</code></pre><h3 id="Finite-excitations"><a class="docs-heading-anchor" href="#Finite-excitations">Finite excitations</a><a id="Finite-excitations-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-excitations" title="Permalink"></a></h3><p>For finite systems we can also do something else - find the groundstate of the hamiltonian + <span>$weight \sum_i | psi_i &gt; &lt; psi_i$</span>. This is also supported by calling</p><pre><code class="language-julia hljs">th = nonsym_ising_ham()
ts = FiniteMPS(10,ℂ^2,ℂ^12);
(ts,envs,_) = find_groundstate(ts,th,DMRG(verbosity=0));
(energies,Bs) = excitations(th,FiniteExcited(),ts,envs);</code></pre><h3 id="&quot;Chepiga-Ansatz&quot;"><a class="docs-heading-anchor" href="#&quot;Chepiga-Ansatz&quot;">&quot;Chepiga Ansatz&quot;</a><a id="&quot;Chepiga-Ansatz&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Chepiga-Ansatz&quot;" title="Permalink"></a></h3><p>Computing excitations in critical systems poses a significant challenge due to the diverging correlation length, which requires very large bond dimensions. However, we can leverage this long-range correlation to effectively identify excitations. In this context, the left/right gauged MPS, serving as isometries, are effectively projecting the Hamiltonian into the low-energy sector. This projection method is particularly effective in long-range systems, where excitations are distributed throughout the entire system. Consequently, the low-lying energy spectrum can be extracted by diagonalizing the effective Hamiltonian (without any additional DMRG costs!). The states of these excitations are then represented by the ground state MPS, with one site substituted by the corresponding eigenvector. This approach is often referred to as the &#39;Chepiga ansatz&#39;, named after one of the authors of this paper.</p><p>This is supported via the following syntax:</p><pre><code class="language-julia hljs">g = 1.0
L = 16
H = transverse_field_ising(; g)
ψ₀ = FiniteMPS(L, ComplexSpace(2), ComplexSpace(32))
ψ, envs, = find_groundstate(ψ₀, H; verbosity=0)
E₀ = real(sum(expectation_value(ψ, H, envs)))
Es, ϕs = excitations(H, ChepigaAnsatz(), ψ, envs; num=1)
isapprox(Es[1], 2(g - 1); rtol=1e-2) # infinite analytical result

# output

true</code></pre><p>In order to improve the accuracy, a two-site version also exists, which varies two neighbouring sites:</p><pre><code class="language-julia hljs">g = 1.0
L = 16
H = transverse_field_ising(; g)
ψ₀ = FiniteMPS(L, ComplexSpace(2), ComplexSpace(32))
ψ, envs, = find_groundstate(ψ₀, H; verbosity=0)
E₀ = real(sum(expectation_value(ψ, H, envs)))
Es, ϕs = excitations(H, ChepigaAnsatz2(), ψ, envs; num=1)
isapprox(Es[1], 2(g - 1); rtol=1e-2) # infinite analytical result

# output

true</code></pre><p>The algorithm is described in more detail in the following paper:</p><ul><li>Chepiga, N., &amp; Mila, F. (2017). Excitation spectrum and density matrix renormalization group iterations. Physical Review B, 96(5), 054425.</li></ul><h2 id="changebonds"><a class="docs-heading-anchor" href="#changebonds"><code>changebonds</code></a><a id="changebonds-1"></a><a class="docs-heading-anchor-permalink" href="#changebonds" title="Permalink"></a></h2><p>Many of the previously mentioned algorithms do not possess a way to dynamically change to bond dimension. This is often a problem, as the optimal bond dimension is often not a priori known, or needs to increase because of entanglement growth throughout the course of a simulation. <a href="#changebonds"><code>changebonds</code></a> exposes a way to change the bond dimension of a given state.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.changebonds-man-algorithms" href="#MPSKit.changebonds-man-algorithms"><code>MPSKit.changebonds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">changebonds(ψ::AbstractMPS, H, alg, envs) -&gt; ψ′, envs′
changebonds(ψ::AbstractMPS, alg) -&gt; ψ′</code></pre><p>Change the bond dimension of <code>ψ</code> using the algorithm <code>alg</code>, and return the new <code>ψ</code> and the new <code>envs</code>.</p><p>See also: <a href="../../lib/lib/#MPSKit.SvdCut"><code>SvdCut</code></a>, <a href="../../lib/lib/#MPSKit.RandExpand"><code>RandExpand</code></a>, <a href="../../lib/lib/#MPSKit.VUMPSSvdCut"><code>VUMPSSvdCut</code></a>, <a href="../../lib/lib/#MPSKit.OptimalExpand"><code>OptimalExpand</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/cd81eef12431cccf769aba8febafce7d50cb80ba/src/algorithms/changebonds/changebonds.jl#L1-L8">source</a></section></article><p>There are several different algorithms implemented, each having their own advantages and disadvantages:</p><ul><li><a href="../../lib/lib/#MPSKit.SvdCut"><code>SvdCut</code></a>: The simplest method for changing the bonddimension is found by simply locally truncating the state using an SVD decomposition. This yields a (locally) optimal truncation, but clearly cannot be used to increase the bond dimension. Note that a globally optimal truncation can be obtained by using the <a href="../../lib/lib/#MPSKit.SvdCut"><code>SvdCut</code></a> algorithm in combination with <a href="#approximate"><code>approximate</code></a>. Since the output of this method might have a truncated bonddimension, the new state might not be identical to the input state. The truncation is controlled through <code>trscheme</code>, which dictates how the singular values of the original state are truncated.</li></ul><ul><li><p><a href="../../lib/lib/#MPSKit.OptimalExpand"><code>OptimalExpand</code></a>: This algorithm is based on the idea of expanding the bond dimension by investigating the two-site derivative, and adding the most important blocks which are orthogonal to the current state. From the point of view of a local two-site update, this procedure is <em>optimal</em>, but it requires to evaluate a two-site derivative, which can be costly when the physical space is large. The state will remain unchanged, but a one-site scheme will now be able to push the optimization further. The subspace used for expansion can be truncated through <code>trscheme</code>, which dictates how many singular values will be added.</p></li><li><p><a href="../../lib/lib/#MPSKit.RandExpand"><code>RandExpand</code></a>: This algorithm similarly adds blocks orthogonal to the current state, but does not attempt to select the most important ones, and rather just selects them at random. The advantage here is that this is much cheaper than the optimal expand, and if the bond dimension is grown slow enough, this still obtains a very good expansion scheme. Again, The state will remain unchanged and a one-site scheme will now be able to  push the optimization further. The subspace used for expansion can be truncated through <code>trscheme</code>, which dictates how many singular values will be added.</p></li><li><p><a href="../../lib/lib/#MPSKit.VUMPSSvdCut"><code>VUMPSSvdCut</code></a>: This algorithm is based on the <a href="#VUMPS"><code>VUMPS</code></a> algorithm, and consists of performing a two-site update, and then truncating the state back down. Because of the two-site update, this can again become expensive, but the algorithm has the option of both expanding as well as truncating the bond dimension. Here, <code>trscheme</code> controls the truncation of the full state after the two-site update.</p></li></ul><h2 id="leading-boundary"><a class="docs-heading-anchor" href="#leading-boundary">leading boundary</a><a id="leading-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#leading-boundary" title="Permalink"></a></h2><p>For statmech partition functions we want to find the approximate leading boundary MPS. Again this can be done with VUMPS:</p><pre><code class="language-julia hljs">th = nonsym_ising_mpo()
ts = InfiniteMPS([ℂ^2],[ℂ^20]);
(ts,envs,_) = leading_boundary(ts,th,VUMPS(maxiter=400,verbosity=false));</code></pre><p>if the mpo satisfies certain properties (positive and hermitian), it may also be possible to use GradientGrassmann.</p><h2 id="approximate"><a class="docs-heading-anchor" href="#approximate"><code>approximate</code></a><a id="approximate-1"></a><a class="docs-heading-anchor-permalink" href="#approximate" title="Permalink"></a></h2><p>Often, it is useful to approximate a given MPS by another, typically by one of a different bond dimension. This is achieved by approximating an application of an MPO to the initial state, by a new state.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.approximate-man-algorithms" href="#MPSKit.approximate-man-algorithms"><code>MPSKit.approximate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approximate(ψ₀, (O, ψ), algorithm, [environments]; kwargs...)
approximate!(ψ₀, (O, ψ), algorithm, [environments]; kwargs...)</code></pre><p>Compute an approximation to the application of an operator <code>O</code> to the state <code>ψ</code> in the form of an MPS <code>ψ₀</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess of the approximated state</li><li><code>(O::AbstractMPO, ψ::AbstractMPS)</code>: operator <code>O</code> and state <code>ψ</code> to be approximated</li><li><code>algorithm</code>: approximation algorithm. See below for a list of available algorithms.</li><li><code>[environments]</code>: MPS environment manager</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Algorithms</strong></p><ul><li><p><code>DMRG</code>: Alternating least square method for maximizing the fidelity with a single-site scheme.</p></li><li><p><code>DMRG2</code>: Alternating least square method for maximizing the fidelity with a two-site scheme.</p></li><li><p><code>IDMRG1</code>: Variant of <code>DMRG</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>IDMRG2</code>: Variant of <code>DMRG2</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>VOMPS</code>: Tangent space method for truncating uniform MPS.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/cd81eef12431cccf769aba8febafce7d50cb80ba/src/algorithms/approximate/approximate.jl#L1-L26">source</a></section></article><h2 id="Varia"><a class="docs-heading-anchor" href="#Varia">Varia</a><a id="Varia-1"></a><a class="docs-heading-anchor-permalink" href="#Varia" title="Permalink"></a></h2><p>What follows is a medley of lesser known (or used) algorithms and don&#39;t entirely fit under one of the above categories.</p><h3 id="Dynamical-DMRG"><a class="docs-heading-anchor" href="#Dynamical-DMRG">Dynamical DMRG</a><a id="Dynamical-DMRG-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-DMRG" title="Permalink"></a></h3><p>Dynamical DMRG has been described in other papers and is a way to find the propagator. The basic idea is that to calculate <span>$G(z) = &lt; V | (H-z)^{-1} | V &gt;$</span> , one can variationally find <span>$(H-z) |W &gt; = | V &gt;$</span> and then the propagator simply equals <span>$G(z) = &lt; V | W &gt;$</span>.</p><h3 id="fidelity-susceptibility"><a class="docs-heading-anchor" href="#fidelity-susceptibility">fidelity susceptibility</a><a id="fidelity-susceptibility-1"></a><a class="docs-heading-anchor-permalink" href="#fidelity-susceptibility" title="Permalink"></a></h3><p>The fidelity susceptibility measures how much the groundstate changes when tuning a parameter in your hamiltonian. Divergences occur at phase transitions, making it a valuable measure when no order parameter is known.</p><pre><code class="language-julia hljs">fidelity_susceptibility(groundstate,H_0,perturbing_Hams::AbstractVector)</code></pre><h3 id="periodic-boundary-conditions"><a class="docs-heading-anchor" href="#periodic-boundary-conditions">periodic boundary conditions</a><a id="periodic-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#periodic-boundary-conditions" title="Permalink"></a></h3><p>You can impose periodic boundary conditions on the hamiltonian itself, while still using a normal OBC finite matrix product states. This is straightforward to implement but competitive with more advanced PBC MPS algorithms.</p><h3 id="exact-diagonalization"><a class="docs-heading-anchor" href="#exact-diagonalization">exact diagonalization</a><a id="exact-diagonalization-1"></a><a class="docs-heading-anchor-permalink" href="#exact-diagonalization" title="Permalink"></a></h3><p>As a side effect, our code support exact diagonalization. The idea is to construct a finite matrix product state with maximal bond dimension, and then optimize the middle site. Because we never truncated the bond dimension, this single site effectively parametrizes the entire hilbert space.</p><pre><code class="language-julia hljs">exact_diagonalization(periodic_boundary_conditions(su2_xxx_ham(spin=1),10),which=:SR) # find the groundstate on 10 sites</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../environments/">Environments »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 11 December 2024 18:17">Wednesday 11 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
