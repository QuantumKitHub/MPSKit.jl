<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallelism in julia · MPSKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MPSKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Basics</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><a class="tocitem" href="../states/">States</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../environments/">Environments</a></li><li class="is-active"><a class="tocitem" href>Parallelism in julia</a><ul class="internal"><li><a class="tocitem" href="#The-problem-1"><span>The problem</span></a></li><li><a class="tocitem" href="#The-possible-solution-1"><span>The possible solution</span></a></li><li><a class="tocitem" href="#In-practice-1"><span>In practice</span></a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tut/anyonic_statmech/">The hard hexagon model</a></li><li><a class="tocitem" href="../../tut/isingcft/">The ising cft spectrum</a></li><li><a class="tocitem" href="../../tut/xxz_groundstate/">Analyzing the xxz model</a></li><li><a class="tocitem" href="../../tut/timeev/">DQPT in ising</a></li><li><a class="tocitem" href="../../tut/haldane/">The haldane gap</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/lib/">Library documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Parallelism in julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallelism in julia</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maartenvd/MPSKit.jl/blob/master/docs/src/man/parallelism.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Parallelism-in-julia-1"><a class="docs-heading-anchor" href="#Parallelism-in-julia-1">Parallelism in julia</a><a class="docs-heading-anchor-permalink" href="#Parallelism-in-julia-1" title="Permalink"></a></h1><p>Julia has <a href="https://julialang.org/blog/2019/07/multithreading/">really great parallelism infrastructure</a>, but there is a caveat that is relevant for all algorithms implemented in mpskit. The julia threads do not play nicely together with the BLAS threads, which are the threads used for matrix matrix multiplications (amongst other things).</p><h2 id="The-problem-1"><a class="docs-heading-anchor" href="#The-problem-1">The problem</a><a class="docs-heading-anchor-permalink" href="#The-problem-1" title="Permalink"></a></h2><p>The default behaviour is to have some BLAS threads running, which accept multiplication jobs, to which the julia threads can then submit jobs. These jobs are in turn sequentially executed over the BLAS threads. This means that if your program is waiting on a matrix multiplication to finish, it can not in parallel do other matrix multiplications!</p><p>The behaviour can be demonstrated using the following bit of code:</p><pre><code class="language-none">function parallelworker(As,Bs)
   temp = similar.(As);
   @sync for i in 1:length(As)
       Threads.@spawn mul!($temp[i], $As[i],$Bs[i])
   end
   sum(temp);
end

function serialworker(As,Bs)
    temp = similar.(As);
    for i in 1:length(As)
        mul!(temp[i], As[i],Bs[i])
    end
    sum(temp);
end

As = [rand(1000,1000) for a in 1:50];
Bs = [rand(1000,1000) for b in 1:50];

@btime parallelworker($As,$Bs);
@btime serialworker($As,$Bs);</code></pre><p>running this on my laptop with 4 julia threads and 4 BLAS threads, I see the following:</p><pre><code class="language-none">998.506 ms (513 allocations: 755.34 MiB)
1.080 s (199 allocations: 755.32 MiB)</code></pre><p>The julia threads give next to no speedup! Despite mpskit trying to implement parallel code, you will most likely not be able to exploit this to the fullest when running julia with the default settings.</p><h2 id="The-possible-solution-1"><a class="docs-heading-anchor" href="#The-possible-solution-1">The possible solution</a><a class="docs-heading-anchor-permalink" href="#The-possible-solution-1" title="Permalink"></a></h2><p>The short term &#39;solution&#39; is to disable BLAS threads altogether. Multiplication jobs are then run in the julia thread that call them. Individual multiplication jobs will be slower, but they can be done in parallel.</p><pre><code class="language-none">using LinearAlgebra
BLAS.set_num_threads(1);
@btime parallelworker($As,$Bs);</code></pre><p>outputs:</p><pre><code class="language-none">681.954 ms (514 allocations: 755.34 MiB)</code></pre><p>This has some drawbacks: BLAS is also responsible for matrix factorizations, which will now run single threaded. If your program only needs to spawn 10 jobs then you will also not see any further improvement when running the code with even more julia threads, as those other threads have nothing to do. A possible solution to this is given by <a href="https://github.com/Jutho/Strided.jl">Strided.jl</a>, which is internally used by <a href="https://github.com/Jutho/TensorKit.jl">TensorKit.jl</a> and consequently also MPSKit. Strided has an option to subdivide multiplication jobs into smaller multiplication jobs distributed over julia threads. When BLAS is single threaded, those jobs will be done in parallel, and you may be able to further speed up your code! Controlling the number of threads over which strided will distribute the matrix multiplications can be done by calling:</p><pre><code class="language-none">Strided.enable_threaded_mul(); # enable the subdivision of jobs
Strided.set_num_threads(N); # set the number of threads strided will use</code></pre><p>In an ideal world we would have a julia implemention of BLAS, or some way to make the BLAS scheduler collaborate with the julia scheduler. Now however, the best performance can usually be achieved by experimenting with the number of julia and strided threads after disabling the BLAS threading.</p><h2 id="In-practice-1"><a class="docs-heading-anchor" href="#In-practice-1">In practice</a><a class="docs-heading-anchor-permalink" href="#In-practice-1" title="Permalink"></a></h2><p>Real world performance is dependent on the particular problem, and one typically needs to do some experimentation to get optimal settings. As an illustration I have benchmarked the time it takes to get environments of the second order time evolution operator for ising, with an mps of bond dimension 500.</p><p>I always took 50 samples and used the median timing. This may not be enough to do proper statistics, and there is even further randomness in the initial conditions, but it should be enough to get some kind of idea.</p><p><img src="../D_500_blas.png" alt/></p><p>BLAS scales really well initially. The bond dimension is pretty big, which translates to fairly large blocks being multiplied. However, after a certain point, we start to see diminishing returns. Nothing is gained from further parallization.</p><p>If we just take the last point (14 threads) and set BLAS threading to 1, we can fully leverage julia multithreading. The only variable to play with is in how many jobs every matrix multiplication should be subdivided.</p><p><img src="../D_500_strided.png" alt/></p><p>We clearly see that already by disabling BLAS multithreading we were able to get faster simulations, and allowing strided to further subdivide mutiplications iallows us to push the simulation even further! The optimal amount of strided jobs is very problem and architecture dependent. Below I remade the same plot at bond dimension 100. Because of the smaller bond dimension we don&#39;t benefit from having a large amount of jobs per multiplication. In fact, we are probably seeing all but numerical noise.</p><p><img src="../D_100_strided.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environments/">« Environments</a><a class="docs-footer-nextpage" href="../../tut/anyonic_statmech/">The hard hexagon model »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 January 2022 09:06">Monday 31 January 2022</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
