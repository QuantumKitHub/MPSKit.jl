<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The ising cft spectrum · MPSKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MPSKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Basics</a></li><li><a class="tocitem" href="../../man/conventions/">Conventions</a></li><li><a class="tocitem" href="../../man/states/">States</a></li><li><a class="tocitem" href="../../man/operators/">Operators</a></li><li><a class="tocitem" href="../../man/algorithms/">Algorithms</a></li><li><a class="tocitem" href="../../man/environments/">Environments</a></li><li><a class="tocitem" href="../../man/parallelism/">Parallelism in julia</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../anyonic_statmech/">The hard hexagon model</a></li><li class="is-active"><a class="tocitem" href>The ising cft spectrum</a><ul class="internal"><li><a class="tocitem" href="#exact-diagonalization-1"><span>exact diagonalization</span></a></li><li><a class="tocitem" href="#extracting-momentum-1"><span>extracting momentum</span></a></li><li><a class="tocitem" href="#finite-bond-dimension-1"><span>finite bond dimension</span></a></li></ul></li><li><a class="tocitem" href="../xxz_groundstate/">Analyzing the xxz model</a></li><li><a class="tocitem" href="../timeev/">DQPT in ising</a></li><li><a class="tocitem" href="../haldane/">The haldane gap</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/lib/">Library documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>The ising cft spectrum</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The ising cft spectrum</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maartenvd/MPSKit.jl/blob/master/docs/src/tut/isingcft.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-ising-cft-spectrum-1"><a class="docs-heading-anchor" href="#The-ising-cft-spectrum-1">The ising cft spectrum</a><a class="docs-heading-anchor-permalink" href="#The-ising-cft-spectrum-1" title="Permalink"></a></h1><p>In this tutorial we will try to plot the finite size cft spectrum for quantum ising, first with exact diagonalization and then going to larger system sizes using mps techniques. The required packages are</p><pre><code class="language-julia">using MPSKit, MPSKitModels, TensorKit, Plots, KrylovKit
using LinearAlgebra:eigen,diagm,Hermitian;</code></pre><p>The ising hamiltonian has already been implemented:</p><pre><code class="language-julia">nonsym_ising_ham();</code></pre><p>MPSKit does not support periodic matrix product states, we only deal with the &#39;usual&#39; open boundary mps&#39;s. However we can still impose periodic boundary conditions on the hamiltonian itself, and the mps will then restore translation invariance. To impose periodic boundary conditions you should call:</p><pre><code class="language-julia">circumference = 12;
ham = periodic_boundary_conditions(nonsym_ising_ham(),circumference);</code></pre><h2 id="exact-diagonalization-1"><a class="docs-heading-anchor" href="#exact-diagonalization-1">exact diagonalization</a><a class="docs-heading-anchor-permalink" href="#exact-diagonalization-1" title="Permalink"></a></h2><p>We implemented rudimentary support for exact diagonalization using a trick - by again representing it as a matrix product state but without truncating the bond dimension. The idea is illustrated below.</p><p><img src="../ed_diagram.png" alt/></p><p>Optimizing the middle tensor is then equivalent to optimizing a state in the entire hilbert space.</p><p>To call it in julia, do:</p><pre><code class="language-julia">(energies,states) = exact_diagonalization(ham,num=18,alg=Lanczos(krylovdim=200));
plot(real.(energies),seriestype=:scatter,legend=false,yaxis=&quot;energy&quot;,xaxis=&quot;#eigenvalue&quot;)</code></pre><p><img src="../ising_cft_en.png" alt/></p><p>Note the large krylov dimension - degenerate eigenvalues are notoriously difficult for iterative methods.</p><h2 id="extracting-momentum-1"><a class="docs-heading-anchor" href="#extracting-momentum-1">extracting momentum</a><a class="docs-heading-anchor-permalink" href="#extracting-momentum-1" title="Permalink"></a></h2><p>Given a state, we would like to assign a momentum label. A natural way to do this is by creating the translation operator, as an mpo:</p><p><img src="../translation_mpo.png" alt/></p><pre><code class="language-julia">id = complex(isomorphism(ℂ^2,ℂ^2));
@tensor O[-1 -2;-3 -4] := id[-1,-3]*id[-2,-4]
mpo = DenseMPO(O);</code></pre><p>We don&#39;t quite want an infinite mpo - which simply repeats this mpo ad infinitum, but would rather want to impose periodic boundary conditions to this mpo:</p><pre><code class="language-julia">mpo = periodic_boundary_conditions(mpo,circumference);</code></pre><p>You can now simply calculate the momentum of the groundstate as:</p><pre><code class="language-julia">angle(dot(states[1],mpo*states[1]))</code></pre><p>However, there is a subtlety because of the degenerate energy eigenvalues. The eigensolver will find an orthonormal basis within every energy subspace, so states within an energy subspace will not necessarily be momentum eigenstates. To assign a momentum label, we would have to diagonalize the translation operator.</p><pre><code class="language-julia">function fix_degeneracies(basis)
    N = fill(0.0+0im,length(basis),length(basis));
    T = fill(0.0+0im,length(basis),length(basis));
    for i in 1:length(basis), j in 1:length(basis)
        T[i,j] = dot(basis[i],mpo*basis[j]);
        N[i,j] = dot(basis[i],basis[j]);
    end


    (vals,vecs) = eigen(Hermitian(N));
    T = vecs&#39;*T*vecs
    T/=diagm(vals);

    (vals,vecs) = eigen(T);
    angle.(vals);

end

momenta = Float64[];


append!(momenta,fix_degeneracies(states[1:1]));
append!(momenta,fix_degeneracies(states[2:2]));
append!(momenta,fix_degeneracies(states[3:3]));
append!(momenta,fix_degeneracies(states[4:5]));
append!(momenta,fix_degeneracies(states[6:9]));
append!(momenta,fix_degeneracies(states[10:11]));
append!(momenta,fix_degeneracies(states[12:12]));
append!(momenta,fix_degeneracies(states[13:16]));
append!(momenta,fix_degeneracies(states[17:18]));

plot(momenta,real.(energies[1:18]),seriestype=:scatter,xaxis=&quot;momentum&quot;,yaxis=&quot;energy&quot;,legend=false)</code></pre><p><img src="../ed_spectrum.png" alt/></p><h2 id="finite-bond-dimension-1"><a class="docs-heading-anchor" href="#finite-bond-dimension-1">finite bond dimension</a><a class="docs-heading-anchor-permalink" href="#finite-bond-dimension-1" title="Permalink"></a></h2><p>Not much changes at finite bond dimension, except we can now reach higher system sizes.</p><pre><code class="language-julia">circumference = 20;
ham = periodic_boundary_conditions(nonsym_ising_ham(),circumference);

state = FiniteMPS(circumference,ℂ^2,ℂ^50 #=bond dimension=#);

(gs,envs) = find_groundstate(state,ham,DMRG());</code></pre><p>Excitations on top of the groundstate can be found using the quasiparticle ansatz. This returns quasiparticle states, which you can just convert back to the usual finite mps&#39;s.</p><pre><code class="language-julia">(ens,qps) = excitations(ham,QuasiparticleAnsatz(),gs,envs,num=16);
qpstates = map(qp-&gt;convert(FiniteMPS,qp),qps);</code></pre><p>And we get the spectrum:</p><pre><code class="language-julia">states = [gs;qpstates];
energies = map(x-&gt;sum(expectation_value(x,ham)),states);

mpo = periodic_boundary_conditions(DenseMPO(O),circumference);

momenta = Float64[];

append!(momenta,fix_degeneracies(states[1:1]));
append!(momenta,fix_degeneracies(states[2:2]));
append!(momenta,fix_degeneracies(states[3:3]));
append!(momenta,fix_degeneracies(states[4:5]));
append!(momenta,fix_degeneracies(states[6:9]));
append!(momenta,fix_degeneracies(states[10:11]));
append!(momenta,fix_degeneracies(states[12:12]));
append!(momenta,fix_degeneracies(states[13:16]));

plot(momenta,real.(energies[1:16]),seriestype=:scatter,xaxis=&quot;momentum&quot;,yaxis=&quot;energy&quot;,legend=false)</code></pre><p><img src="../qp_spectrum.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../anyonic_statmech/">« The hard hexagon model</a><a class="docs-footer-nextpage" href="../xxz_groundstate/">Analyzing the xxz model »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 May 2023 12:36">Monday 15 May 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
