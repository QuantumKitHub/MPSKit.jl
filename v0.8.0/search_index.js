var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library-documentation-1","page":"Library documentation","title":"Library documentation","text":"","category":"section"},{"location":"lib/lib/#lib_states-1","page":"Library documentation","title":"States","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"FiniteMPS\nInfiniteMPS\nMPSComoving\nMPSMultiline","category":"page"},{"location":"lib/lib/#MPSKit.FiniteMPS","page":"Library documentation","title":"MPSKit.FiniteMPS","text":"FiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor} <: AbstractFiniteMPS\n\nType that represents a finite Matrix Product State.\n\nFields\n\nALs – left-gauged MPS tensors\nARs – right-gauged MPS tensors\nACs – center-gauged MPS tensors\nCLs – gauge tensors\n\nWhere each is entry can be a tensor or missing.\n\nNotes\n\nBy convention, we have that:\n\nAL[i] * CL[i+1] = AC[i] = CL[i] * AR[i]\nAL[i]' * AL[i] = 1\nAR[i] * AR[i]' = 1\n\n\n\nConstructors\n\nFiniteMPS([f, eltype], physicalspaces::Vector{<:Union{S, CompositeSpace{S}},\n          virtualspaces::Vector{<:Union{S, CompositeSpace{S}};\n          normalize=true) where {S<:ElementarySpace}\nFiniteMPS([f, eltype], physicalspaces::Vector{<:Union{S,CompositeSpace{S}}},\n          maxvirtualspace::S;\n          normalize=true, left=oneunit(S), right=oneunit(S)) where {S<:ElementarySpace}\nFiniteMPS([f, eltype], N::Int, physicalspace::Union{S,CompositeSpace{S}},\n          maxvirtualspace::S;\n          normalize=true, left=oneunit(S), right=oneunit(S)) where {S<:ElementarySpace}\nFiniteMPS(As::Vector{<:GenericMPSTensor}; normalize=false, overwrite=false)\n\nConstruct an MPS via a specification of physical and virtual spaces, or from a list of tensors As. All cases reduce to the latter.\n\nArguments\n\nAs::Vector{<:GenericMPSTensor}: vector of site tensors\nf::Function=rand: initializer function for tensor data\neltype::Type{<:Number}=ComplexF64: scalar type of tensors\nphysicalspaces::Vector{<:Union{S, CompositeSpace{S}}: list of physical spaces\nN::Int: number of sites\nphysicalspace::Union{S,CompositeSpace{S}}: local physical space\nvirtualspaces::Vector{<:Union{S, CompositeSpace{S}}: list of virtual spaces\nmaxvirtualspace::S: maximum virtual space\n\nKeywords\n\nnormalize: normalize the constructed state\noverwrite=false: overwrite the given input tensors\nleft=oneunit(S): left-most virtual space\nright=oneunit(S): right-most virtual space\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.InfiniteMPS","page":"Library documentation","title":"MPSKit.InfiniteMPS","text":"InfiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor} <: AbtractMPS\n\nType that represents an infinite Matrix Product State.\n\nFields\n\nAL – left-gauged MPS tensors\nAR – right-gauged MPS tensors\nAC – center-gauged MPS tensors\nCR – gauge tensors\n\nNotes\n\nBy convention, we have that:\n\nAL[i] * CR[i] = AC[i] = CR[i-1] * AR[i]\nAL[i]' * AL[i] = 1\nAR[i] * AR[i]' = 1\n\n\n\nConstructors\n\nInfiniteMPS([f, eltype], physicalspaces::Vector{<:Union{S, CompositeSpace{S}},\n            virtualspaces::Vector{<:Union{S, CompositeSpace{S}}) where\n            {S<:ElementarySpace}\nInfiniteMPS(As::AbstractVector{<:GenericMPSTensor}; tol=1e-14, maxiter=100)\nInfiniteMPS(ALs::AbstractVector{<:GenericMPSTensor}, C₀::MPSBondTensor;\n            tol=1e-14, maxiter=100)\n\nConstruct an MPS via a specification of physical and virtual spaces, or from a list of tensors As, or a list of left-gauged tensors ALs.\n\nArguments\n\nAs::AbstractVector{<:GenericMPSTensor}: vector of site tensors\nALs::AbstractVector{<:GenericMPSTensor}: vector of left-gauged site tensors\nC₀::MPSBondTensor: initial gauge tensor\nf::Function=rand: initializer function for tensor data\neltype::Type{<:Number}=ComplexF64: scalar type of tensors\nphysicalspaces::AbstractVector{<:Union{S, CompositeSpace{S}}: list of physical spaces\nvirtualspaces::AbstractVector{<:Union{S, CompositeSpace{S}}: list of virtual spaces\n\nKeywords\n\ntol: gauge fixing tolerance\nmaxiter: gauge fixing maximum iterations\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSComoving","page":"Library documentation","title":"MPSKit.MPSComoving","text":"MPSComoving(leftstate,window,rightstate)\n\nmuteable window of tensors on top of an infinite chain\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Operators-1","page":"Library documentation","title":"Operators","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"SparseMPO\nDenseMPO\nMPOHamiltonian","category":"page"},{"location":"lib/lib/#MPSKit.DenseMPO","page":"Library documentation","title":"MPSKit.DenseMPO","text":"Represents a dense periodic mpo\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPOHamiltonian","page":"Library documentation","title":"MPSKit.MPOHamiltonian","text":"MPOHamiltonian\n\nrepresents a general periodic quantum hamiltonian\n\nreally just a sparsempo, with some garantuees on its structure\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Environments-1","page":"Library documentation","title":"Environments","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPSKit.AbstractInfEnv\nMPSKit.PerMPOInfEnv\nMPSKit.MPOHamInfEnv\nMPSKit.FinEnv\nMPSKit.IDMRGEnvs","category":"page"},{"location":"lib/lib/#MPSKit.AbstractInfEnv","page":"Library documentation","title":"MPSKit.AbstractInfEnv","text":"Abstract environment for an infinite state\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PerMPOInfEnv","page":"Library documentation","title":"MPSKit.PerMPOInfEnv","text":"This object manages the periodic mpo environments for an MPSMultiline\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPOHamInfEnv","page":"Library documentation","title":"MPSKit.MPOHamInfEnv","text":"This object manages the hamiltonian environments for an InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.FinEnv","page":"Library documentation","title":"MPSKit.FinEnv","text":"FinEnv keeps track of the environments for FiniteMPS / MPSComoving\nIt automatically checks if the queried environment is still correctly cached and if not - recalculates\n\nif above is set to nothing, above === below.\n\nopp can be a vector of nothing, in which case it'll just be the overlap\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Generic-actions-1","page":"Library documentation","title":"Generic actions","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"∂C\n∂∂C\n∂AC\n∂∂AC\n∂AC2\n∂∂AC2\n\nc_proj\nac_proj\nac2_proj\n\nexpectation_value","category":"page"},{"location":"lib/lib/#MPSKit.∂C","page":"Library documentation","title":"MPSKit.∂C","text":"Zero-site derivative (the C matrix to the right of pos)\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.∂AC2","page":"Library documentation","title":"MPSKit.∂AC2","text":"Two-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.expectation_value","page":"Library documentation","title":"MPSKit.expectation_value","text":"calculates the expectation value of op, where op is a plain tensormap where the first index works on site at\n\n\n\n\n\ncalculates the expectation value of op = op1op2op3*... (ie an N site operator) starting at site at\n\n\n\n\n\ncalculates the expectation value for the given operator/hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#Algorithms-1","page":"Library documentation","title":"Algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"find_groundstate\ntimestep\nleading_boundary\ndynamicaldmrg\nchangebonds\nexcitations\napproximate","category":"page"},{"location":"lib/lib/#MPSKit.find_groundstate","page":"Library documentation","title":"MPSKit.find_groundstate","text":"find_groundstate(Ψ, H, [environments]; kwargs...)\nfind_groundstate(Ψ, H, algorithm, environments)\n\nCompute the groundstate for Hamiltonian H with initial guess Ψ. If not specified, an optimization algorithm will be attempted based on the supplied keywords.\n\nArguments\n\nΨ::AbstractMPS: initial guess\nH::AbstractMPO: operator for which to find the groundstate\n[environments]: MPS environment manager\nalgorithm: optimization algorithm\n\nKeywords\n\ntol::Float64: tolerance for convergence criterium\nmaxiter::Int: maximum amount of iterations\nverbose::Bool: display progress information\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.timestep","page":"Library documentation","title":"MPSKit.timestep","text":"timestep(Ψ, H, dt, algorithm, environments)\ntimestep!(Ψ, H, dt, algorithm, environments)\n\nCompute the time-evolved state Ψ  exp(-iHdt) Ψ.\n\nArguments\n\nΨ::AbstractMPS: current state\nH::AbstractMPO: evolution operator\ndt::Number: timestep\nalgorithm: evolution algorithm\n[environments]: environment manager\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.leading_boundary","page":"Library documentation","title":"MPSKit.leading_boundary","text":"leading_boundary(state,opp,alg,envs=environments(state,ham))\n\napproximate the leading eigenvector for opp\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.excitations","page":"Library documentation","title":"MPSKit.excitations","text":"excitations(H, algorithm::QuasiparticleAnsatz, Ψ::FiniteQP, [left_environments],\n            [right_environments]; num=1)\nexcitations(H, algorithm::QuasiparticleAnsatz, Ψ::InfiniteQP, [left_environments],\n            [right_environments]; num=1, solver=Defaults.solver)\nexcitations(H, algorithm::FiniteExcited, Ψs::NTuple{<:Any, <:FiniteMPS};\n            num=1, init=copy(first(Ψs)))\n\nCompute the first excited states and their energy gap above a groundstate.\n\nArguments\n\nH::AbstractMPO: operator for which to find the excitations\nalgorithm: optimization algorithm\nΨ::QP: initial quasiparticle guess\nΨs::NTuple{N, <:FiniteMPS}: N first excited states\n[left_environments]: left groundstate environment\n[right_environments]: right groundstate environment\n\nKeywords\n\nnum::Int: number of excited states to compute\nsolver: algorithm for the linear solver of the quasiparticle environments\ninit: initial excited state guess\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#lib_gs_alg-1","page":"Library documentation","title":"Groundstate algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"VUMPS\nIDMRG1\nIDMRG2\nDMRG\nDMRG2\nGradientGrassmann","category":"page"},{"location":"lib/lib/#MPSKit.VUMPS","page":"Library documentation","title":"MPSKit.VUMPS","text":"VUMPS{F} <: Algorithm\n\nVariational optimization algorithm for uniform matrix product states, as introduced in https://arxiv.org/abs/1701.07035.\n\nFields\n\ntol_galerkin::Float64: tolerance for convergence criterium\ntol_gauge::Float64: tolerance for gauging algorithm\nmaxiter::Int: maximum amount of iterations\northmaxiter::Int: maximum amount of gauging iterations\nfinalize::F: user-supplied function which is applied after each iteration, with   signature finalize(iter, Ψ, H, envs) -> Ψ, envs\nverbose::Bool: display progress information\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.IDMRG1","page":"Library documentation","title":"MPSKit.IDMRG1","text":"IDMRG1{A} <: Algorithm\n\nSingle site infinite DMRG algorithm for finding groundstates.\n\nFields\n\ntol_galerkin::Float64: tolerance for convergence criterium\ntol_gauge::Float64: tolerance for gauging algorithm\neigalg::A: eigensolver algorithm\nmaxiter::Int: maximum number of outer iterations\nverbose::Bool: display progress information\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.IDMRG2","page":"Library documentation","title":"MPSKit.IDMRG2","text":"IDMRG2{A} <: Algorithm\n\n2-site infinite DMRG algorithm for finding groundstates.\n\nFields\n\ntol_galerkin::Float64: tolerance for convergence criterium\ntol_gauge::Float64: tolerance for gauging algorithm\neigalg::A: eigensolver algorithm\nmaxiter::Int: maximum number of outer iterations\nverbose::Bool: display progress information\ntrscheme: truncation algorithm for [tsvd]TensorKit.tsvd\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.DMRG","page":"Library documentation","title":"MPSKit.DMRG","text":"DMRG{A,F} <: Algorithm\n\nSingle site DMRG algorithm for finding groundstates.\n\nFields\n\ntol::Float64: tolerance for convergence criterium\neigalg::A: eigensolver algorithm\nmaxiter::Int: maximum number of outer iterations\nverbose::Bool: display progress information\nfinalize::F: user-supplied function which is applied after each iteration, with   signature finalize(iter, Ψ, H, envs) -> Ψ, envs\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.DMRG2","page":"Library documentation","title":"MPSKit.DMRG2","text":"DMRG2{A,F} <: Algorithm\n\n2-site  DMRG algorithm for finding groundstates.\n\nFields\n\ntol::Float64: tolerance for convergence criterium\neigalg::A: eigensolver algorithm\nmaxiter::Int: maximum number of outer iterations\nverbose::Bool: display progress information\nfinalize::F: user-supplied function which is applied after each iteration, with   signature finalize(iter, Ψ, H, envs) -> Ψ, envs\ntrscheme: truncation algorithm for [tsvd]TensorKit.tsvd\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.GradientGrassmann","page":"Library documentation","title":"MPSKit.GradientGrassmann","text":"GradientGrassmann <: Algorithm\n\nVariational gradient-based optimization algorithm that keeps the MPS in left-canonical form, as points on a Grassmann manifold. The optimization is then a Riemannian gradient descent  with a preconditioner to induce the metric from the Hilbert space inner product.\n\nFields\n\nmethod::OptimKit.OptimizationAlgorithm: algorithm to perform the gradient search\nfinalize!::Function: user-supplied function which is applied after each iteration, with   signature finalize!(x::GrassmannMPS.ManifoldPoint, f, g, numiter) -> x, f, g\n\n\n\nConstructors\n\nGradientGrassmann(; kwargs...)\n\nKeywords\n\nmethod=ConjugateGradient: instance of optimization algorithm, or type of optimization   algorithm to construct\nfinalize!: finalizer algorithm\ntol::Float64: tolerance for convergence criterium\nmaxiter::Int: maximum amount of iterations\nverbosity::Int: level of information display\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_time_alg-1","page":"Library documentation","title":"Time evolution algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"TDVP\nTDVP2\nTaylorCluster\nWII","category":"page"},{"location":"lib/lib/#MPSKit.TDVP","page":"Library documentation","title":"MPSKit.TDVP","text":"TDVP{A} <: Algorithm\n\nSingle site TDVP algorithm for time evolution.\n\nFields\n\nexpalg::A: exponentiator algorithm\ntolgauge::Float64: tolerance for gauging algorithm\nmaxiter::Int: maximum amount of gauging iterations\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.TDVP2","page":"Library documentation","title":"MPSKit.TDVP2","text":"TDVP2{A} <: Algorithm\n\n2-site TDVP algorithm for time evolution.\n\nFields\n\nexpalg::A: exponentiator algorithm\ntolgauge::Float64: tolerance for gauging algorithm\nmaxiter::Int: maximum amount of gauging iterations\ntrscheme: truncation algorithm for [tsvd]TensorKit.tsvd\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_bound_alg-1","page":"Library documentation","title":"Leading boundary algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"VUMPS\nPowerMethod","category":"page"},{"location":"lib/lib/#lib_bc_alg-1","page":"Library documentation","title":"Bond change algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"OptimalExpand\nRandExpand\nVUMPSSvdCut\nSvdCut","category":"page"},{"location":"lib/lib/#MPSKit.OptimalExpand","page":"Library documentation","title":"MPSKit.OptimalExpand","text":"expands the given mps using the algorithm given in the vumps paper\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.RandExpand","page":"Library documentation","title":"MPSKit.RandExpand","text":"expands the bond dimension by adding random unitary vectors\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.VUMPSSvdCut","page":"Library documentation","title":"MPSKit.VUMPSSvdCut","text":"use an idmrg2 step to truncate/expand the bond dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SvdCut","page":"Library documentation","title":"MPSKit.SvdCut","text":"Truncate a given state using svd\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#[Excitations]-1","page":"Library documentation","title":"[Excitations]","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"QuasiparticleAnsatz\nFiniteExcited","category":"page"},{"location":"lib/lib/#MPSKit.QuasiparticleAnsatz","page":"Library documentation","title":"MPSKit.QuasiparticleAnsatz","text":"QuasiparticleAnsatz <: Algorithm\n\nOptimization algorithm for quasiparticle excitations on top of MPS groundstates, as introduced in this paper.\n\nFields\n\ntoler::Float64: tolerance for convergence criterium\nkrylovdim::Int: Krylov subspace dimension\n\n\n\n\n\n","category":"type"},{"location":"man/parallelism/#Parallelism-in-julia-1","page":"Parallelism in julia","title":"Parallelism in julia","text":"","category":"section"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"Julia has really great parallelism infrastructure, but there is a caveat that is relevant for all algorithms implemented in mpskit. The julia threads do not play nicely together with the BLAS threads, which are the threads used for matrix matrix multiplications (amongst other things).","category":"page"},{"location":"man/parallelism/#The-problem-1","page":"Parallelism in julia","title":"The problem","text":"","category":"section"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"The default behaviour is to have some BLAS threads running, which accept multiplication jobs, to which the julia threads can then submit jobs. These jobs are in turn sequentially executed over the BLAS threads. This means that if your program is waiting on a matrix multiplication to finish, it can not in parallel do other matrix multiplications!","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"The behaviour can be demonstrated using the following bit of code:","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"function parallelworker(As,Bs)\n   temp = similar.(As);\n   @sync for i in 1:length(As)\n       Threads.@spawn mul!($temp[i], $As[i],$Bs[i])\n   end\n   sum(temp);\nend\n\nfunction serialworker(As,Bs)\n    temp = similar.(As);\n    for i in 1:length(As)\n        mul!(temp[i], As[i],Bs[i])\n    end\n    sum(temp);\nend\n\nAs = [rand(1000,1000) for a in 1:50];\nBs = [rand(1000,1000) for b in 1:50];\n\n@btime parallelworker($As,$Bs);\n@btime serialworker($As,$Bs);","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"running this on my laptop with 4 julia threads and 4 BLAS threads, I see the following:","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"998.506 ms (513 allocations: 755.34 MiB)\n1.080 s (199 allocations: 755.32 MiB)","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"The julia threads give next to no speedup! Despite mpskit trying to implement parallel code, you will most likely not be able to exploit this to the fullest when running julia with the default settings.","category":"page"},{"location":"man/parallelism/#The-possible-solution-1","page":"Parallelism in julia","title":"The possible solution","text":"","category":"section"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"The short term 'solution' is to disable BLAS threads altogether. Multiplication jobs are then run in the julia thread that call them. Individual multiplication jobs will be slower, but they can be done in parallel.","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"using LinearAlgebra\nBLAS.set_num_threads(1);\n@btime parallelworker($As,$Bs);","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"outputs:","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"681.954 ms (514 allocations: 755.34 MiB)","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"This has some drawbacks: BLAS is also responsible for matrix factorizations, which will now run single threaded. If your program only needs to spawn 10 jobs then you will also not see any further improvement when running the code with even more julia threads, as those other threads have nothing to do. A possible solution to this is given by Strided.jl, which is internally used by TensorKit.jl and consequently also MPSKit. Strided has an option to subdivide multiplication jobs into smaller multiplication jobs distributed over julia threads. When BLAS is single threaded, those jobs will be done in parallel, and you may be able to further speed up your code! Controlling the number of threads over which strided will distribute the matrix multiplications can be done by calling:","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"Strided.enable_threaded_mul(); # enable the subdivision of jobs\nStrided.set_num_threads(N); # set the number of threads strided will use","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"In an ideal world we would have a julia implemention of BLAS, or some way to make the BLAS scheduler collaborate with the julia scheduler. Now however, the best performance can usually be achieved by experimenting with the number of julia and strided threads after disabling the BLAS threading.","category":"page"},{"location":"man/parallelism/#In-practice-1","page":"Parallelism in julia","title":"In practice","text":"","category":"section"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"Real world performance is dependent on the particular problem, and one typically needs to do some experimentation to get optimal settings. As an illustration I have benchmarked the time it takes to get environments of the second order time evolution operator for ising, with an mps of bond dimension 500.","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"I always took 50 samples and used the median timing. This may not be enough to do proper statistics, and there is even further randomness in the initial conditions, but it should be enough to get some kind of idea.","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"(Image: )","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"BLAS scales really well initially. The bond dimension is pretty big, which translates to fairly large blocks being multiplied. However, after a certain point, we start to see diminishing returns. Nothing is gained from further parallization.","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"If we just take the last point (14 threads) and set BLAS threading to 1, we can fully leverage julia multithreading. The only variable to play with is in how many jobs every matrix multiplication should be subdivided.","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"(Image: )","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"We clearly see that already by disabling BLAS multithreading we were able to get faster simulations, and allowing strided to further subdivide mutiplications iallows us to push the simulation even further! The optimal amount of strided jobs is very problem and architecture dependent. Below I remade the same plot at bond dimension 100. Because of the smaller bond dimension we don't benefit from having a large amount of jobs per multiplication. In fact, we are probably seeing all but numerical noise.","category":"page"},{"location":"man/parallelism/#","page":"Parallelism in julia","title":"Parallelism in julia","text":"(Image: )","category":"page"},{"location":"tut/timeev/#DQPT-in-ising-1","page":"DQPT in ising","title":"DQPT in ising","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"In this tutorial we will try to reproduce the results from this paper. The needed packages are","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"using MPSKit,MPSKitModels,TensorKit,ProgressMeter","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Dynamical quantum phase transitions (DQPT in short) are signatures of equilibrium phase transitions in a dynamical quantity - the loschmidth echo. This quantity is given by L(t) = frac-2N ln(  psi(t)  psi(0)  ) where N is the system size. One typically starts from a groundstate and then quenches the hamiltonian to a different point. Non analycities in the loschmidth echo are called 'dynamical quantum phase transitions'.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"In the mentioned paper they work with H(g) = - sum^N-1_i=1 sigma^z_i sigma^z_i+1 + g sum_i=1^N sigma^x_i and show that divergences occur when quenching across the critical point (g₀→g₁) for t^*_n = t^*(n+frac12) with t^* = pie(g_1k^*), cos(k^*) = (1+g_0 g_1)  (g_0 + g_1), e(gk) = sqrt(g-cos k)^2 + sin^2 k.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"The outline of the tutorial is as follows. We will pick g₀ = 0.5, g₁ = 2.0, perform the time evolution at different system sizes and compare with the thermodynamic limit. For those g we expect non-analicities to occur at t_n  235 (n + 12).","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"First we construct the hamiltonian in mpo form:","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function ising_ham(g)\n    (σˣ,σʸ,σᶻ) = nonsym_spintensors(1//2).*2;\n\n    data = Array{Any,3}(missing,1,3,3);\n    data[1,1,1] = one(σˣ); data[1,end,end] = one(σˣ);\n    data[1,1,2] = -σᶻ;\n    data[1,2,end] = σᶻ;\n    data[1,1,end] = g*σˣ;\n\n    MPOHamiltonian(data);\nend","category":"page"},{"location":"tut/timeev/#Finite-MPS-quenching-1","page":"DQPT in ising","title":"Finite MPS quenching","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Construct an initial finite system","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"len = 20;\ninit = FiniteMPS(rand,ComplexF64,len,ℂ^2,ℂ^10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Find the pre-quench groundstate","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(ψ₀,_) = find_groundstate(init,ising_ham(0.5),DMRG());","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"We can define a help function that measures the loschmith echo","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"echo(ψ₀::FiniteMPS,ψₜ::FiniteMPS) = -2*log(abs(dot(ψ₀,ψₜ)))/length(ψ₀)\n@assert isapprox(echo(ψ₀,ψ₀),0,atol=1e-10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"we will initially use a 2site tdvp scheme to increase the bond dimension while time evolving, and later on switch to a faster one-site scheme. A single timestep can be done using","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"ψₜ = deepcopy(ψ₀);\ndt = 0.01;\n\n(ψₜ,envs) = timestep(ψₜ,ising_ham(2),dt,TDVP2(trscheme=truncdim(20)));","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"\"envs\" is a kind of cache object that keeps track of all environments in ψ. It is often advantageous to re-use the environment, so that mpskit doesn't need to recalculate everything.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Putting it all together, we get","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function finite_sim(len; dt = 0.05, finaltime = 5.0)\n    ψ₀ = FiniteMPS(rand,ComplexF64,len,ℂ^2,ℂ^10);\n    (ψ₀,_) = find_groundstate(ψ₀,ising_ham(0.5),DMRG());\n\n    post_quench_ham = ising_ham(2);\n    ψₜ = deepcopy(ψ₀);\n    envs = environments(ψₜ,post_quench_ham);\n\n    echos = [echo(ψₜ,ψ₀)];\n    times = collect(0:dt:finaltime);\n\n    @showprogress for t = times[2:end]\n        alg = t > 3*dt ? TDVP() : TDVP2(trscheme = truncdim(50))\n        (ψₜ,envs) = timestep(ψₜ,post_quench_ham,dt,alg,envs);\n        push!(echos,echo(ψₜ,ψ₀))\n    end\n\n    return (times,echos)\nend","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(Image: )","category":"page"},{"location":"tut/timeev/#Infinite-MPS-quenching-1","page":"DQPT in ising","title":"Infinite MPS quenching","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Similarly we start with an initial infinite state","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"init = InfiniteMPS([ℂ^2],[ℂ^10]);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"and find the pre-quench groundstate","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(ψ₀,_) = find_groundstate(init,ising_ham(0.5),Vumps());","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"The dot product of two infinite matrix product states scales as  alpha ^N where α is the dominant eigenvalue of the transfer matrix. It is this α that is returned when calling","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"dot(ψ₀,ψ₀)","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"so the loschmidth echo takes on the pleasant form","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"echo(ψ₀::InfiniteMPS,ψₜ::InfiniteMPS) = -2*log(abs(dot(ψ₀,ψₜ)))\n@assert isapprox(echo(ψ₀,ψ₀),0,atol=1e-10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"This time we cannot use a 2site scheme to grow the bond dimension, as this isn't implemented (yet). Instead, we have to make use of the changebonds machinery. Multiple algorithms are available, but we will only focus on OptimalEpand(). Growing the bond dimension by 5 can be done by calling:","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"ψₜ = deepcopy(ψ₀);\n(ψₜ,envs) = changebonds(ψₜ,ising_ham(2),OptimalExpand(trscheme=truncdim(5)));","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"a single timestep is easy","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"dt = 0.01;\n\n(ψₜ,envs) = timestep(ψₜ,ising_ham(2),dt,Tdvp(),envs);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"With performance in mind we should once again try to re-use these \"envs\" cache objects. The final code is","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function infinite_sim(dt = 0.05, finaltime = 5.0)\n    ψ₀ = InfiniteMPS([ℂ^2],[ℂ^10]);\n    (ψ₀,_) = find_groundstate(ψ₀,ising_ham(0.5),Vumps());\n\n    post_quench_ham = ising_ham(2);\n    ψₜ = deepcopy(ψ₀);\n    envs = environments(ψₜ,post_quench_ham);\n\n    echos = [echo(ψₜ,ψ₀)];\n    times = collect(0:dt:finaltime);\n\n    @showprogress for t = times[2:end]\n        if t < 50*dt # if t is sufficiently small, we increase the bond dimension\n            (ψₜ,envs) = changebonds(ψₜ,post_quench_ham,OptimalExpand(trscheme=truncdim(1)),envs)\n        end\n        (ψₜ,envs) = timestep(ψₜ,post_quench_ham,dt,Tdvp(),envs);\n        push!(echos,echo(ψₜ,ψ₀))\n    end\n\n    return (times,echos)\nend","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(Image: )","category":"page"},{"location":"man/environments/#um_environments-1","page":"Environments","title":"Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"In many tensor network algorithms we encounter partially contracted tensor networks. In dmrg for example, one needs to know the sum of all the hamiltonian contributions left and right of the site that we want to optimize. If you then optimize the neighboring site to the right, you only need to add one new contribution to the previous sum of hamiltonian contributions.","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This kind of information is stored in the environment objects (at the moment called \"Cache\" in our code, but the name is subject to change). The goal is that the user should preferably never have to deal with the caches, but being aware of the inner workings may allow you to write more efficient code. That is why they are nonetheless included in the manual.","category":"page"},{"location":"man/environments/#Finite-Environments-1","page":"Environments","title":"Finite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"When you create a state and a hamiltonian:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"an environment object can be created by calling","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache = environments(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"The partially contracted mpohamiltonian left of site i can then be queried using:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This may take some time, but a subsequent call to","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i-1,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Should pretty much be free. Behind the scenes the cache stored all tensors it used to calculate leftenv (state.AL[1 .. i]) and when queried again, it checks if the tensors it previously used are identical (using ===). If so, it can simply return the previously stored results. If not, it will recalculate again. If you update a tensor in-place, the caches cannot know using === that the actual tensors have changed. If you do this, you have to call poison!(state,i).","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"As an optional argument, many algorithms allow you to pass in an environment object, and they also return an updated one. Therefore, for time evolution code, it is more efficient to give it the updated caches every time step, instead of letting it recalculate.","category":"page"},{"location":"man/environments/#Infinite-Environments-1","page":"Environments","title":"Infinite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Infinite Environments are very similar :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\ncache = environments(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"There are also some notable differences. Infinite environments typically require solving linear problems or eigenvalue problems iteratively with finite precision. To find out what precision we used we can type:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"(cache.tol,cache.maxiter)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"To recalculate with a different precision :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache.tol=1e-8;\nrecalculate!(cache,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Unlike their finite counterparts, recalculating is not done automatically. To get the environment for a different state one has to recalculate explicitly!","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"different_state = InfiniteMPS([ℂ^2],[ℂ^10]);\nrecalculate!(cache,different_state)\nleftenv(cache,3,different_state)","category":"page"},{"location":"man/conventions/#Conventions-1","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"MPSKit is build on top of TensorKit, which in turn defines general (codomain ← domain) tensormaps. It is necessary to concretely define what we should consider an mps tensor (for example - what leg is its physical leg?), a bond tensor, and an mpo tensor.","category":"page"},{"location":"man/conventions/#MPS-tensors-1","page":"Conventions","title":"MPS tensors","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"The general definition of an mps tensor is as follows","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"(Image: )","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"mps tensors are well defined for any amount of physical legs and InfiniteMPS/FiniteMPS handle these general N-leg tensors just fine. This is necessary in for example peps code, where the number of physical spaces of a boundary mps tensor is 2.","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"However our operators MPOHamiltonian/DenseMPO both only work on mps tensors with one leg. There is no fundamental problem, anyone is free to implement new operators working on the more general mps tensors.","category":"page"},{"location":"man/conventions/#Bond-tensors-1","page":"Conventions","title":"Bond tensors","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"The mps bond tensors are square tensormaps, mapping a virtual space to the same virtual space. (Image: )","category":"page"},{"location":"man/conventions/#MPO-tensors-1","page":"Conventions","title":"MPO tensors","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"MPO tensors are used in both statistical mechanics problems and in the definition of quantum hamiltonians. Graphically, they can be represented as follows","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"(Image: )","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"The numbering of spaces results in an at first glance not very intuitive ordering of (virtual,physical,physical,virtual) spaces.","category":"page"},{"location":"man/conventions/#Planarity-1","page":"Conventions","title":"Planarity","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"MPSKit tries to be as planar as possible, braidings are avoided as often as possible. As a result, it can handle anyonic/fermionic symmetries. Behind the scenes we always check if a contraction is done with tensors for which the braiding rules are trivial - and if not we use TensorKit's @planar macro. The logic of this switching between normal and planar tensor contractions is contained in a private @plansor macro. This is mostly an implementation detail, and the user should not have to worry about this.","category":"page"},{"location":"tut/haldane/#tut_haldane-1","page":"The haldane gap","title":"The haldane gap","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"In this tutorial we will calculate the haldane gap (the energy gap in spin 1 heisenberg) in 2 different ways. To follow the tutorial you need the following packages.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"using MPSKit,MPSKitModels,TensorKit,Plots","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"We will enforce the su(2) symmetry, our hamiltonian will therefore be","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"ham = su2_xxx_ham(spin=1);","category":"page"},{"location":"tut/haldane/#Finite-size-extrapolation-1","page":"The haldane gap","title":"Finite size extrapolation","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The first step is always the same, we want to find the groundstate of our system.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"len = 10;\nphysical_space = Rep[SU₂](1=>1);\nvirtual_space = Rep[SU₂](0=>20,1=>20,2=>10,3=>10,4=>5);\n\ninitial_state = FiniteMPS(rand,ComplexF64,len,physical_space,virtual_space);\n(gs,envs,delta) = find_groundstate(initial_state,ham,DMRG());","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The typical way to find excited states is to minmize the energy while adding an error term lambda  gs   gs . Here we will instead use the quasiparticle ansatz.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"In steven white's original DMRG paper it was remarked that the S=1 excitations correspond to edge states, and that one should define the haldane gap as the difference in energy between the S=2 and S=1 states. This can be done as follows.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(En_1,st_1) = excitations(ham,QuasiparticleAnsatz(),gs,envs,sector = SU₂(1))\n(En_2,st_2) = excitations(ham,QuasiparticleAnsatz(),gs,envs,sector = SU₂(2))\nfinite_haldane_gap = En_2[1]-En_1[1]","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"We can go even further and doublecheck the claim that S=1 is an edge excitation, by plotting the energy density.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"pl = plot(xaxis=\"position\",yaxis=\"energy density\")\nplot!(pl,real.(expectation_value(st_1[1],ham)-expectation_value(gs,ham)),label = \"S=1\")\nplot!(pl,real.(expectation_value(st_2[1],ham)-expectation_value(gs,ham)),label = \"S=2\")","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"Extrapolating for different len gives an approximate haldane gap.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#Thermodynamic-limit-1","page":"The haldane gap","title":"Thermodynamic limit","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"A much nicer way of obtaining the haldane gap is by working directly in the thermodynamic limit. We must be careful in selecting the symmetry sectors, the only correct choice is to work with half-integer charges (this is an SPT phase).","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"virtual_space = Rep[SU₂](1//2=>20,3//2=>20,5//2=>10,7//2=>10,9//2=>5); # this is bond dimension 300!\ninitial_state = InfiniteMPS([physical_space],[virtual_space]);\n(gs,envs,delta) = find_groundstate(initial_state,ham,VUMPS());","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"One difference with the finite size case is that we not only can - but also have to - specify a momentum label. We can scan for k = 0 to pi by calling:","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"kspace = 0:0.1:pi\n(Energies,_) = excitations(ham,QuasiparticleAnsatz(),kspace,gs,envs,sector=SU₂(1));","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The minimima sits at k = pi, with corresponding value","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(En,_) = excitations(ham,QuasiparticleAnsatz(),Float64(pi),gs,envs,sector=SU₂(1));\n@assert En[1]  ≈ 0.41047925 atol=1e-4","category":"page"},{"location":"man/states/#um_states-1","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/#FiniteMPS-1","page":"States","title":"FiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A FiniteMPS is - at its core - a chain of mps tensors.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"(Image: )","category":"page"},{"location":"man/states/#Usage-1","page":"States","title":"Usage","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A FiniteMPS can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^1),10);\nFiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Or alternatively by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"len = 10;\nmax_bond_dimension = ℂ^10;\nphysical_space = ℂ^2;\nFiniteMPS(rand,ComplexF64,len,physical_space,max_bond_dimension);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can take dot products, renormalize!, expectation values,....","category":"page"},{"location":"man/states/#Gauging-1","page":"States","title":"Gauging","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"There is residual gauge freedom in such a finite mps :","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"(Image: )","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"which is often exploited in mps algorithms. The gauging logic is handled behind the scenes, if you call","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"then the state will be gauged such that the third tensor is a left isometry (similarly for state.AR).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AC[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"gauges the state in such a way that all tensors to the left are left isometries, and to the right will be right isometries.As a result you should have","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"lastly there is also the CR field, with the following property:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"@tensor a[-1 -2;-3] := state.AL[3][-1 -2;1]*state.CR[3][1;-3]\n@tensor b[-1 -2;-3] := state.CR[2][-1;1]*state.AR[3][1 -2;-3]\na ≈ state.AC[3];\nb ≈ state.AC[3];","category":"page"},{"location":"man/states/#Implementation-details-1","page":"States","title":"Implementation details","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Behind the scenes, a finite mps has 4 fields","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"ALs::Vector{Union{Missing,A}}\nARs::Vector{Union{Missing,A}}\nACs::Vector{Union{Missing,A}}\nCLs::Vector{Union{Missing,B}}","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"calling state.AC returns an \"orthoview\" instance, which is a very simple dummy object. When you call get/setindex on an orthoview, it will move the gauge for the underlying state, and return the result. The idea behind this construction is that one never has to worry about how the state is gauged, as this gets handled automagically.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The following bit of code shows the logic in action:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state = FiniteMPS(10,ℂ^2,ℂ^10); # a random initial state\n@show ismissing.(state.ALs) # all AL fields are already calculated\n@show ismissing.(state.ARs) # all AR fields are missing\n\n#if we now query state.AC[2], it should calculate and store all AR fields left of position 2\nstate.AC[2];\n@show ismissing.(state.ARs)","category":"page"},{"location":"man/states/#InfiniteMPS-1","page":"States","title":"InfiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"An infinite mps can be thought of as a finite mps, where the set of tensors is repeated periodically.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2);\nInfiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The above code would create an infinite mps with an A-B structure (a 2 site unit cell).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"much like a finite mps, we can again query the fields state.AL, state.AR, state.AC and state.CR. The implementation is much easier, as they are now just plain fields in the struct","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"AL::PeriodicArray{A,1}\nAR::PeriodicArray{A,1}\nCR::PeriodicArray{B,1}\nAC::PeriodicArray{A,1}","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The periodic array is an array-like type where all indices are repeated periodically.","category":"page"},{"location":"man/states/#MPSComoving-1","page":"States","title":"MPSComoving","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"MPSComoving is a bit of a mix between an infinite mps and a finite mps. It represents a window of mutable tensors embedded in an infinite mps.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created using:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"mpco = MPSComoving(left_infinite_mps,window_of_tensors,right_infinite_mps)","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Algorithms will then act on this window of tensors, while leaving the left and right infinite mps's invariant.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Behind the scenes it uses the same orthoview logic as finitemps.","category":"page"},{"location":"man/states/#Multiline-1","page":"States","title":"Multiline","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Statistical physics partition functions can be represented by an infinite tensor network which then needs to be contracted. This is done by finding approximate fixpoint infinite matrix product states. However, there is no good reason why a single mps should suffice and indeed we find in practice that this can require a nontrivial unit cell in both dimensions.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In other words, the fixpoints can be well described by a set of matrix product states.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Such a set can be created by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2,2);\nMPSMultiline(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline is also used extensively in as of yet unreleased peps code.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can access properties by calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[row,collumn]\nstate.AC[row,collumn]\nstate.AR[row,collumn]\nstate.CR[row,collumn]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Behind the scenes, we have a type called Multiline, defined as:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"struct Multiline{T}\n    data::PeriodicArray{T,1}\nend","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline/MPOMultiline are then defined as ```julia const MPSMultiline = Multiline{<:InfiniteMPS} const MPOMultiline = Multiline{<:DenseMPO}","category":"page"},{"location":"man/intro/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"The following few sections should help you on your way to setting up and running simulations.","category":"page"},{"location":"man/intro/#TensorKit-1","page":"Basics","title":"TensorKit","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"MPSKit works on \"TensorMap\" objects defined in TensorKit.jl. These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Initializing a TensorMap can be done using","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(initializer,eltype,codomain,domain);\nTensorMap(inputdat,codomain,domain);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Similarly, the following creates a symmetric tensor","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,Rep[U₁](0=>1)*Rep[U₁](1//2=>3),Rep[U₁](1//2=>1,-1//2=>2))","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorKit defines a number of operations on TensorMap objects","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n\n3*a; # multiply by a scalar\n\na+a; #addition of tensormaps\n\na*a; #multiplication of tensormaps\n\na*adjoint(a); #taking the adjoint\n\ndot(a,a); #inner product\n\npermute(a,(1,2),()); # create a new tensormap ℂ^10 * (ℂ^10)' ← nothing\n\n...","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"for more complicated operations, we can use the same @tensor macro defined in TensorOperations.jl","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\nb = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n@tensor c[-1;-2]:=a[-1,1]*b[1,-2];","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"creates a new TensorMap c equal to a*b.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"For more information, check out the TensorKit documentation!","category":"page"},{"location":"man/intro/#Overview-1","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Within MPSKit we defined a set of states, a number of operators and some algorithms which combine the two in a nontrivial way.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As a simple example we can define a FiniteMPS","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"state = FiniteMPS(rand,ComplexF64,10,ℂ^2,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"A hamiltonian operator","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"opp = nonsym_ising_ham();","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"And use this to find the groundstate","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"(groundstate,_) = find_groundstate(state,opp,DMRG());","category":"page"},{"location":"man/intro/#Tips-and-tricks-1","page":"Basics","title":"Tips & tricks","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"There is an examples folder\nJulia inference is taxed a lot; the first time any function is run takes a really long time\nThere are predefined hamiltonians in MPSKitModels.jl","category":"page"},{"location":"tut/isingcft/#The-ising-cft-spectrum-1","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"In this tutorial we will try to plot the finite size cft spectrum for quantum ising, first with exact diagonalization and then going to larger system sizes using mps techniques. The required packages are","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"using MPSKit, MPSKitModels, TensorKit, Plots, KrylovKit\nusing LinearAlgebra:eigen,diagm,Hermitian;","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"The ising hamiltonian has already been implemented:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"nonsym_ising_ham();","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"MPSKit does not support periodic matrix product states, we only deal with the 'usual' open boundary mps's. However we can still impose periodic boundary conditions on the hamiltonian itself, and the mps will then restore translation invariance. To impose periodic boundary conditions you should call:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"circumference = 12;\nham = periodic_boundary_conditions(nonsym_ising_ham(),circumference);","category":"page"},{"location":"tut/isingcft/#exact-diagonalization-1","page":"The ising cft spectrum","title":"exact diagonalization","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"We implemented rudimentary support for exact diagonalization using a trick - by again representing it as a matrix product state but without truncating the bond dimension. The idea is illustrated below.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Optimizing the middle tensor is then equivalent to optimizing a state in the entire hilbert space.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"To call it in julia, do:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(energies,states) = exact_diagonalization(ham,num=18,alg=Lanczos(krylovdim=200));\nplot(real.(energies),seriestype=:scatter,legend=false,yaxis=\"energy\",xaxis=\"#eigenvalue\")","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Note the large krylov dimension - degenerate eigenvalues are notoriously difficult for iterative methods.","category":"page"},{"location":"tut/isingcft/#extracting-momentum-1","page":"The ising cft spectrum","title":"extracting momentum","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Given a state, we would like to assign a momentum label. A natural way to do this is by creating the translation operator, as an mpo:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"id = complex(isomorphism(ℂ^2,ℂ^2));\n@tensor O[-1 -2;-3 -4] := id[-1,-3]*id[-2,-4]\nmpo = DenseMPO(O);","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"We don't quite want an infinite mpo - which simply repeats this mpo ad infinitum, but would rather want to impose periodic boundary conditions to this mpo:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"mpo = periodic_boundary_conditions(mpo,circumference);","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"You can now simply calculate the momentum of the groundstate as:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"angle(dot(states[1],mpo*states[1]))","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"However, there is a subtlety because of the degenerate energy eigenvalues. The eigensolver will find an orthonormal basis within every energy subspace, so states within an energy subspace will not necessarily be momentum eigenstates. To assign a momentum label, we would have to diagonalize the translation operator.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"function fix_degeneracies(basis)\n    N = fill(0.0+0im,length(basis),length(basis));\n    T = fill(0.0+0im,length(basis),length(basis));\n    for i in 1:length(basis), j in 1:length(basis)\n        T[i,j] = dot(basis[i],mpo*basis[j]);\n        N[i,j] = dot(basis[i],basis[j]);\n    end\n\n\n    (vals,vecs) = eigen(Hermitian(N));\n    T = vecs'*T*vecs\n    T/=diagm(vals);\n\n    (vals,vecs) = eigen(T);\n    angle.(vals);\n\nend\n\nmomenta = Float64[];\n\n\nappend!(momenta,fix_degeneracies(states[1:1]));\nappend!(momenta,fix_degeneracies(states[2:2]));\nappend!(momenta,fix_degeneracies(states[3:3]));\nappend!(momenta,fix_degeneracies(states[4:5]));\nappend!(momenta,fix_degeneracies(states[6:9]));\nappend!(momenta,fix_degeneracies(states[10:11]));\nappend!(momenta,fix_degeneracies(states[12:12]));\nappend!(momenta,fix_degeneracies(states[13:16]));\nappend!(momenta,fix_degeneracies(states[17:18]));\n\nplot(momenta,real.(energies[1:18]),seriestype=:scatter,xaxis=\"momentum\",yaxis=\"energy\",legend=false)","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#finite-bond-dimension-1","page":"The ising cft spectrum","title":"finite bond dimension","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Not much changes at finite bond dimension, except we can now reach higher system sizes.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"circumference = 20;\nham = periodic_boundary_conditions(nonsym_ising_ham(),circumference);\n\nstate = FiniteMPS(circumference,ℂ^2,ℂ^50 #=bond dimension=#);\n\n(gs,envs) = find_groundstate(state,ham,DMRG());","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Excitations on top of the groundstate can be found using the quasiparticle ansatz. This returns quasiparticle states, which you can just convert back to the usual finite mps's.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(ens,qps) = excitations(ham,QuasiparticleAnsatz(),gs,envs,num=16);\nqpstates = map(qp->convert(FiniteMPS,qp),qps);","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"And we get the spectrum:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"states = [gs;qpstates];\nenergies = map(x->sum(expectation_value(x,ham)),states);\n\nmpo = periodic_boundary_conditions(DenseMPO(O),circumference);\n\nmomenta = Float64[];\n\nappend!(momenta,fix_degeneracies(states[1:1]));\nappend!(momenta,fix_degeneracies(states[2:2]));\nappend!(momenta,fix_degeneracies(states[3:3]));\nappend!(momenta,fix_degeneracies(states[4:5]));\nappend!(momenta,fix_degeneracies(states[6:9]));\nappend!(momenta,fix_degeneracies(states[10:11]));\nappend!(momenta,fix_degeneracies(states[12:12]));\nappend!(momenta,fix_degeneracies(states[13:16]));\n\nplot(momenta,real.(energies[1:16]),seriestype=:scatter,xaxis=\"momentum\",yaxis=\"energy\",legend=false)","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/anyonic_statmech/#tut_hardhex-1","page":"The hard hexagon model","title":"The hard hexagon model","text":"","category":"section"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"Tensor networks are a natural way to do statistical mechanics on a lattice. As an example of this we will extract the central charge of the hard hexagon model. This model is known to have central charge 0.8, and has very peculiar non-local (anyonic) symmetries. Because TensorKit supports anyonic symmetries, so does MPSKit. To follow the tutorial you need the following packages.","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"using MPSKit,TensorKit,Polynomials","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"The hard hexagon mpo is given by","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"physical = Vect[FibonacciAnyon](:τ => 1);\nt = TensorMap(ones,ComplexF64,physical*physical,physical*physical);\nblocks(t)[FibonacciAnyon(:I)] *= 0;\n\nmpo = DenseMPO(t);","category":"page"},{"location":"tut/anyonic_statmech/#The-leading-boundary-1","page":"The hard hexagon model","title":"The leading boundary","text":"","category":"section"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"One way to do statmech in infinite systems with tensor networks is by approximating the dominant eigenvector of the transfer matrix by an mps. In MPSKit one should first define an initial guess for this eigenvector:","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"virtual = Vect[FibonacciAnyon](:τ => 5, :I => 5);\ninit = InfiniteMPS([physical],[virtual]);","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"and then pass it on to \"leading_boundary\":","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"(dominant,_) = leading_boundary(init,mpo,VUMPS());","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"This dominant eigenvector contains a lot of hidden information, for example the following calculates the free energy:","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"expectation_value(dominant,mpo)","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"In this tutorial we will be focussing on the entanglement entropy and the correlation length:","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"S = entropy(dominant);\ncor_len = correlation_length(dominant);","category":"page"},{"location":"tut/anyonic_statmech/#The-scaling-hypothesis-1","page":"The hard hexagon model","title":"The scaling hypothesis","text":"","category":"section"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"The dominant eigenvector is of course only an approximation. The finite bond dimension enforces a finite correlation length, which effectively introduces a length scale in the system. This can be exploited to formulate a scaling hypothesis, which in turn allows you to extract the central charge!","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"First we need to know the entropy and correlation length at a bunch of different bond dimensions. Our approach will be to re-use the previous approximated dominant eigenvector, by simply expanding its bond dimension and re-running vumps.","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"entropies = [real(S[1])];\ncorlens = [cor_len];\nenvs = environments(dominant,mpo);\n\n#this will take a fairly long time\nfor Ds in 5:5:50\n    (dominant,envs) = changebonds(dominant,mpo,OptimalExpand(trscheme = truncdim(5)),envs);\n    (dominant,envs) = leading_boundary(dominant,mpo,VUMPS(maxiter=200));\n    push!(entropies,real(entropy(dominant)[1]));\n    push!(corlens,correlation_length(dominant));\nend","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"According to the scaling hypothesis we should have S propto fracc6 log(corlen). Therefore we should find c using","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"f = fit(log.(corlens),6*entropies,1);\nf.coeffs[2]","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"Which indeed nicely agrees with the known result of 0.8.","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"(Image: )","category":"page"},{"location":"man/algorithms/#um_algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms/#Minimizing-the-energy-1","page":"Algorithms","title":"Minimizing the energy","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"There are a number of different possible energy-minimization algorithms, depending on the system size. Exclusive to finite systems are","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"- DMRG\n\n- DMRG2","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Exclusive to infinite systems are","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"- IDMRG\n\n- IDMRG2\n\n- VUMPS","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"with a last algorithm - GradientGrassmann - implemented for both finite and infinite systems.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"MPSComoving, which is a finite patch of mutable tensors embedded in an infinite MPS, is handled as a finite system where we only optimize over the patch of mutable tensors.","category":"page"},{"location":"man/algorithms/#DMRG-1","page":"Algorithms","title":"DMRG","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate!(state,operator,DMRG())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The DMRG algorithm sweeps through the system, optimizing every site. Because of its single-site behaviour, this will always keep the bond dimension fixed. If you do want to increase the bond dimension dynamically, then there are two options. Either you use the two-site variant of DMRG (DMRG2()), or you make use of the finalize option. Finalize is a function that gets called at the end of every DMRG iteration. Within that function call one can modify the state.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"function my_finalize(iter,state,ham,envs)\n    println(\"Hello from iteration $iter\")\n    return state,envs;\nend\n\n(groundstate,environments,delta) = find_groundstate!(state,operator,DMRG(finalize = my_finalize))","category":"page"},{"location":"man/algorithms/#DMRG2-1","page":"Algorithms","title":"DMRG2","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate!(state,operator,DMRG2(trscheme=truncbelow(1e-7)));","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The twosite variant of DMRG, which optimizes blocks of two sites and then decomposes them into 2 MPS tensors using the svd decomposition. By truncating the singular values up to a desired precision, one can dynamically grow and shrink the bond dimension as needed. However, this truncation in turn introduces an error, which is why a state converged with DMRG2 can often be slightly further converged by subsequently using DMRG.","category":"page"},{"location":"man/algorithms/#IDMRG-1","page":"Algorithms","title":"IDMRG","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,IDMRG1())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The DMRG algorithm for finite systems can be generalized to infinite MPS. The idea is to start with a finite system and grow the system size, while we are sweeping through the system. This is again a single site algorithm, and therefore preserves the initial bond dimension.","category":"page"},{"location":"man/algorithms/#IDMRG2-1","page":"Algorithms","title":"IDMRG2","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2,ℂ^2],[ℂ^10,ℂ^10]);\noperator = repeat(nonsym_ising_ham(),2);\n(groundstate,environments,delta) = find_groundstate(state,operator,IDMRG2(trscheme=truncbelow(1e-5)))","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The generalization of DMRG2 to infinite systems has the same caveats as its finite counterpart. We furthermore require a unitcell ≥ 2. As a rule of thumb, a truncation cutoff of 1e-5 is already really good.","category":"page"},{"location":"man/algorithms/#VUMPS-1","page":"Algorithms","title":"VUMPS","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"VUMPS is an (I)DMRG inspired algorithm that can be used to find the groundstate of infinite matrix product states","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,VUMPS())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"much like DMRG, it cannot modify the bond dimension, and this has to be done manually in the finalize function.","category":"page"},{"location":"man/algorithms/#Gradient-descent-1","page":"Algorithms","title":"Gradient descent","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Both finite and infinite matrix product states can be parametrized by a set of unitary matrices, and we can then perform gradient descent on this unitary manifold. Due to some technical reasons (gauge freedom), this manifold further restricts to a grassmann manifold.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,GradientGrassmann())","category":"page"},{"location":"man/algorithms/#Time-evolution-1","page":"Algorithms","title":"Time evolution","text":"","category":"section"},{"location":"man/algorithms/#TDVP-1","page":"Algorithms","title":"TDVP","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"There is an implementation of the one-site TDVP scheme for finite and infinite MPS:","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"(newstate,environments) = timestep(state,operator,dt,TDVP())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"and the two-site scheme for finite MPS (TDVP2()). Similarly to DMRG, the one site scheme will preserve the bond dimension, and expansion has to be done manually.","category":"page"},{"location":"man/algorithms/#Time-evolution-MPO-1","page":"Algorithms","title":"Time evolution MPO","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"We have rudimentary support for turning an MPO hamiltonian into a time evolution MPO.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"make_time_mpo(ham,dt,alg::WI)\nmake_time_mpo(ham,dt,alg::WII)","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"two algorithms are available, corresponding to different orders of precision. It is possible to then multiply a state by this MPO, or to approximate (MPO,state) by a new state","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\nmpo = make_time_mpo(operator,0.1,WII());\napproximate(state,(state,mpo),VUMPS())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"This feature is at the moment not very well supported.","category":"page"},{"location":"man/algorithms/#Excitations-1","page":"Algorithms","title":"Excitations","text":"","category":"section"},{"location":"man/algorithms/#Quasiparticle-ansatz-1","page":"Algorithms","title":"Quasiparticle ansatz","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"We export code that implements the quasiparticle excitation ansatz for finite and infinite systems. For example, the following calculates the haldane gap for spin-1 heisenberg.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_xxz_ham()\nts = InfiniteMPS([ℂ^3],[ℂ^48]);\n(ts,envs,_) = find_groundstate(ts,th,VUMPS(maxiter=400,verbose=false));\n(energies,Bs) = excitations(th,QuasiparticleAnsatz(),Float64(pi),ts,envs);\n@test energies[1] ≈ 0.41047925 atol=1e-4","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For infinite systems you have to specify the momentum of your particle. In contrast, momentum is not a well defined quantum number and you therefore do not have to specify it when finding excitations on top of a finite MPS.","category":"page"},{"location":"man/algorithms/#Finite-excitations-1","page":"Algorithms","title":"Finite excitations","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For finite systems we can also do something else - find the groundstate of the hamiltonian + weight sum_i  psi_i   psi_i. This is also supported by calling","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_ham()\nts = FiniteMPS(10,ℂ^2,ℂ^12);\n(ts,envs,_) = find_groundstate(ts,th,DMRG(verbose=false));\n(energies,Bs) = excitations(th,FiniteExcited(),ts,envs);","category":"page"},{"location":"man/algorithms/#changebonds-1","page":"Algorithms","title":"changebonds","text":"","category":"section"},{"location":"man/algorithms/#optimal-expand-1","page":"Algorithms","title":"optimal expand","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"One possible way to expand the bond dimension is described in the original VUMPS paper. The idea is to look at the 2site derivative and add the most important blocks orthogonal to the current MPS. From the point of view of a local 2site update, this procedure is 'optimal'.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The state will remain physically unchanged, but a one-site scheme will now be able to push the optimization further.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_ham()\nts = FiniteMPS(10,ℂ^2,ℂ^12);\nchangebonds(ts,OptimalExpand(trscheme = truncdim(1))) # expand the bond dimension by 1","category":"page"},{"location":"man/algorithms/#random-expand-1","page":"Algorithms","title":"random expand","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"This algorithm is almost identical to optimal expand, except we don't try to do anything 'clever'. The unitary blocks that get added are chosen at random.","category":"page"},{"location":"man/algorithms/#svd-cut-1","page":"Algorithms","title":"svd cut","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"It is possible to truncate a state using the svd decomposition, this is implemented in svdcut.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_ham()\nts = FiniteMPS(10,ℂ^2,ℂ^12);\nchangebonds(ts,SvdCut(trscheme = truncdim(10))) # truncate the state to one with bond dimension 10","category":"page"},{"location":"man/algorithms/#VUMPS-svd-cut-1","page":"Algorithms","title":"VUMPS svd cut","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"A particularly simple scheme useful when doing VUMPS is to do a 2site update, and then truncating this back down. It changes the state itself, so cannot be used to do time evolution, but that is no problem for energy minimization.","category":"page"},{"location":"man/algorithms/#leading-boundary-1","page":"Algorithms","title":"leading boundary","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For statmech partition functions we want to find the approximate leading boundary MPS.  Again this can be done with VUMPS:","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_mpo()\nts = InfiniteMPS([ℂ^2],[ℂ^20]);\n(ts,envs,_) = leading_boundary(ts,th,VUMPS(maxiter=400,verbose=false));","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"if the mpo satisfies certain properties (positive and hermitian), it may also be possible to use GradientGrassmann.","category":"page"},{"location":"man/algorithms/#approximate-1","page":"Algorithms","title":"approximate","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Sometimes we want to approximate the product of an MPO and a state by another state (for example during time evolution). The call signature is","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"    approximate(initial_guess,(state,mpo),alg)","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"for finite systems alg can be Dmrg,Dmrg2 while for infinite systems we have Idmrg1,Idmrg2 and VUMPS. It's important to mention that the actual implementation differs a bit from the usual  Dmrg,Dmrg2,... for energy minimization but is rather inspired by it. For example, calling approximate with VUMPS actually uses an algorithm that has been described as VOMPS.","category":"page"},{"location":"man/algorithms/#Varia-1","page":"Algorithms","title":"Varia","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"What follows is a medley of lesser known (or used) algorithms and don't entirely fit under one of the above categories.","category":"page"},{"location":"man/algorithms/#Dynamical-DMRG-1","page":"Algorithms","title":"Dynamical DMRG","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Dynamical DMRG has been described in other papers and is a way to find the propagator. The basic idea is that to calculate G(z) =  V  (H-z)^-1  V  , one can variationally find (H-z) W  =  V  and then the propagator simply equals G(z) =  V  W .","category":"page"},{"location":"man/algorithms/#fidelity-susceptibility-1","page":"Algorithms","title":"fidelity susceptibility","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The fidelity susceptibility measures how much the groundstate changes when tuning a parameter in your hamiltonian. Divergences occur at phase transitions, making it a valuable measure when no order parameter is known.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"fidelity_susceptibility(groundstate,H_0,perturbing_Hams::AbstractVector)","category":"page"},{"location":"man/algorithms/#periodic-boundary-conditions-1","page":"Algorithms","title":"periodic boundary conditions","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"You can impose periodic boundary conditions on the hamiltonian itself, while still using a normal OBC finite matrix product states. This is straightforward to implement but competitive with more advanced PBC MPS algorithms.","category":"page"},{"location":"man/algorithms/#exact-diagonalization-1","page":"Algorithms","title":"exact diagonalization","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"As a side effect, our code support exact diagonalization. The idea is to construct a finite matrix product state with maximal bond dimension, and then optimize the middle site. Because we never truncated the bond dimension, this single site effectively parametrizes the entire hilbert space.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"exact_diagonalization(periodic_boundary_conditions(su2_xxx_ham(spin=1),10),which=:SR) # find the groundstate on 10 sites","category":"page"},{"location":"tut/xxz_groundstate/#Analyzing-the-xxz-model-1","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"In this file we will give step by step instructions on how to analyze the spin 1/2 xxz model. The necessary packages to follow this tutorial are :","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"using MPSKit, MPSKitModels, TensorKit, Plots","category":"page"},{"location":"tut/xxz_groundstate/#Failure-1","page":"Analyzing the xxz model","title":"Failure","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"First we should define the hamiltonian we want to work with. The following code does so in the mpo representation of the hamiltonian.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\nham_data = fill(zero(id),1,5,5);\nham_data[1,1,1] = id; ham_data[1,end,end] = id;\nham_data[1,1,2] = sx; ham_data[1,2,end] = sx;\nham_data[1,1,3] = sy; ham_data[1,3,end] = sy;\nham_data[1,1,4] = sz; ham_data[1,4,end] = sz;\nham = MPOHamiltonian(ham_data);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We then need an intial state, which we shall later optimize. In this example we work directly in the thermodynamic limit.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"random_data = TensorMap(rand,ComplexF64,ℂ^20*ℂ^2,ℂ^20);\nstate = InfiniteMPS([random_data]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"The groundstate can then be found by calling find_groundstate.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,VUMPS());","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"As you can see, vumps strugles to converge. On it's own, that is already quite curious. Maybe we can do better using another algorithm, such as gradient descent.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,GradientGrassmann(maxiter=20));","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Convergence is quite slow and even fails after sufficiently many iterations. To understand why, we can look at the transfer matrix spectrum.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"    transferplot(groundstate,groundstate)","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(Image: )","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We can clearly see multiple eigenvalues close to the unit circle. Our state is close to being non-injective, and represents the sum of multiple injective states. This is numerically very problematic, but also indicates that we used an incorrect ansatz to approximate the groundstate. We should retry with a larger unit cell.","category":"page"},{"location":"tut/xxz_groundstate/#Success-1","page":"Analyzing the xxz model","title":"Success","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Let's initialize a different initial state, this time with a 2-site unit cell:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"A = TensorMap(rand,ComplexF64,ℂ^20*ℂ^2,ℂ^20);\nB = TensorMap(rand,ComplexF64,ℂ^20*ℂ^2,ℂ^20);\nstate = InfiniteMPS([A,B]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"In MPSKit, we require that the periodicity of the hamiltonian equals that of the state it is applied to. This is not a big obstacle, you can simply repeat the original hamiltonian:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"ham = repeat(ham,2);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Running vumps","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,VUMPS(maxiter=100,tol_galerkin=1e-12));","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"we get convergence, but it takes an enormous amount of iterations. The reason behind this becomes more obvious at higher bond dimensions","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,IDMRG2(trscheme=truncdim(100),maxiter=100,tol_galerkin=1e-12));\n\nentanglementplot(groundstate)","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(Image: )","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We see that some eigenvalues clearly belong to a group, and are almost degenerate. This implies 2 things:     - there is superfluous information, if those eigenvalues are the same anyway     - poor convergence if we cut off within such a subspace","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"It are precisely those problems that we can solve by using symmetries.","category":"page"},{"location":"tut/xxz_groundstate/#Symmetries-1","page":"Analyzing the xxz model","title":"Symmetries","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"The xxz hamiltonian is su(2) symmetric and we can exploit this to greatly speed up the simulation.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"It is cumbersome to construct symmetric hamiltonians, but luckily su(2) symmetric xxz is already implemented:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"ham = repeat(su2_xxx_ham(spin=1//2),2);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Our initial state should also be su(2) symmetric. It now becomes apparent why we have to use a 2 site periodic state. The physical space carries a half-integer charge and the first tensor maps the first virtual space ⊗ the physical space to the second virtual space. Half integer virtual charges will therefore map only to integer charges, and vice versa. The staggering happens on the virtual level!","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"An alternative constructor for the initial state is","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"D1 = Rep[SU₂](1//2 => 10,3//2=>5,5//2=>2);\nD2 = Rep[SU₂](0=>15,1=>10,2=>5);\nstate = InfiniteMPS([Rep[SU₂](1//2 => 1),Rep[SU₂](1//2 => 1)],[D1,D2])","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Even though the bond dimension is higher then in the non symmetric example:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"@assert dim(D1) == 52;\n@assert dim(D2) == 70;","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Vumps converges much much faster","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,VUMPS(maxiter=400,tol_galerkin=1e-12));","category":"page"},{"location":"man/operators/#um_operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/#DenseMPO-1","page":"Operators","title":"DenseMPO","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"This operator is used for statistical physics problems. It is simply a periodic array of mpo tensors.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Can be created using","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"DenseMPO(t::AbstractArray{T,1}) where T<:MPOTensor","category":"page"},{"location":"man/operators/#SparseMPO-1","page":"Operators","title":"SparseMPO","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"SparseMPO is similar to a DenseMPO, in that it again represents an mpo tensor, periodically repeated. However this type keeps track of all internal zero blocks, allowing for a more efficient representation of certain operators (such as time evolution operators and quantum hamiltonians). You can convert a sparse mpo to a densempo, but the converse does not hold.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Indexing a SparseMPO returns a SparseMPOSlice object, which has 3 field","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"\nOs <: AbstractMatrix{Union{T,E}}\ndomspaces <: AbstractVector{S}\nimspaces <: AbstractVector{S}\npspace :: S\n\nWhere T<:MPOTensor, E<:Number, S<: VectorSpace","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"When indexing a SparseMPOSlice at index j,k, the code looks up the corresponding field in Os[j,k]. Either that element is a tensormap, in which case it gets returned. If it equals zero(E), then we return a tensormap","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"domspaces[j]*pspace ← pspace*imspaces[k]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"with norm zero. If the element is a nonzero number, then implicitly we have the identity operator there (multiplied by that element).","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"The idea here is that you don't have to worry about the underlying structure, you can just index into a sparsempo as if it is a vector of matrices. Behind the scenes we then optimize certain contractions by using the sparsity structure.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"SparseMPO are always assumed to be periodic in the first index (position). In this way, we can both represent periodic infinite mpos and place dependent finite mpos.","category":"page"},{"location":"man/operators/#MPOHamiltonian-1","page":"Operators","title":"MPOHamiltonian","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"We represent all quantum hamiltonians in their mpo form. As an example, the following bit of code constructs the ising hamiltonian.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\ndata = Array{Any,3}(missing,1,3,3);\ndata[1,1,1] = id;\ndata[1,1,2] = -sz;\ndata[1,2,3] = sz;\ndata[1,1,3] = 3*sx;\nham = MPOHamiltonian(data);","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"When we work with symmetries, it is often not possible to represent the entire hamiltonian as a sum of a product of one-body operators. In xxz for examples, only the sum (sx sx + sy sy + sz sz) is su(2) symmetric, but individually none of the terms are. It is for this reason that we use 4 leg mpo tensors in this hamiltonian object. The following bit of code","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"ham[1][1,1]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Will print out a tensormap mapping (virtual space x physical space) to (physical space x virtual space). The conversion to mpo tensors was done automagically behind the scenes!","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"An MPOHamiltonian is really just a SparseMPO, but with the garantuee that the sub-blocks are upper triangular. This effectively means that they are finite state machines, which are general enough to encode any hamiltonian but are efficient to construct environments for.","category":"page"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#User-manual-1","page":"Home","title":"User manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\",\"man/conventions.md\",\"man/states.md\",\"man/operators.md\",\"man/algorithms.md\",\"man/parallelism.md\"]\nDepth = 1","category":"page"},{"location":"#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"tut/anyonic_statmech.md\",\"tut/isingcft.md\",\"tut/xxz_groundstate.md\",\"tut/timeev.md\",\"tut/haldane.md\"]\nDepth = 1","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/lib.md\"]\nDepth = 1","category":"page"}]
}
