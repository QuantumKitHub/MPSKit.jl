var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library-documentation-1","page":"Library documentation","title":"Library documentation","text":"","category":"section"},{"location":"lib/lib/#lib_states-1","page":"Library documentation","title":"States","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"FiniteMPS\nInfiniteMPS\nMPSComoving\nMPSMultiline","category":"page"},{"location":"lib/lib/#MPSKit.FiniteMPS","page":"Library documentation","title":"MPSKit.FiniteMPS","text":"mutable struct FiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor} <: AbstractMPS\n\nRepresents a finite matrix product state\n\nWhen queried for AL/AR/AC/CL it will check if it is missing.     If not, return     If it is, calculate it, store it and return\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.InfiniteMPS","page":"Library documentation","title":"MPSKit.InfiniteMPS","text":"struct InfiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor}\n\nRepresents an infinite matrix product state The state is stored in the centergauge where     state.AL[i]state.CR[i] = state.AC[i] = state.CR[i-1]state.AR[i]\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSComoving","page":"Library documentation","title":"MPSKit.MPSComoving","text":"MPSComoving(leftstate,window,rightstate)\n\nmuteable window of tensors on top of an infinite chain\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSMultiline","page":"Library documentation","title":"MPSKit.MPSMultiline","text":"2d extension of InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Operators-1","page":"Library documentation","title":"Operators","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPOHamiltonian\nComAct\nPeriodicMPO","category":"page"},{"location":"lib/lib/#MPSKit.MPOHamiltonian","page":"Library documentation","title":"MPSKit.MPOHamiltonian","text":"MPOHamiltonian\n\nrepresents a general periodic quantum hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.ComAct","page":"Library documentation","title":"MPSKit.ComAct","text":"ComAct(ham1,ham2)\n\nActs on an mpo with mpo hamiltonian 'ham1' from below + 'ham2' from above.\nCan therefore represent the (anti) commutator.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PeriodicMPO","page":"Library documentation","title":"MPSKit.PeriodicMPO","text":"Represents a periodic (in 2 directions) statmech mpo\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Environments-1","page":"Library documentation","title":"Environments","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPSKit.AbstractInfEnv\nMPSKit.PerMPOInfEnv\nMPSKit.MPOHamInfEnv\nMPSKit.FinEnv\nMPSKit.SimpleEnv\nMPSKit.OvlEnv","category":"page"},{"location":"lib/lib/#MPSKit.AbstractInfEnv","page":"Library documentation","title":"MPSKit.AbstractInfEnv","text":"Abstract environment for an infinite state\ndistinct from finite, because we have to recalculate everything when the state changes\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PerMPOInfEnv","page":"Library documentation","title":"MPSKit.PerMPOInfEnv","text":"This object manages the periodic mpo environments for an MPSMultiline\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPOHamInfEnv","page":"Library documentation","title":"MPSKit.MPOHamInfEnv","text":"This object manages the hamiltonian environments for an InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.FinEnv","page":"Library documentation","title":"MPSKit.FinEnv","text":"FinEnv keeps track of the environments for FiniteMPS / MPSComoving\nIt automatically checks if the queried environment is still correctly cached and if not - recalculates\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SimpleEnv","page":"Library documentation","title":"MPSKit.SimpleEnv","text":"SimpleEnv does nothing fancy to ensure the correctness of the environments it returns.\nSupports setleftenv! and setrightenv!\nOnly used internally (in idmrg); no public constructor is provided\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Generic-actions-1","page":"Library documentation","title":"Generic actions","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"c_prime\nac_prime\nac2_prime\nexpectation_value","category":"page"},{"location":"lib/lib/#MPSKit.c_prime","page":"Library documentation","title":"MPSKit.c_prime","text":"Zero-site derivative (the C matrix to the right of pos)\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac_prime","page":"Library documentation","title":"MPSKit.ac_prime","text":"One-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac2_prime","page":"Library documentation","title":"MPSKit.ac2_prime","text":"Two-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.expectation_value","page":"Library documentation","title":"MPSKit.expectation_value","text":"calculates the expectation value for the given operator/hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#Algorithms-1","page":"Library documentation","title":"Algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"find_groundstate\ntimestep\nleading_boundary\ndynamicaldmrg\nquasiparticle_excitation\nchangebonds","category":"page"},{"location":"lib/lib/#MPSKit.find_groundstate","page":"Library documentation","title":"MPSKit.find_groundstate","text":"find_groundstate(state,ham,alg,pars=params(state,ham))\n\nfind the groundstate for ham using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.timestep","page":"Library documentation","title":"MPSKit.timestep","text":"function timestep(psi, operator, dt, alg,pars = params(psi,operator))\n\ntime evolves psi by timestep dt using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.leading_boundary","page":"Library documentation","title":"MPSKit.leading_boundary","text":"leading_boundary(state,opp,alg,pars=params(state,ham))\n\napproximate the leading eigenvector for opp\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.dynamicaldmrg","page":"Library documentation","title":"MPSKit.dynamicaldmrg","text":"https://arxiv.org/pdf/cond-mat/0203500.pdf\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.quasiparticle_excitation","page":"Library documentation","title":"MPSKit.quasiparticle_excitation","text":"quasiparticle_excitation calculates the energy of the first excited state at momentum 'moment'\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#lib_gs_alg-1","page":"Library documentation","title":"Groundstate algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Vumps\nIdmrg1\nDmrg\nDmrg2\nGradientGrassmann","category":"page"},{"location":"lib/lib/#MPSKit.Vumps","page":"Library documentation","title":"MPSKit.Vumps","text":"see https://arxiv.org/abs/1701.07035\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Idmrg1","page":"Library documentation","title":"MPSKit.Idmrg1","text":"onesite infinite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg","page":"Library documentation","title":"MPSKit.Dmrg","text":"onesite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg2","page":"Library documentation","title":"MPSKit.Dmrg2","text":"twosite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.GradientGrassmann","page":"Library documentation","title":"MPSKit.GradientGrassmann","text":"GradientGrassmann is an optimisation methdod that keeps the MPS in left-canonical form, and treats the tensors as points on Grassmann manifolds. It then applies one of the standard gradient optimisation methods, e.g. conjugate gradient, to the MPS, making use of the Riemannian manifold structure. A preconditioner is used, so that effectively the metric used on the manifold is that given by the Hilbert space inner product.\n\nThe arguments to the constructor are method = OptimKit.ConjugateGradient     The gradient optimisation method to be used. Should either be an instance or a subtype     of OptimKit.OptimizationAlgorithm. If it's an instance, this method is simply used     to do the optimisation. If it's a subtype, then an instance is constructed as     method(; maxiter=maxiter, verbosity=verbosity, gradtol=tol)\n\nfinalize! = OptimKit._finalize!     A function that gets called once each iteration. See OptimKit for details.\n\ntol = Defaults.tol maxiter = Defaults.maxiter verbosity = 2     Arguments passed to the method constructor. If method is an instance of     OptimKit.OptimizationAlgorithm, these argument are ignored.\n\nIn other words, by default conjugate gradient is used. One can easily set tol, maxiter and verbosity for it, or switch to LBFGS or gradient descent by setting method. If more control is wanted over things like specifics of the linesearch, CG flavor or the m parameter of LBFGS, then the user should create the OptimKit.OptimizationAlgorithm instance manually and pass it as method.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_time_alg-1","page":"Library documentation","title":"Time evolution algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Tdvp\nTdvp2","category":"page"},{"location":"lib/lib/#MPSKit.Tdvp","page":"Library documentation","title":"MPSKit.Tdvp","text":"onesite tdvp\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Tdvp2","page":"Library documentation","title":"MPSKit.Tdvp2","text":"twosite tdvp (works for finite mps's)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_bound_alg-1","page":"Library documentation","title":"Leading boundary algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Vumps\nPowerMethod","category":"page"},{"location":"lib/lib/#MPSKit.PowerMethod","page":"Library documentation","title":"MPSKit.PowerMethod","text":"PowerMethod way of finding the leading boundary mps\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_bc_alg-1","page":"Library documentation","title":"Bond change algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"OptimalExpand\nVumpsSvdCut\nSvdCut","category":"page"},{"location":"lib/lib/#MPSKit.OptimalExpand","page":"Library documentation","title":"MPSKit.OptimalExpand","text":"expands the given mps using the algorithm given in the vumps paper\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.VumpsSvdCut","page":"Library documentation","title":"MPSKit.VumpsSvdCut","text":"use an idmrg2 step to truncate/expand the bond dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SvdCut","page":"Library documentation","title":"MPSKit.SvdCut","text":"Truncate a given state using svd\n\n\n\n\n\n","category":"type"},{"location":"man/states/#um_states-1","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/#FiniteMPS-1","page":"States","title":"FiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A FiniteMPS can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^1),10);\nFiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Or alternatively by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"len = 10;\nmax_bond_dimension = ℂ^10;\nphysical_space = ℂ^2;\nFiniteMPS(rand,ComplexF64,len,physical_space,max_bond_dimension);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can take dot products, renormalize!, expectation values,....","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In our algorithms we typically make use of the fields .AC/.AR/.AL. Calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AC[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"gauges the state such that every tensor left of 3 is a left unitary matrix and to the right we have right unitary matrices. As a result you should have","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Note that every tensor should be a map from the virtual space to the virtual space ⊗ physical space. In other words, we need the input tensormaps to be of the type AbstractTensorMap{S,N,1}.","category":"page"},{"location":"man/states/#InfiniteMPS-1","page":"States","title":"InfiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"An infinite mps can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2);\nInfiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The above code would create an infinite mps with an A-B structure (a 2 site unit cell).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Very analogous to the finite mps case we have:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#MPSComoving-1","page":"States","title":"MPSComoving","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"MPSComoving is a bit of a mix between an infinite mps and a finite mps. It represents a window of mutable tensors embedded in an infinite mps.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created using:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"mpco = MPSComoving(left_infinite_mps,window_of_tensors,right_infinite_mps)","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Algorithms will then act on this window of tensors, while leaving the left and right infinite mps's invariant.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"This state can be used to study impurities or local quenches.","category":"page"},{"location":"man/states/#MPSMultiline-1","page":"States","title":"MPSMultiline","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Statistical physics partition functions can be represented by an infinite tensor network which then needs to be contracted. This is done by finding approximate fixpoint infinite matrix product states. However, there is no good reason why a single mps should suffice and indeed we find in practice that this can also be periodic.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In other words, the fixpoints can be well described by a set of matrix product states.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Such a set can be created by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2,2);\nMPSMultiline(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline is also used extensively in as of yet unreleased peps code.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can access properties by calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[row,collumn]","category":"page"},{"location":"man/intro/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"The following few sections should help you on your way to setting up and running simulations.","category":"page"},{"location":"man/intro/#TensorKit-1","page":"Basics","title":"TensorKit","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"MPSKit works on \"TensorMap\" objects defined in TensorKit.jl. These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Initializing a TensorMap can be done using","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(initializer,eltype,codomain,domain);\nTensorMap(inputdat,codomain,domain);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\ndat = rand(ComplexF64,10,10); TensorMap(dat,ℂ^10,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Similarly, the following creates a symmetric tensor","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ[U₁](0=>1)*ℂ[U₁](1//2=>3),ℂ[U₁](1//2=>1,-1//2=>2))","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorKit defines a number of operations on TensorMap objects","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n3*a; a+a; a*a; a*adjoint(a); a-a; dot(a,a); norm(a);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"but the primary workhorse is the @tensor macro","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\nb = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n@tensor c[-1;-2]:=a[-1,1]*b[1,-2];","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"creates a new TensorMap c equal to a*b.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"For more information, check out the tensorkit documentation!","category":"page"},{"location":"man/intro/#Overview-1","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Within MPSKit we defined a set of states, a number of operators and some algorithms which combine the two in a nontrivial way.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As a simple example we can define a FiniteMPS","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"state = FiniteMPS(rand,ComplexF64,10,ℂ^2,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"A hamiltonian operator","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"opp = nonsym_ising_ham();","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"And use this to find the groundstate","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"(groundstate,_) = find_groundstate(state,opp,DMRG());","category":"page"},{"location":"man/intro/#Tips-and-tricks-1","page":"Basics","title":"Tips & tricks","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"There is an examples folder\nJulia inference is taxed a lot; so use (jupyter notebooks / Revise ) instead of re-running a script everytime","category":"page"},{"location":"tut/timeev/#DQPT-in-ising-1","page":"DQPT in ising","title":"DQPT in ising","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"In this tutorial we will try to reproduce the results from this paper. The needed packages are","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"using MPSKit,TensorKit,ProgressMeter","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Dynamical quantum phase transitions (DQPT in short) are signatures of equilibrium phase transitions in a dynamical quantity - the loschmidth echo. This quantity is given by L(t) = frac-2N ln(  psi(t)  psi(0)  ) where N is the system size. One typically starts from a groundstate and then quenches the hamiltonian to a different point. Non analycities in the loschmidth echo are called 'dynamical quantum phase transitions'.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"In the mentioned paper they work with H(g) = - sum^N-1_i=1 sigma^z_i sigma^z_i+1 + g sum_i=1^N sigma^x_i and show that divergences occur when quenching across the critical point (g₀→g₁) for t^*_n = t^*(n+frac12) with t^* = pie(g_1k^*), cos(k^*) = (1+g_0 g_1)  (g_0 + g_1), e(gk) = sqrt(g-cos k)^2 + sin^2 k.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"The outline of the tutorial is as follows. We will pick g₀ = 0.5, g₁ = 2.0, perform the time evolution at different system sizes and compare with the thermodynamic limit. For those g we expect non-analicities to occur at t_n  235 (n + 12).","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"First we construct the hamiltonian in mpo form:","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function ising_ham(g)\n    (σˣ,σʸ,σᶻ) = nonsym_spintensors(1//2).*2;\n\n    data = Array{Any,3}(missing,1,3,3);\n    data[1,1,1] = one(σˣ); data[1,end,end] = one(σˣ);\n    data[1,1,2] = -σᶻ;\n    data[1,2,end] = σᶻ;\n    data[1,1,end] = g*σˣ;\n\n    MPOHamiltonian(data);\nend","category":"page"},{"location":"tut/timeev/#Finite-MPS-quenching-1","page":"DQPT in ising","title":"Finite MPS quenching","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Construct an initial finite system","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"len = 20;\ninit = FiniteMPS(rand,ComplexF64,len,ℂ^2,ℂ^10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Find the pre-quench groundstate","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(ψ₀,_) = find_groundstate(init,ising_ham(0.5),Dmrg());","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"We can define a help function that measures the loschmith echo","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"echo(ψ₀::FiniteMPS,ψₜ::FiniteMPS) = -2*log(abs(dot(ψ₀,ψₜ)))/length(ψ₀)\n@assert isapprox(echo(ψ₀,ψ₀),0,atol=1e-10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"we will initially use a 2site tdvp scheme to increase the bond dimension while time evolving, and later on switch to a faster one-site scheme. A single timestep can be done using","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"ψₜ = copy(ψ₀);\ndt = 0.01;\n\n(ψₜ,pars) = timestep(ψₜ,ising_ham(2),dt,Tdvp2(trscheme=truncdim(20)));","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"\"pars\" is a kind of cache object that keeps track of all environments in ψ. It is often advantageous to re-use the environment, so that mpskit doesn't need to recalculate everything.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Putting it all together, we get","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function finite_sim(len; dt = 0.05, finaltime = 5.0)\n    ψ₀ = FiniteMPS(rand,ComplexF64,len,ℂ^2,ℂ^10);\n    (ψ₀,_) = find_groundstate(ψ₀,ising_ham(0.5),Dmrg());\n\n    post_quench_ham = ising_ham(2);\n    ψₜ = copy(ψ₀);\n    pars = params(ψₜ,post_quench_ham);\n\n    echos = [echo(ψₜ,ψ₀)];\n    times = collect(0:dt:finaltime);\n\n    @showprogress for t = times[2:end]\n        alg = t > 3*dt ? Tdvp() : Tdvp2(trscheme = truncdim(50))\n        (ψₜ,pars) = timestep(ψₜ,post_quench_ham,dt,alg,pars);\n        push!(echos,echo(ψₜ,ψ₀))\n    end\n\n    return (times,echos)\nend","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(Image: )","category":"page"},{"location":"tut/timeev/#Infinite-MPS-quenching-1","page":"DQPT in ising","title":"Infinite MPS quenching","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Similarly we start with an initial infinite state","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"init = InfiniteMPS([ℂ^2],[ℂ^10]);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"and find the pre-quench groundstate","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(ψ₀,_) = find_groundstate(init,ising_ham(0.5),Vumps());","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"The dot product of two infinite matrix product states scales as  alpha ^N where α is the dominant eigenvalue of the transfer matrix. It is this α that is returned when calling","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"dot(ψ₀,ψ₀)","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"so the loschmidth echo takes on the pleasant form","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"echo(ψ₀::InfiniteMPS,ψₜ::InfiniteMPS) = -2*log(abs(dot(ψ₀,ψₜ)))\n@assert isapprox(echo(ψ₀,ψ₀),0,atol=1e-10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"This time we cannot use a 2site scheme to grow the bond dimension, as this isn't implemented (yet). Instead, we have to make use of the changebonds machinery. Multiple algorithms are available, but we will only focus on OptimalEpand(). Growing the bond dimension by 5 can be done by calling:","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"ψₜ = copy(ψ₀);\n(ψₜ,pars) = changebonds(ψₜ,ising_ham(2),OptimalExpand(trscheme=truncdim(5)));","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"a single timestep is easy","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"dt = 0.01;\n\n(ψₜ,pars) = timestep(ψₜ,ising_ham(2),dt,Tdvp(),pars);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"With performance in mind we should once again try to re-use these \"pars\" cache objects. The final code is","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function infinite_sim(dt = 0.05, finaltime = 5.0)\n    ψ₀ = InfiniteMPS([ℂ^2],[ℂ^10]);\n    (ψ₀,_) = find_groundstate(ψ₀,ising_ham(0.5),Vumps());\n\n    post_quench_ham = ising_ham(2);\n    ψₜ = copy(ψ₀);\n    pars = params(ψₜ,post_quench_ham);\n\n    echos = [echo(ψₜ,ψ₀)];\n    times = collect(0:dt:finaltime);\n\n    @showprogress for t = times[2:end]\n        if t < 50*dt # if t is sufficiently small, we increase the bond dimension\n            (ψₜ,pars) = changebonds(ψₜ,post_quench_ham,OptimalExpand(trscheme=truncdim(1)),pars)\n        end\n        (ψₜ,pars) = timestep(ψₜ,post_quench_ham,dt,Tdvp(),pars);\n        push!(echos,echo(ψₜ,ψ₀))\n    end\n\n    return (times,echos)\nend","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(Image: )","category":"page"},{"location":"man/environments/#um_environments-1","page":"Environments","title":"Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"In many tensor network algorithms we encounter partially contracted tensor networks. In dmrg for example, one needs to know the sum of all the hamiltonian contributions left and right of the site that we want to optimize. If you then optimize the neighboring site to the right, you only need to add one new contribution to the previous sum of hamiltonian contributions.","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This kind of information is stored in the environment objects (at the moment called \"Cache\" in our code, but the name is subject to change). The goal is that the user should preferably never have to deal with the caches, but being aware of the inner workings may allow you to write more efficient code. That is why they are nonetheless included in the manual.","category":"page"},{"location":"man/environments/#Finite-Environments-1","page":"Environments","title":"Finite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"When you create a state and a hamiltonian:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"an environment object can be created by calling","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache = params(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"The partially contracted mpohamiltonian left of site i can then be queried using:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This may take some time, but a subsequent call to","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i-1,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Should pretty much be free. Behind the scenes the cache stored all tensors it used to calculate leftenv (state.AL[1 .. i]) and when queried again, it checks if the tensors it previously used are identical (using ===). If so, it can simply return the previously stored results. If not, it will recalculate again. If you update a tensor in-place, the caches cannot know using === that the actual tensors have changed. If you do this, you have to call poison!(state,i).","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"As an optional argument, many algorithms allow you to pass in an environment object, and they also return an updated one. Therefore, for time evolution code, it is more efficient to give it the updated caches every time step, instead of letting it recalculate.","category":"page"},{"location":"man/environments/#Infinite-Environments-1","page":"Environments","title":"Infinite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Infinite Environments are very similar :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\ncache = params(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"There are also some notable differences. Infinite environments typically require solving linear problems or eigenvalue problems iteratively with finite precision. To find out what precision we used we can type:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"(cache.tol,cache.maxiter)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"To recalculate with a different precision :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache.tol=1e-8;\nrecalculate!(cache,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Similar to finite environments, when queried with a different state:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"different_state = InfiniteMPS([ℂ^2],[ℂ^10]);\nleftenv(cache,3,different_state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"the cache will simply check if the states match up and if not, recalculate! behind the scenes.","category":"page"},{"location":"man/algorithms/#um_algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms/#minimizing-the-energy-1","page":"Algorithms","title":"minimizing the energy","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,Dmrg())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"will use dmrg to minimize the energy. Sometimes it can be useful to do more extensive logging or to perform dynamical bond dimension expansion. That's why the Dmrg() constructor allows you to specify a finalize function","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"function finalize(iter,state,ham,pars)\n    println(\"Hello from iteration $iter\")\n    return state,pars;\nend\n\nDmrg(finalize=my_finalize)","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Similar functionality is provided (or soon to be implemented) in other groundstate algorithms. Other algorithms are provided and can be found in the library documentation.","category":"page"},{"location":"man/algorithms/#timestep-1","page":"Algorithms","title":"timestep","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(newstate,environments) = timestep(state,operator,0.3,Tdvp2(trscheme=truncdim(20)))","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"will evolve 'state' forwards in time by 0.3 seconds. Here we use a 2 site update scheme, which will truncate the 2site tensor back down, truncating at bond dimension 20. An overview of all time evolution algorithms is in the library documentation.","category":"page"},{"location":"man/algorithms/#dynamicaldmrg-1","page":"Algorithms","title":"dynamicaldmrg","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Dynamical dmrg has been described in other papers and is a way to find the propagator. The basic idea is that to calculate G(z) =  V  (H-z)^-1  V  , one can variationally find (H-z) W  =  V  and then the propagator simply equals G(z) =  V  W .","category":"page"},{"location":"man/algorithms/#quasiparticle-excitations-1","page":"Algorithms","title":"quasiparticle excitations","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"We export code that implements the quasiparticle excitation ansatz for finite and infinite systems. For example, the following calculates the haldane gap for spin-1 heisenberg.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_xxz_ham()\nts = InfiniteMPS([ℂ^3],[ℂ^48]);\n(ts,pars,_) = find_groundstate(ts,th,Vumps(maxiter=400,verbose=false));\n(energies,Bs) = quasiparticle_excitation(th,Float64(pi),ts,pars);\n@test energies[1] ≈ 0.41047925 atol=1e-4","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For infinite systems you have to specify the momentum of your particle. In contrast, momentum is not a well defined quantum number and you therefore do not have to specify it when finding excitations on top of a finite mps.","category":"page"},{"location":"man/algorithms/#fidelity-susceptibility-1","page":"Algorithms","title":"fidelity susceptibility","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The fidelity susceptibility measures how much the groundstate changes when tuning a parameter in your hamiltonian. Divergences occur at phase transitions, making it a valuable measure when no order parameter is known.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"suscept = fidelity_susceptibility(groundstate,H_0,perturbing_Hams::AbstractVector)","category":"page"},{"location":"tut/haldane/#tut_haldane-1","page":"The haldane gap","title":"The haldane gap","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"In this tutorial we will calculate the haldane gap (the energy gap in spin 1 heisenberg) in 2 different ways. To follow the tutorial you need the following packages.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"using MPSKit,TensorKit","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"We will enforce the su(2) symmetry, our hamiltonian will therefore be","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"ham = su2_xxx_ham(spin=1);","category":"page"},{"location":"tut/haldane/#Finite-size-extrapolation-1","page":"The haldane gap","title":"Finite size extrapolation","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The first step is always the same, we want to find the groundstate of our system.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"len = 10;\nphysical_space = ℂ[SU₂](1=>1);\nvirtual_space = ℂ[SU₂](0=>20,1=>20,2=>10,3=>10,4=>5);\n\ninitial_state = FiniteMPS(rand,ComplexF64,len,physical_space,virtual_space);\n(gs,pars,delta) = find_groundstate(initial_state,ham,Dmrg());","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The typical way to find excited states is to minmize the energy while adding an error term lambda  gs   gs . Here we will instead use the quasiparticle ansatz.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"In steven white's original DMRG paper it was remarked that the S=1 excitations correspond to edge states, and that one should define the haldane gap as the difference in energy between the S=2 and S=1 states. This can be done as follows.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(En_1,_) = quasiparticle_excitation(ham,gs,pars,excitation_space = ℂ[SU₂](1=>1))\n(En_2,_) = quasiparticle_excitation(ham,gs,pars,excitation_space = ℂ[SU₂](2=>1))\nEn_2[1]-En_1[1]","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"We can now extrapolate this value for different len, and approximately find the haldane gap.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#Thermodynamic-limit-1","page":"The haldane gap","title":"Thermodynamic limit","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"A much nicer way of obtaining the haldane gap is by working directly in the thermodynamic limit.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"initial_state = InfiniteMPS([physical_space],[virtual_space]);\n(gs,pars,delta) = find_groundstate(initial_state,ham,Vumps());","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The haldane gap in the thermodynamic limit is the energy of the S=1 excitation at momentum pi.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Energies,_) = quasiparticle_excitation(ham,Float64(pi),gs,pars,excitation_space=ℂ[SU₂](1=>1))\nEnergies[1]","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"Which prints out 0.4104791728966182, in agreement with known results.","category":"page"},{"location":"tut/xxz_groundstate/#Analyzing-the-xxz-model-1","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"In this file we will give step by step instructions to analyze the spin 1/2 xxz model. The necessary packages to follow this tutorial are :","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"using MPSKit,TensorKit,Plots,LinearAlgebra","category":"page"},{"location":"tut/xxz_groundstate/#Failure-1","page":"Analyzing the xxz model","title":"Failure","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"First we should define the hamiltonian we want to work with. The following code does so in the mpo representation of the hamiltonian.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\nham_data = fill(zero(id),1,5,5);\nham_data[1,1,1] = id; ham_data[1,end,end] = id;\nham_data[1,1,2] = sx; ham_data[1,2,end] = sx;\nham_data[1,1,3] = sy; ham_data[1,3,end] = sy;\nham_data[1,1,4] = sz; ham_data[1,4,end] = sz;\nham = MPOHamiltonian(ham_data);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We then need an intial state, which we shall later optimize. In this example we work directly in the thermodynamic limit.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"random_data = TensorMap(rand,ComplexF64,ℂ^50*ℂ^2,ℂ^50);\nstate = InfiniteMPS([random_data]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"The groundstate can then be found by calling find_groundstate.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Vumps());","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"As you can see, this struggles to converge. To understand why, we can look at schmidth decomposition of our 'groundstate'. Our states are centergauged, which means that they can be represented as: (Image: )","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"with AL and AR respectively left and right unitary. The schmidth decomposition is therefore the svd of this C matrix:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(U,S,V) = tsvd(groundstate.CR[1]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We would like to plot S, but it is still a TensorMap. At the moment, you can plot the diagonal elements by calling:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"S_array = convert(Array,S); #convert it to an array\nS_diag = diag(S_array); #get the diagonal elements\nplot(S_diag,yscale=:log10,seriestype=:scatter) #plot them","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(Image: )","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We clearly see that the dominant schmidth coefficient is doubly degenerate, implying that the groundstate of xxz can only be represented using a 2-site periodic unit cell.","category":"page"},{"location":"tut/xxz_groundstate/#Success-1","page":"Analyzing the xxz model","title":"Success","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Let's initialize a different initial state, this time with a 2-site unit cell:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"A = TensorMap(rand,ComplexF64,ℂ^50*ℂ^2,ℂ^50);\nB = TensorMap(rand,ComplexF64,ℂ^50*ℂ^2,ℂ^50);\nstate = InfiniteMPS([A,B]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"In MPSKit, we require that the periodicity of the hamiltonian equals that of the state it is applied to. This is not a big obstacle, you can simply repeat the original hamiltonian:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"@assert ham.period == 1\nham = repeat(ham,2);\n@assert ham.period == 2","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Running vumps once again we get convergence:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Vumps(maxiter=400,tol_galerkin=1e-12));","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"One may be worried that if ... - [A B] - [A B] - [A B] - ... is a groundstate, the one-site shifted version may also be a totally different groundstate. It's easy to check that this is not true.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"shifted_groundstate = InfiniteMPS([groundstate.AL[2],groundstate.AL[1]]);\noverlap = abs(dot(shifted_groundstate,groundstate))\n@assert isapprox(overlap,1,atol=1e-1)","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"overlap is close to 1, indicating that both states are identical.","category":"page"},{"location":"tut/xxz_groundstate/#Symmetries-1","page":"Analyzing the xxz model","title":"Symmetries","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"The xxz hamiltonian is su(2) symmetric and we can exploit this to greatly speed up the simulation.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"It is cumbersome to construct symmetric hamiltonians, but luckily su(2) symmetric xxz is already implemented:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"ham = repeat(su2_xxx_ham(spin=1//2),2);\n@assert ham.pspaces[1] == ℂ[SU₂](1//2 => 1)","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Our initial state should also be su(2) symmetric. It now becomes apparant why we have to use a 2 site periodic state. The physical space carries a half-integer charge and the first tensor maps the first virtual space ⊗ the physical space to the second virtual space. Half integer virtual charges will therefore map only to integer charges, and vice versa. The staggering happens on the virtual level!","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"An alternative constructor for the initial state is","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"D1 = ℂ[SU₂](1//2 => 10,3//2=>5,5//2=>2);\nD2 = ℂ[SU₂](0=>15,1=>10,2=>5);\nstate = InfiniteMPS([ℂ[SU₂](1//2 => 1),ℂ[SU₂](1//2 => 1)],[D1,D2])","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Even though the bond dimension is higher then in the non symmetric example:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"@assert dim(D1) == 52;\n@assert dim(D2) == 70;","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Vumps converges much much faster","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Vumps(maxiter=400,tol_galerkin=1e-12));","category":"page"},{"location":"man/operators/#um_operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/#MPOHamiltonian-1","page":"Operators","title":"MPOHamiltonian","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"We represent all quantum hamiltonians in their mpo form. As an example, the following bit of code constructs the ising hamiltonian.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\ndata = Array{Any,3}(missing,1,3,3);\ndata[1,1,1] = id;\ndata[1,1,2] = -sz;\ndata[1,2,3] = sz;\ndata[1,1,3] = 3*sx;\nham = MPOHamiltonian(data);","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"When we work with symmetries, it is often not possible to represent the entire hamiltonian as a sum of a product of one-body operators. In xxz for examples, only the sum (sx sx + sy sy + sz sz) is su(2) symmetric, but individually none of the terms are. It is for this reason that we use 4 leg mpo tensors in this hamiltonian object. The following bit of code","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"ham[1,1,1]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Will print out a tensormap mapping (virtual space x physical space) to (virtual space x physical space). The conversion to mpo tensors was done automagically behind the scenes!","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"MPOHamiltonian are always assumed to be periodic in the first index (position). In this way, we can both represent periodic infinite hamiltonians and place dependent finite hamiltonians.","category":"page"},{"location":"man/operators/#PeriodicMPO-1","page":"Operators","title":"PeriodicMPO","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"This operator is used for statistical physics problems. It is simply a 2 dimensional periodic array of mpo tensors.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Can be created using","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"PeriodicMPO(t::AbstractArray{T,2}) where T<:MPOTensor","category":"page"},{"location":"man/operators/#ComAct-1","page":"Operators","title":"ComAct","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"We can deal with thermal density matrices by mapping them back to a state with hilbert space p*p'. Time evolution is then done using the (anti)commutator of the original hamiltonian. ComAct represents this object and can be created by calling","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"anticommutator(ham)\ncommutator(ham)","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Only finite density matrices are supported at the moment. If you want to do finite temperature stuff in the thermodynamic limit, then you should manually fuse p*p' and construct the the commutator in this space.","category":"page"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This code track contains the numerical research and development of the Ghent Quantum Group with regard to tensor network simulation in the julia language. The purpose of this package is to facilitate efficient collaboration between different members of the group.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Topics of research on tensor networks within the realm of this track include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tensor network algorithms (excitations, tdvp, vumps, ...)\nMPS routines (MPS diagonalization, Schmidt Decomposition, MPS left and right multiplication, ...)\nThe study of several useful models (nearest neighbour interactions, MPO's, long range interactions, ...)","category":"page"},{"location":"#User-manual-1","page":"Home","title":"User manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\",\"man/states.md\",\"man/operators.md\",\"man/algorithms.md\"]\nDepth = 3","category":"page"},{"location":"#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"tut/xxz_groundstate.md\",\"tut/timeev.md\",\"tut/haldane.md\"]\nDepth = 1","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/lib.md\"]\nDepth = 1","category":"page"}]
}
