<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · MPSKit.jl</title><meta name="title" content="Algorithms · MPSKit.jl"/><meta property="og:title" content="Algorithms · MPSKit.jl"/><meta property="twitter:title" content="Algorithms · MPSKit.jl"/><meta name="description" content="Documentation for MPSKit.jl."/><meta property="og:description" content="Documentation for MPSKit.jl."/><meta property="twitter:description" content="Documentation for MPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Prerequisites</a></li><li><a class="tocitem" href="../states/">States</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Groundstates"><span>Groundstates</span></a></li><li><a class="tocitem" href="#Time-evolution"><span>Time evolution</span></a></li><li><a class="tocitem" href="#Excitations"><span>Excitations</span></a></li><li><a class="tocitem" href="#changebonds"><span><code>changebonds</code></span></a></li><li><a class="tocitem" href="#Leading-boundary"><span>Leading boundary</span></a></li><li><a class="tocitem" href="#approximate"><span><code>approximate</code></span></a></li><li><a class="tocitem" href="#Varia"><span>Varia</span></a></li></ul></li><li><a class="tocitem" href="../parallelism/">Parallelism in julia</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../lib/lib/">Library</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/main/docs/src/man/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="um_algorithms"><a class="docs-heading-anchor" href="#um_algorithms">Algorithms</a><a id="um_algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#um_algorithms" title="Permalink"></a></h1><p>Here is a collection of the algorithms that have been added to MPSKit.jl. If a particular algorithm is missing, feel free to let us know via an issue, or contribute via a PR.</p><h2 id="Groundstates"><a class="docs-heading-anchor" href="#Groundstates">Groundstates</a><a id="Groundstates-1"></a><a class="docs-heading-anchor-permalink" href="#Groundstates" title="Permalink"></a></h2><p>One of the most prominent use-cases of MPS is to obtain the groundstate of a given (quasi-) one-dimensional quantum Hamiltonian. In MPSKit.jl, this can be achieved through <code>find_groundstate</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.find_groundstate-man-algorithms" href="#MPSKit.find_groundstate-man-algorithms"><code>MPSKit.find_groundstate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_groundstate(ψ₀, H, [environments]; kwargs...) -&gt; (ψ, environments, ϵ)
find_groundstate(ψ₀, H, algorithm, environments) -&gt; (ψ, environments, ϵ)</code></pre><p>Compute the groundstate for Hamiltonian <code>H</code> with initial guess <code>ψ</code>. If not specified, an optimization algorithm will be attempted based on the supplied keywords.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess</li><li><code>H::AbstractMPO</code>: operator for which to find the groundstate</li><li><code>[environments]</code>: MPS environment manager</li><li><code>algorithm</code>: optimization algorithm</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>ψ::AbstractMPS</code>: converged groundstate</li><li><code>environments</code>: environments corresponding to the converged state</li><li><code>ϵ::Float64</code>: final convergence error upon terminating the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/find_groundstate.jl#L1-L23">source</a></section></article><p>There is a variety of algorithms that have been developed over the years, and many of them have been implemented in MPSKit. Keep in mind that some of them are exclusive to finite or infinite systems, while others may work for both. Many of these algorithms have different advantages and disadvantages, and figuring out the optimal algorithm is not always straightforward, since this may strongly depend on the model. Here, we enumerate some of their properties in hopes of pointing you in the right direction.</p><h3 id="DMRG"><a class="docs-heading-anchor" href="#DMRG">DMRG</a><a id="DMRG-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG" title="Permalink"></a></h3><p>Probably the most widely used algorithm for optimizing groundstates with MPS is <a href="#DMRG"><code>DMRG</code></a> and its variants. This algorithm sweeps through the system, optimizing a single site while keeping all others fixed. Since this local problem can be solved efficiently, the global optimal state follows by alternating through the system. However, because of the single-site nature of this algorithm, this can never alter the bond dimension of the state, such that there is no way of dynamically increasing the precision. This can become particularly relevant in the cases where symmetries are involved, since then finding a good distribution of charges is also required. To circumvent this, it is also possible to optimize over two sites at the same time with <a href="../../lib/lib/#MPSKit.DMRG2"><code>DMRG2</code></a>, followed by a truncation back to the single site states. This can dynamically change the bond dimension but comes at an increase in cost.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DMRG-man-algorithms" href="#MPSKit.DMRG-man-algorithms"><code>MPSKit.DMRG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DMRG{A, F} &lt;: MPSKit.Algorithm</code></pre><p>Single-site DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/dmrg.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DMRG2-man-algorithms" href="#MPSKit.DMRG2-man-algorithms"><code>MPSKit.DMRG2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DMRG2{A, S, F} &lt;: MPSKit.Algorithm</code></pre><p>Two-site DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for <a href="https://quantumkithub.github.io/TensorKit.jl/stable/lib/tensors/#TensorKit.tsvd">truncation</a> of the two-site update</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/dmrg.jl#L70">source</a></section></article><p>For infinite systems, a similar approach can be used by dynamically adding new sites to the middle of the system and optimizing over them. This gradually increases the system size until the boundary effects are no longer felt. However, because of this approach, for critical systems this algorithm can be quite slow to converge, since the number of steps needs to be larger than the correlation length of the system. Again, both a single-site and a two-site version are implemented, to have the option to dynamically increase the bonddimension at a higher cost.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.IDMRG-man-algorithms" href="#MPSKit.IDMRG-man-algorithms"><code>MPSKit.IDMRG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IDMRG{A} &lt;: MPSKit.Algorithm</code></pre><p>Single site infinite DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the MPS</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/idmrg.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.IDMRG2-man-algorithms" href="#MPSKit.IDMRG2-man-algorithms"><code>MPSKit.IDMRG2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IDMRG2{A, S} &lt;: MPSKit.Algorithm</code></pre><p>Two-site infinite DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the MPS</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for <a href="https://quantumkithub.github.io/TensorKit.jl/stable/lib/tensors/#TensorKit.tsvd">truncation</a> of the two-site update</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/idmrg.jl#L102">source</a></section></article><h3 id="VUMPS"><a class="docs-heading-anchor" href="#VUMPS">VUMPS</a><a id="VUMPS-1"></a><a class="docs-heading-anchor-permalink" href="#VUMPS" title="Permalink"></a></h3><p><a href="#VUMPS"><code>VUMPS</code></a> is an (I)DMRG inspired algorithm that can be used to Variationally find the groundstate as a Uniform (infinite) Matrix Product State. In particular, a local update is followed by a re-gauging procedure that effectively replaces the entire network with the newly updated tensor. Compared to IDMRG, this often achieves a higher rate of convergence, since updates are felt throughout the system immediately. Nevertheless, this algorithm only works whenever the state is injective, i.e. there is a unique ground state. Since this is a single-site algorithm, this cannot alter the bond dimension.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.VUMPS-man-algorithms" href="#MPSKit.VUMPS-man-algorithms"><code>MPSKit.VUMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VUMPS{F} &lt;: MPSKit.Algorithm</code></pre><p>Variational optimization algorithm for uniform matrix product states, based on the combination of DMRG with matrix product state tangent space concepts.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_environments::Any</code>: algorithm used for the MPS environments</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#zauner-stauber2018">Zauner-Stauber et al. Phys. Rev. B 97 (2018)</a></li><li><a href="../../references/#vanderstraeten2019">Vanderstraeten et al. SciPost Phys. Lect. Notes 7 (2019)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/vumps.jl#L1">source</a></section></article><h3 id="Gradient-descent"><a class="docs-heading-anchor" href="#Gradient-descent">Gradient descent</a><a id="Gradient-descent-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-descent" title="Permalink"></a></h3><p>Both finite and infinite matrix product states can be parametrized by a set of isometric tensors, which we can optimize over. Making use of the geometry of the manifold (a Grassmann manifold), we can greatly outperform naive optimization strategies. Compared to the other algorithms, quite often the convergence rate in the tail of the optimization procedure is higher, such that often the fastest method combines a different algorithm far from convergence with this algorithm close to convergence. Since this is again a single-site algorithm, there is no way to alter the bond dimension.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.GradientGrassmann-man-algorithms" href="#MPSKit.GradientGrassmann-man-algorithms"><code>MPSKit.GradientGrassmann</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GradientGrassmann{O&lt;:OptimKit.OptimizationAlgorithm, F} &lt;: MPSKit.Algorithm</code></pre><p>Variational gradient-based optimization algorithm that keeps the MPS in left-canonical form, as points on a Grassmann manifold. The optimization is then a Riemannian gradient descent  with a preconditioner to induce the metric from the Hilbert space inner product.</p><p><strong>Fields</strong></p><ul><li><p><code>method::OptimKit.OptimizationAlgorithm</code>: optimization algorithm</p></li><li><p><code>finalize!::Any</code>: callback function applied after each iteration, of signature <code>finalize!(x, f, g, numiter) -&gt; x, f, g</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#hauru2021">Hauru et al. SciPost Phys. 10 (2021)</a></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">GradientGrassmann(; kwargs...)</code></pre><p><strong>Keywords</strong></p><ul><li><code>method=ConjugateGradient</code>: instance of optimization algorithm, or type of optimization   algorithm to construct</li><li><code>finalize!</code>: finalizer algorithm</li><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: level of information display</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/groundstate/gradient_grassmann.jl#L1">source</a></section></article><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><p>Given a particular state, it can also often be useful to have the ability to examine the evolution of certain properties over time. To that end, there are two main approaches to solving the Schrödinger equation in MPSKit.</p><p class="math-container">\[i \hbar \frac{d}{dt} \Psi = H \Psi \implies \Psi(t) = \exp{\left(-iH(t - t_0)\right)} \Psi(t_0)\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.timestep-man-algorithms" href="#MPSKit.timestep-man-algorithms"><code>MPSKit.timestep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timestep(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
timestep!(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-step the state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time step <code>dt</code> at time <code>t</code>, solving the Schroedinger equation: <span>$i ∂ψ/∂t = H ψ$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/time_evolve.jl#L50-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.time_evolve-man-algorithms" href="#MPSKit.time_evolve-man-algorithms"><code>MPSKit.time_evolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_evolve(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
time_evolve!(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-evolve the initial state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time span by stepping through each of the time points obtained by iterating t_span.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t_span::AbstractVector{&lt;:Number}</code>: time points over which the time evolution is stepped</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbosity::Int=0</code>: verbosity level for logging</li><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/time_evolve.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.make_time_mpo-man-algorithms" href="#MPSKit.make_time_mpo-man-algorithms"><code>MPSKit.make_time_mpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_time_mpo(H::MPOHamiltonian, dt::Number, alg; kwargs...) -&gt; O::MPO</code></pre><p>Construct an <code>MPO</code> that approximates <span>$\exp(-iHdt)$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution operator is constructed   with an imaginary time step instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>).   This can be useful for using this function to compute the ground state of a Hamiltonian,   or to compute finite-temperature properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/time_evolve.jl#L75-L86">source</a></section></article><h3 id="TDVP"><a class="docs-heading-anchor" href="#TDVP">TDVP</a><a id="TDVP-1"></a><a class="docs-heading-anchor-permalink" href="#TDVP" title="Permalink"></a></h3><p>The first is focused around approximately solving the equation for a small timestep, and repeating this until the desired evolution is achieved. This can be achieved by projecting the equation onto the tangent space of the MPS, and then solving the results. This procedure is commonly referred to as the <a href="#TDVP"><code>TDVP</code></a> algorithm, which again has a two-site variant to allow for dynamically altering the bond dimension.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TDVP-man-algorithms" href="#MPSKit.TDVP-man-algorithms"><code>MPSKit.TDVP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TDVP{A, F} &lt;: MPSKit.Algorithm</code></pre><p>Single site MPS time-evolution algorithm based on the Time-Dependent Variational Principle.</p><p><strong>Fields</strong></p><ul><li><p><code>integrator::Any</code>: algorithm used in the exponential solvers</p></li><li><p><code>tolgauge::Float64</code>: tolerance for gauging algorithm</p></li><li><p><code>gaugemaxiter::Int64</code>: maximal amount of iterations for gauging algorithm</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2011">Haegeman et al. Phys. Rev. Lett. 107 (2011)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/tdvp.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TDVP2-man-algorithms" href="#MPSKit.TDVP2-man-algorithms"><code>MPSKit.TDVP2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TDVP2{A, S, F} &lt;: MPSKit.Algorithm</code></pre><p>Two-site MPS time-evolution algorithm based on the Time-Dependent Variational Principle.</p><p><strong>Fields</strong></p><ul><li><p><code>integrator::Any</code>: algorithm used in the exponential solvers</p></li><li><p><code>tolgauge::Float64</code>: tolerance for gauging algorithm</p></li><li><p><code>gaugemaxiter::Int64</code>: maximal amount of iterations for gauging algorithm</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for truncation of the two-site update</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2011">Haegeman et al. Phys. Rev. Lett. 107 (2011)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/tdvp.jl#L134">source</a></section></article><h3 id="Time-evolution-MPO"><a class="docs-heading-anchor" href="#Time-evolution-MPO">Time evolution MPO</a><a id="Time-evolution-MPO-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution-MPO" title="Permalink"></a></h3><p>The other approach instead tries to first approximately represent the evolution operator, and only then attempts to apply this operator to the initial state. Typically the first step happens through <a href="../../lib/lib/#MPSKit.make_time_mpo"><code>make_time_mpo</code></a>, while the second can be achieved through <a href="#approximate"><code>approximate</code></a>. Here, there are several algorithms available</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.WI-man-algorithms" href="#MPSKit.WI-man-algorithms"><code>MPSKit.WI</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const WI = TaylorCluster(; N=1, extension=false, compression=false)</code></pre><p>First order Taylor expansion for a time-evolution MPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/taylorcluster.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.WII-man-algorithms" href="#MPSKit.WII-man-algorithms"><code>MPSKit.WII</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct WII &lt;: MPSKit.Algorithm</code></pre><p>Generalization of the Euler approximation of the operator exponential for MPOs.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal number of iterations</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#zaletel2015">Zaletel et al. Phys. Rev. B 91 (2015)</a></li><li><a href="../../references/#paeckel2019">Paeckel et al. Ann. of Phys. 411 (2019)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/wii.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TaylorCluster-man-algorithms" href="#MPSKit.TaylorCluster-man-algorithms"><code>MPSKit.TaylorCluster</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TaylorCluster &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for constructing the <code>N</code>th order time evolution MPO using the Taylor cluster expansion.</p><p><strong>Fields</strong></p><ul><li><p><code>N::Int64</code>: order of the Taylor expansion</p></li><li><p><code>extension::Bool</code>: include higher-order corrections</p></li><li><p><code>compression::Bool</code>: approximate compression of corrections, accurate up to order <code>N</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#vandamme2024">Van Damme et al. SciPost Phys. 17 (2024)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/timestep/taylorcluster.jl#L1">source</a></section></article><h2 id="Excitations"><a class="docs-heading-anchor" href="#Excitations">Excitations</a><a id="Excitations-1"></a><a class="docs-heading-anchor-permalink" href="#Excitations" title="Permalink"></a></h2><p>It might also be desirable to obtain information beyond the lowest energy state of a given system, and study the dispersion relation. While it is typically not feasible to resolve states in the middle of the energy spectrum, there are several ways to target a few of the lowest-lying energy states.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.excitations-man-algorithms" href="#MPSKit.excitations-man-algorithms"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, ψ::FiniteQP, [left_environments],
            [right_environments]; num=1) -&gt; (energies, states)
excitations(H, algorithm::QuasiparticleAnsatz, ψ::InfiniteQP, [left_environments],
            [right_environments]; num=1, solver=Defaults.solver) -&gt; (energies, states)
excitations(H, algorithm::FiniteExcited, ψs::NTuple{&lt;:Any, &lt;:FiniteMPS};
            num=1, init=copy(first(ψs))) -&gt; (energies, states)
excitations(H, algorithm::ChepigaAnsatz, ψ::FiniteMPS, [envs];
            num=1, pos=length(ψ)÷2) -&gt; (energies, states)
excitations(H, algorithm::ChepigaAnsatz2, ψ::FiniteMPS, [envs];
            num=1, pos=length(ψ)÷2) -&gt; (energies, states)</code></pre><p>Compute the first excited states and their energy gap above a groundstate.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm</code>: optimization algorithm</li><li><code>ψ::QP</code>: initial quasiparticle guess</li><li><code>ψs::NTuple{N, &lt;:FiniteMPS}</code>: <code>N</code> first excited states</li><li><code>[left_environments]</code>: left groundstate environment</li><li><code>[right_environments]</code>: right groundstate environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>solver</code>: algorithm for the linear solver of the quasiparticle environments</li><li><code>init</code>: initial excited state guess</li><li><code>pos</code>: position of perturbation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/excitation/excitations.jl#L1-L28">source</a></section></article><h3 id="Quasiparticle-Ansatz"><a class="docs-heading-anchor" href="#Quasiparticle-Ansatz">Quasiparticle Ansatz</a><a id="Quasiparticle-Ansatz-1"></a><a class="docs-heading-anchor-permalink" href="#Quasiparticle-Ansatz" title="Permalink"></a></h3><p>The Quasiparticle Ansatz offers an approach to compute low-energy eigenstates in quantum systems, playing a key role in both finite and infinite systems. It leverages localized perturbations for approximations, as detailed in (<a href="../../references/#haegeman2013">Haegeman <em>et al.</em>, 2013</a>).</p><h4 id="Finite-Systems:"><a class="docs-heading-anchor" href="#Finite-Systems:">Finite Systems:</a><a id="Finite-Systems:-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Systems:" title="Permalink"></a></h4><p>In finite systems, we approximate low-energy states by altering a single tensor in the Matrix Product State (MPS) for each site, and summing these across all sites. This method introduces additional gauge freedoms, utilized to ensure orthogonality to the ground state. Optimizing within this framework translates to solving an eigenvalue problem. For example, in the transverse field Ising model, we calculate the first excited state as shown in the provided code snippet, amd check the accuracy against theoretical values. Some deviations are expected, both due to finite-bond-dimension and finite-size effects.</p><pre><code class="language-julia hljs"># Model parameters
g = 10.0
L = 16
H = transverse_field_ising(FiniteChain(L); g)

# Finding the ground state
ψ₀ = FiniteMPS(L, ℂ^2, ℂ^32)
ψ, = find_groundstate(ψ₀, H; verbosity=0)

# Computing excitations using the Quasiparticle Ansatz
Es, ϕs = excitations(H, QuasiparticleAnsatz(), ψ; num=1)
isapprox(Es[1], 2(g - 1); rtol=1e-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h4 id="Infinite-Systems:"><a class="docs-heading-anchor" href="#Infinite-Systems:">Infinite Systems:</a><a id="Infinite-Systems:-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Systems:" title="Permalink"></a></h4><p>The ansatz in infinite systems maintains translational invariance by perturbing every site in the unit cell in a plane-wave superposition, requiring momentum specification. The <a href="https://iopscience.iop.org/article/10.1088/0953-8984/1/19/001">Haldane gap</a> computation in the Heisenberg model illustrates this approach.</p><pre><code class="language-julia hljs"># Setting up the model and momentum
momentum = π
H = heisenberg_XXX()

# Ground state computation
ψ₀ = InfiniteMPS(ℂ^3, ℂ^48)
ψ, = find_groundstate(ψ₀, H; verbosity=0)

# Excitation calculations
Es, ϕs = excitations(H, QuasiparticleAnsatz(), momentum, ψ)
isapprox(Es[1], 0.41047925; atol=1e-4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h4 id="Charged-excitations:"><a class="docs-heading-anchor" href="#Charged-excitations:">Charged excitations:</a><a id="Charged-excitations:-1"></a><a class="docs-heading-anchor-permalink" href="#Charged-excitations:" title="Permalink"></a></h4><p>When dealing with symmetric systems, the default optimization is for eigenvectors with trivial total charge. However, quasiparticles with different charges can be obtained using the sector keyword. For instance, in the transverse field Ising model, we consider an excitation built up of flipping a single spin, aligning with <code>Z2Irrep(1)</code>.</p><pre><code class="language-julia hljs">g = 10.0
L = 16
H = transverse_field_ising(Z2Irrep, FiniteChain(L); g)
ψ₀ = FiniteMPS(L, Z2Space(0 =&gt; 1, 1 =&gt; 1), Z2Space(0 =&gt; 16, 1 =&gt; 16))
ψ, = find_groundstate(ψ₀, H; verbosity=0)
Es, ϕs = excitations(H, QuasiparticleAnsatz(), ψ; num=1, sector=Z2Irrep(1))
isapprox(Es[1], 2(g - 1); rtol=1e-2) # infinite analytical result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.QuasiparticleAnsatz-man-algorithms" href="#MPSKit.QuasiparticleAnsatz-man-algorithms"><code>MPSKit.QuasiparticleAnsatz</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct QuasiparticleAnsatz{A, E} &lt;: MPSKit.Algorithm</code></pre><p>Optimization algorithm for quasi-particle excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><p><code>alg::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_environments::Any</code>: algorithm used for the quasiparticle environments</p></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">QuasiparticleAnsatz()
QuasiparticleAnsatz(; kwargs...)
QuasiparticleAnsatz(alg)</code></pre><p>Create a <code>QuasiparticleAnsatz</code> algorithm with the given algorithm, or by passing the  keyword arguments to <code>Arnoldi</code>.</p><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2013">Haegeman et al. Phys. Rev. Let. 111 (2013)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/excitation/quasiparticleexcitation.jl#L5">source</a></section></article><h3 id="Finite-excitations"><a class="docs-heading-anchor" href="#Finite-excitations">Finite excitations</a><a id="Finite-excitations-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-excitations" title="Permalink"></a></h3><p>For finite systems we can also do something else - find the groundstate of the hamiltonian + <span>$\\text{weight} \sum_i | \\psi_i ⟩ ⟨ \\psi_i$</span>. This is also supported by calling</p><pre><code class="language-julia hljs"># Model parameters
g = 10.0
L = 16
H = transverse_field_ising(FiniteChain(L); g)

# Finding the ground state
ψ₀ = FiniteMPS(L, ℂ^2, ℂ^32)
ψ, = find_groundstate(ψ₀, H; verbosity=0)

Es, ϕs = excitations(H, FiniteExcited(), ψ; num=1)
isapprox(Es[1], 2(g - 1); rtol=1e-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.FiniteExcited-man-algorithms" href="#MPSKit.FiniteExcited-man-algorithms"><code>MPSKit.FiniteExcited</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteExcited{A} &lt;: MPSKit.Algorithm</code></pre><p>Variational optimization algorithm for excitations of finite MPS by minimizing the energy of</p><p class="math-container">\[H - λᵢ |ψᵢ⟩⟨ψᵢ|\]</p><p><strong>Fields</strong></p><ul><li><p><code>gsalg::Any</code>: optimization algorithm</p></li><li><p><code>weight::Float64</code>: energy penalty for enforcing orthogonality with previous states</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/excitation/dmrgexcitation.jl#L1">source</a></section></article><h3 id="&quot;Chepiga-Ansatz&quot;"><a class="docs-heading-anchor" href="#&quot;Chepiga-Ansatz&quot;">&quot;Chepiga Ansatz&quot;</a><a id="&quot;Chepiga-Ansatz&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Chepiga-Ansatz&quot;" title="Permalink"></a></h3><p>Computing excitations in critical systems poses a significant challenge due to the diverging correlation length, which requires very large bond dimensions. However, we can leverage this long-range correlation to effectively identify excitations. In this context, the left/right gauged MPS, serving as isometries, are effectively projecting the Hamiltonian into the low-energy sector. This projection method is particularly effective in long-range systems, where excitations are distributed throughout the entire system. Consequently, the low-lying energy spectrum can be extracted by diagonalizing the effective Hamiltonian (without any additional DMRG costs!). The states of these excitations are then represented by the ground state MPS, with one site substituted by the corresponding eigenvector. This approach is often referred to as the &#39;Chepiga ansatz&#39;, named after one of the authors of this paper (<a href="../../references/#chepiga2017">Chepiga and Mila, 2017</a>).</p><p>This is supported via the following syntax:</p><pre><code class="language-julia hljs">g = 10.0
L = 16
H = transverse_field_ising(FiniteChain(L); g)
ψ₀ = FiniteMPS(L, ComplexSpace(2), ComplexSpace(32))
ψ, envs, = find_groundstate(ψ₀, H; verbosity=0)
E₀ = real(sum(expectation_value(ψ, H, envs)))
Es, ϕs = excitations(H, ChepigaAnsatz(), ψ, envs; num=1)
isapprox(Es[1] - E₀, 2(g - 1); rtol=1e-2) # infinite analytical result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>In order to improve the accuracy, a two-site version also exists, which varies two neighbouring sites:</p><pre><code class="language-julia hljs">Es, ϕs = excitations(H, ChepigaAnsatz2(), ψ, envs; num=1)
isapprox(Es[1] - E₀, 2(g - 1); rtol=1e-2) # infinite analytical result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="changebonds"><a class="docs-heading-anchor" href="#changebonds"><code>changebonds</code></a><a id="changebonds-1"></a><a class="docs-heading-anchor-permalink" href="#changebonds" title="Permalink"></a></h2><p>Many of the previously mentioned algorithms do not possess a way to dynamically change to bond dimension. This is often a problem, as the optimal bond dimension is often not a priori known, or needs to increase because of entanglement growth throughout the course of a simulation. <a href="#changebonds"><code>changebonds</code></a> exposes a way to change the bond dimension of a given state.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.changebonds-man-algorithms" href="#MPSKit.changebonds-man-algorithms"><code>MPSKit.changebonds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">changebonds(ψ::AbstractMPS, H, alg, envs) -&gt; ψ′, envs′
changebonds(ψ::AbstractMPS, alg) -&gt; ψ′</code></pre><p>Change the bond dimension of <code>ψ</code> using the algorithm <code>alg</code>, and return the new <code>ψ</code> and the new <code>envs</code>.</p><p>See also: <a href="../../lib/lib/#MPSKit.SvdCut"><code>SvdCut</code></a>, <a href="../../lib/lib/#MPSKit.RandExpand"><code>RandExpand</code></a>, <a href="../../lib/lib/#MPSKit.VUMPSSvdCut"><code>VUMPSSvdCut</code></a>, <a href="../../lib/lib/#MPSKit.OptimalExpand"><code>OptimalExpand</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/changebonds/changebonds.jl#L1-L8">source</a></section></article><p>There are several different algorithms implemented, each having their own advantages and disadvantages:</p><ul><li><a href="../../lib/lib/#MPSKit.SvdCut"><code>SvdCut</code></a>: The simplest method for changing the bonddimension is found by simply locally truncating the state using an SVD decomposition. This yields a (locally) optimal truncation, but clearly cannot be used to increase the bond dimension. Note that a globally optimal truncation can be obtained by using the <a href="../../lib/lib/#MPSKit.SvdCut"><code>SvdCut</code></a> algorithm in combination with <a href="#approximate"><code>approximate</code></a>. Since the output of this method might have a truncated bonddimension, the new state might not be identical to the input state. The truncation is controlled through <code>trscheme</code>, which dictates how the singular values of the original state are truncated.</li></ul><ul><li><p><a href="../../lib/lib/#MPSKit.OptimalExpand"><code>OptimalExpand</code></a>: This algorithm is based on the idea of expanding the bond dimension by investigating the two-site derivative, and adding the most important blocks which are orthogonal to the current state. From the point of view of a local two-site update, this procedure is <em>optimal</em>, but it requires to evaluate a two-site derivative, which can be costly when the physical space is large. The state will remain unchanged, but a one-site scheme will now be able to push the optimization further. The subspace used for expansion can be truncated through <code>trscheme</code>, which dictates how many singular values will be added.</p></li><li><p><a href="../../lib/lib/#MPSKit.RandExpand"><code>RandExpand</code></a>: This algorithm similarly adds blocks orthogonal to the current state, but does not attempt to select the most important ones, and rather just selects them at random. The advantage here is that this is much cheaper than the optimal expand, and if the bond dimension is grown slow enough, this still obtains a very good expansion scheme. Again, The state will remain unchanged and a one-site scheme will now be able to  push the optimization further. The subspace used for expansion can be truncated through <code>trscheme</code>, which dictates how many singular values will be added.</p></li><li><p><a href="../../lib/lib/#MPSKit.VUMPSSvdCut"><code>VUMPSSvdCut</code></a>: This algorithm is based on the <a href="#VUMPS"><code>VUMPS</code></a> algorithm, and consists of performing a two-site update, and then truncating the state back down. Because of the two-site update, this can again become expensive, but the algorithm has the option of both expanding as well as truncating the bond dimension. Here, <code>trscheme</code> controls the truncation of the full state after the two-site update.</p></li></ul><h2 id="Leading-boundary"><a class="docs-heading-anchor" href="#Leading-boundary">Leading boundary</a><a id="Leading-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Leading-boundary" title="Permalink"></a></h2><p>For statistical mechanics partition functions we want to find the approximate leading boundary MPS. Again this can be done with VUMPS:</p><pre><code class="language-julia hljs">th = nonsym_ising_mpo()
ts = InfiniteMPS([ℂ^2],[ℂ^20]);
(ts,envs,_) = leading_boundary(ts,th,VUMPS(maxiter=400,verbosity=false));</code></pre><p>If the mpo satisfies certain properties (positive and hermitian), it may also be possible to use GradientGrassmann.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.leading_boundary-man-algorithms" href="#MPSKit.leading_boundary-man-algorithms"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leading_boundary(ψ₀, O, [environments]; kwargs...) -&gt; (ψ, environments, ϵ)
leading_boundary(ψ₀, O, algorithm, environments) -&gt; (ψ, environments, ϵ)</code></pre><p>Compute the leading boundary MPS for operator <code>O</code> with initial guess <code>ψ</code>. If not specified, an optimization algorithm will be attempted based on the supplied keywords.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess</li><li><code>O::AbstractMPO</code>: operator for which to find the leading_boundary</li><li><code>[environments]</code>: MPS environment manager</li><li><code>algorithm</code>: optimization algorithm</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>ψ::AbstractMPS</code>: converged leading boundary MPS</li><li><code>environments</code>: environments corresponding to the converged boundary</li><li><code>ϵ::Float64</code>: final convergence error upon terminating the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/statmech/leading_boundary.jl#L1-L23">source</a></section></article><h2 id="approximate"><a class="docs-heading-anchor" href="#approximate"><code>approximate</code></a><a id="approximate-1"></a><a class="docs-heading-anchor-permalink" href="#approximate" title="Permalink"></a></h2><p>Often, it is useful to approximate a given MPS by another, typically by one of a different bond dimension. This is achieved by approximating an application of an MPO to the initial state, by a new state.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.approximate-man-algorithms" href="#MPSKit.approximate-man-algorithms"><code>MPSKit.approximate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approximate(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)
approximate!(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)</code></pre><p>Compute an approximation to the application of an operator <code>O</code> to the state <code>ψ</code> in the form of an MPS <code>ψ₀</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess of the approximated state</li><li><code>(O::AbstractMPO, ψ::AbstractMPS)</code>: operator <code>O</code> and state <code>ψ</code> to be approximated</li><li><code>algorithm</code>: approximation algorithm. See below for a list of available algorithms.</li><li><code>[environments]</code>: MPS environment manager</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Algorithms</strong></p><ul><li><p><code>DMRG</code>: Alternating least square method for maximizing the fidelity with a single-site scheme.</p></li><li><p><code>DMRG2</code>: Alternating least square method for maximizing the fidelity with a two-site scheme.</p></li><li><p><code>IDMRG</code>: Variant of <code>DMRG</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>IDMRG2</code>: Variant of <code>DMRG2</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>VOMPS</code>: Tangent space method for truncating uniform MPS.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/approximate/approximate.jl#L1-L26">source</a></section></article><h2 id="Varia"><a class="docs-heading-anchor" href="#Varia">Varia</a><a id="Varia-1"></a><a class="docs-heading-anchor-permalink" href="#Varia" title="Permalink"></a></h2><p>What follows is a medley of lesser known (or used) algorithms and don&#39;t entirely fit under one of the above categories.</p><h3 id="Dynamical-DMRG"><a class="docs-heading-anchor" href="#Dynamical-DMRG">Dynamical DMRG</a><a id="Dynamical-DMRG-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-DMRG" title="Permalink"></a></h3><p>Dynamical DMRG has been described in other papers and is a way to find the propagator. The basic idea is that to calculate <span>$G(z) = ⟨ V | (H-z)^{-1} | V ⟩$</span> , one can variationally find <span>$(H-z) |W ⟩ = | V ⟩$</span> and then the propagator simply equals <span>$G(z) = ⟨ V | W ⟩$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.propagator-man-algorithms" href="#MPSKit.propagator-man-algorithms"><code>MPSKit.propagator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagator(ψ₀::AbstractFiniteMPS, z::Number, H::MPOHamiltonian, alg::DynamicalDMRG; init=copy(ψ₀))</code></pre><p>Calculate the propagator <span>$\frac{1}{E₀ + z - H}|ψ₀⟩$</span> using the dynamical DMRG algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/propagator/corvector.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DynamicalDMRG-man-algorithms" href="#MPSKit.DynamicalDMRG-man-algorithms"><code>MPSKit.DynamicalDMRG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DynamicalDMRG{F&lt;:MPSKit.DDMRG_Flavour, S} &lt;: MPSKit.Algorithm</code></pre><p>A dynamical DMRG method for calculating dynamical properties and excited states, based on a variational principle for dynamical correlation functions.</p><p><strong>Fields</strong></p><ul><li><p><code>flavour::MPSKit.DDMRG_Flavour</code>: flavour of the algorithm to use, either of type <a href="../../lib/lib/#MPSKit.NaiveInvert"><code>NaiveInvert</code></a> or <a href="../../lib/lib/#MPSKit.Jeckelmann"><code>Jeckelmann</code></a></p></li><li><p><code>solver::Any</code>: algorithm used for the linear solvers</p></li><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#jeckelmann2002">Jeckelmann. Phys. Rev. B 66 (2002)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/propagator/corvector.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.NaiveInvert-man-algorithms" href="#MPSKit.NaiveInvert-man-algorithms"><code>MPSKit.NaiveInvert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NaiveInvert &lt;: MPSKit.DDMRG_Flavour</code></pre><p>An alternative approach to the dynamical DMRG algorithm, without quadratic terms but with a less controlled approximation. This algorithm minimizes the following cost function</p><p class="math-container">\[⟨ψ|(H - E)|ψ⟩ - ⟨ψ|ψ₀⟩ - ⟨ψ₀|ψ⟩\]</p><p>which is equivalent to the original approach if</p><p class="math-container">\[|ψ₀⟩ = (H - E)|ψ⟩\]</p><p>See also <a href="../../lib/lib/#MPSKit.Jeckelmann"><code>Jeckelmann</code></a> for the original approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/propagator/corvector.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.Jeckelmann-man-algorithms" href="#MPSKit.Jeckelmann-man-algorithms"><code>MPSKit.Jeckelmann</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Jeckelmann &lt;: MPSKit.DDMRG_Flavour</code></pre><p>The original flavour of dynamical DMRG, which minimizes the following (quadratic) cost function:</p><p class="math-container">\[|| (H - E) |ψ₀⟩ - |ψ⟩ ||\]</p><p>See also <a href="../../lib/lib/#MPSKit.NaiveInvert"><code>NaiveInvert</code></a> for a less costly but less accurate alternative.</p><p><strong>References</strong></p><ul><li><a href="../../references/#jeckelmann2002">Jeckelmann. Phys. Rev. B 66 (2002)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/propagator/corvector.jl#L105">source</a></section></article><h3 id="fidelity-susceptibility"><a class="docs-heading-anchor" href="#fidelity-susceptibility">fidelity susceptibility</a><a id="fidelity-susceptibility-1"></a><a class="docs-heading-anchor-permalink" href="#fidelity-susceptibility" title="Permalink"></a></h3><p>The fidelity susceptibility measures how much the groundstate changes when tuning a parameter in your hamiltonian. Divergences occur at phase transitions, making it a valuable measure when no order parameter is known.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.fidelity_susceptibility-man-algorithms" href="#MPSKit.fidelity_susceptibility-man-algorithms"><code>MPSKit.fidelity_susceptibility</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fidelity_susceptibility(state::Union{FiniteMPS,InfiniteMPS}, H₀::T,
                        Vs::AbstractVector{T}, [henvs=environments(state, H₀)];
                        maxiter=Defaults.maxiter,
                        tol=Defaults.tol) where {T&lt;:MPOHamiltonian}</code></pre><p>Computes the fidelity susceptibility of a the ground state <code>state</code> of a base Hamiltonian <code>H₀</code> with respect to a set of perturbing Hamiltonians <code>Vs</code>. Each of the perturbing Hamiltonians can be interpreted as corresponding to a tuning parameter <span>$aᵢ$</span> in a &#39;total&#39; Hamiltonian <span>$H = H₀ + ∑ᵢ aᵢ Vᵢ$</span>.</p><p>Returns a matrix containing the overlaps of the elementary excitations on top of <code>state</code> corresponding to each of the perturbing Hamiltonians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/fidelity_susceptibility.jl#L1-L14">source</a></section></article><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>You can impose periodic or open boundary conditions on an infinite Hamiltonian, to generate a finite counterpart. In particular, for periodic boundary conditions we still return an MPO that does not form a closed loop, such that it can be used with regular matrix product states. This is straightforward to implement but, and while this effectively squares the bond dimension, it is still competitive with more advanced periodic MPS algorithms.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.open_boundary_conditions-man-algorithms" href="#MPSKit.open_boundary_conditions-man-algorithms"><code>MPSKit.open_boundary_conditions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_boundary_conditions(mpo::InfiniteMPO, L::Int) -&gt; FiniteMPO</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by applying open boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/toolbox.jl#L435-L439">source</a></section><section><div><pre><code class="language-julia hljs">open_boundary_conditions(mpo::InfiniteMPOHamiltonian, L::Int) -&gt; FiniteMPOHamiltonian</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by applying open boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/toolbox.jl#L455-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.periodic_boundary_conditions-man-algorithms" href="#MPSKit.periodic_boundary_conditions-man-algorithms"><code>MPSKit.periodic_boundary_conditions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodic_boundary_conditions(mpo::AbstractInfiniteMPO, L::Int)</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by mapping periodic boundary conditions onto an open system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/toolbox.jl#L265-L269">source</a></section></article><h3 id="Exact-diagonalization"><a class="docs-heading-anchor" href="#Exact-diagonalization">Exact diagonalization</a><a id="Exact-diagonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-diagonalization" title="Permalink"></a></h3><p>As a side effect, our code support exact diagonalization. The idea is to construct a finite matrix product state with maximal bond dimension, and then optimize the middle site. Because we never truncated the bond dimension, this single site effectively parametrizes the entire hilbert space.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.exact_diagonalization-man-algorithms" href="#MPSKit.exact_diagonalization-man-algorithms"><code>MPSKit.exact_diagonalization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_diagonalization(H::FiniteMPOHamiltonian;
                      sector=first(sectors(oneunit(physicalspace(H, 1)))),
                      len::Int=length(H), num::Int=1, which::Symbol=:SR,
                      alg=Defaults.alg_eigsolve(; dynamic_tols=false))
                        -&gt; vals, state_vecs, convhist</code></pre><p>Use <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a> to perform exact diagonalization on a <code>FiniteMPOHamiltonian</code> to find its eigenvectors as <code>FiniteMPS</code> of maximal rank, essentially equivalent to dense eigenvectors.</p><p><strong>Arguments</strong></p><ul><li><code>H::FiniteMPOHamiltonian</code>: the Hamiltonian to diagonalize.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sector=first(sectors(oneunit(physicalspace(H, 1))))</code>: the total charge of the eigenvectors, which is chosen trivial by default.</li><li><code>len::Int=length(H)</code>: the length of the system.</li><li><code>num::Int=1</code>: the number of eigenvectors to find.</li><li><code>which::Symbol=:SR</code>: the kind eigenvalues to find, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a>. </li><li><code>alg=Defaults.alg_eigsolve(; dynamic_tols=false)</code>: the diagonalization algorithm to use, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a>.</li></ul><div class="admonition is-info" id="Valid-sector-values-ad1631d2fa8471f4"><header class="admonition-header">Valid `sector` values<a class="admonition-anchor" href="#Valid-sector-values-ad1631d2fa8471f4" title="Permalink"></a></header><div class="admonition-body"><p>The total charge of the eigenvectors is imposed by adding a charged auxiliary space as the leftmost virtualspace of each eigenvector. Specifically, this is achieved by passing <code>left=Vect[typeof(sector)](sector =&gt; 1)</code> to the <a href="../states/#FiniteMPS"><code>FiniteMPS</code></a> constructor. As such, the only valid <code>sector</code> values (i.e. <code>sector</code> values for which the corresponding eigenstates have valid fusion channels) are those that occur in the dual of the fusion of all the physical spaces in the system.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/440acdb19fb12b7b9e45b2b02ad865ab8adb66a1/src/algorithms/ED.jl#L1-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../parallelism/">Parallelism in julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 30 September 2025 11:23">Tuesday 30 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
