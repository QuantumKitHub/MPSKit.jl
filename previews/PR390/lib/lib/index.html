<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · MPSKit.jl</title><meta name="title" content="Library · MPSKit.jl"/><meta property="og:title" content="Library · MPSKit.jl"/><meta property="twitter:title" content="Library · MPSKit.jl"/><meta name="description" content="Documentation for MPSKit.jl."/><meta property="og:description" content="Documentation for MPSKit.jl."/><meta property="twitter:description" content="Documentation for MPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Prerequisites</a></li><li><a class="tocitem" href="../../man/states/">States</a></li><li><a class="tocitem" href="../../man/operators/">Operators</a></li><li><a class="tocitem" href="../../man/algorithms/">Algorithms</a></li><li><a class="tocitem" href="../../man/parallelism/">Parallelism in julia</a></li><li><a class="tocitem" href="../../man/lattices/">Lattices</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Library</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/main/docs/src/lib/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-documentation"><a class="docs-heading-anchor" href="#Library-documentation">Library documentation</a><a id="Library-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-documentation" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="MPSKit.WI"><a class="docstring-binding" href="#MPSKit.WI"><code>MPSKit.WI</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const WI = TaylorCluster(; N=1, extension=false, compression=false)</code></pre><p>First order Taylor expansion for a time-evolution MPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/taylorcluster.jl#L23-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AbstractMPO"><a class="docstring-binding" href="#MPSKit.AbstractMPO"><code>MPSKit.AbstractMPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractMPO{O} &lt;: AbstractVector{O} end</code></pre><p>Abstract supertype for Matrix Product Operators (MPOs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/abstractmpo.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AbstractMPSEnvironments"><a class="docstring-binding" href="#MPSKit.AbstractMPSEnvironments"><code>MPSKit.AbstractMPSEnvironments</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractEnvironments end</code></pre><p>Abstract supertype for all environment types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/environments/abstract_envs.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.Algorithm"><a class="docstring-binding" href="#MPSKit.Algorithm"><code>MPSKit.Algorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Algorithm</code></pre><p>Abstract supertype for all algorithm structs. These can be thought of as <code>NamedTuple</code>s that hold the settings for a given algorithm, which can be used for dispatch. Additionally, the constructors can be used to provide default values and input sanitation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/algorithm.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.ChepigaAnsatz"><a class="docstring-binding" href="#MPSKit.ChepigaAnsatz"><code>MPSKit.ChepigaAnsatz</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ChepigaAnsatz{A&lt;:KrylovKit.KrylovAlgorithm} &lt;: MPSKit.Algorithm</code></pre><p>Single-site optimization algorithm for excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><code>alg::KrylovKit.KrylovAlgorithm</code>: algorithm used for the eigenvalue solvers</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ChepigaAnsatz()
ChepigaAnsatz(; kwargs...)
ChepigaAnsatz(alg)</code></pre><p>Create a <code>ChepigaAnsatz</code> algorithm with the given eigensolver, or by passing the keyword arguments to [<code>Arnoldi</code>][@extref KrylovKit.Arnoldi].</p><p><strong>References</strong></p><ul><li><a href="../../references/#chepiga2017">Chepiga et al. Phys. Rev. B 96 (2017)</a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/chepigaansatz.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.ChepigaAnsatz2"><a class="docstring-binding" href="#MPSKit.ChepigaAnsatz2"><code>MPSKit.ChepigaAnsatz2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ChepigaAnsatz2 &lt;: Algorithm</code></pre><p>Two-site optimization algorithm for excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><code>alg::A = Defaults.eigsolver</code>: algorithm to use for the eigenvalue problem.</li><li><code>trscheme = Defaults.trscheme</code>: algorithm to use for truncation.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ChepigaAnsatz2()
ChepigaAnsatz2(; kwargs...)
ChepigaAnsatz2(alg, trscheme)</code></pre><p>Create a <code>ChepigaAnsatz2</code> algorithm with the given eigensolver and truncation, or by passing the keyword arguments to <code>Arnoldi</code>.</p><p><strong>References</strong></p><ul><li><a href="../../references/#chepiga2017">Chepiga et al. Phys. Rev. B 96 (2017)</a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/chepigaansatz.jl#L66-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.DDMRG_Flavour"><a class="docstring-binding" href="#MPSKit.DDMRG_Flavour"><code>MPSKit.DDMRG_Flavour</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type DDMRG_Flavour</code></pre><p>Abstract supertype for the different flavours of dynamical DMRG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/propagator/corvector.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.DMRG"><a class="docstring-binding" href="#MPSKit.DMRG"><code>MPSKit.DMRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DMRG{A, F} &lt;: MPSKit.Algorithm</code></pre><p>Single-site DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/dmrg.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.DMRG2"><a class="docstring-binding" href="#MPSKit.DMRG2"><code>MPSKit.DMRG2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DMRG2{A, S, F} &lt;: MPSKit.Algorithm</code></pre><p>Two-site DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for <a href="https://quantumkithub.github.io/MatrixAlgebraKit.jl/stable/library/#MatrixAlgebraKit.TruncationStrategy">truncation</a> of the two-site update</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/dmrg.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.DerivativeOperator"><a class="docstring-binding" href="#MPSKit.DerivativeOperator"><code>MPSKit.DerivativeOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DerivativeOperator</code></pre><p>Abstract supertype for derivative operators acting on MPS. These operators are used to represent the effective local operators obtained from taking the partial derivative of an MPS-MPO-MPS sandwich.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L2-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.DynamicalDMRG"><a class="docstring-binding" href="#MPSKit.DynamicalDMRG"><code>MPSKit.DynamicalDMRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DynamicalDMRG{F&lt;:MPSKit.DDMRG_Flavour, S} &lt;: MPSKit.Algorithm</code></pre><p>A dynamical DMRG method for calculating dynamical properties and excited states, based on a variational principle for dynamical correlation functions.</p><p><strong>Fields</strong></p><ul><li><p><code>flavour::MPSKit.DDMRG_Flavour</code>: flavour of the algorithm to use, either of type <a href="#MPSKit.NaiveInvert"><code>NaiveInvert</code></a> or <a href="#MPSKit.Jeckelmann"><code>Jeckelmann</code></a></p></li><li><p><code>solver::Any</code>: algorithm used for the linear solvers</p></li><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#jeckelmann2002">Jeckelmann. Phys. Rev. B 66 (2002)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/propagator/corvector.jl#L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.FiniteChainStyle"><a class="docstring-binding" href="#MPSKit.FiniteChainStyle"><code>MPSKit.FiniteChainStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type GeometryStyle
GeometryStyle(x)
GeometryStyle(::Type{T})</code></pre><p>Trait to describe the geometry of the input <code>x</code> or type <code>T</code>, which can be either</p><ul><li><code>FiniteChainStyle()</code>: object is defined on a finite chain;</li><li><code>InfiniteChainStyle()</code>: object is defined on an infinite chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/styles.jl#L26-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.FiniteEnvironments"><a class="docstring-binding" href="#MPSKit.FiniteEnvironments"><code>MPSKit.FiniteEnvironments</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteEnvironments &lt;: AbstractMPSEnvironments</code></pre><p>Environment manager for <code>FiniteMPS</code> and <code>WindowMPS</code>. This structure is responsible for automatically checking if the queried environment is still correctly cached and if not recalculates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/environments/finite_envs.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.FiniteExcited"><a class="docstring-binding" href="#MPSKit.FiniteExcited"><code>MPSKit.FiniteExcited</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteExcited{A} &lt;: MPSKit.Algorithm</code></pre><p>Variational optimization algorithm for excitations of finite MPS by minimizing the energy of</p><p class="math-container">\[H - λᵢ |ψᵢ⟩⟨ψᵢ|\]</p><p><strong>Fields</strong></p><ul><li><p><code>gsalg::Any</code>: optimization algorithm</p></li><li><p><code>weight::Float64</code>: energy penalty for enforcing orthogonality with previous states</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/dmrgexcitation.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.FiniteMPO"><a class="docstring-binding" href="#MPSKit.FiniteMPO"><code>MPSKit.FiniteMPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FiniteMPO(Os::Vector{O}) -&gt; FiniteMPO{O}
FiniteMPO(O::AbstractTensorMap{S,N,N}) where {S,N} -&gt; FiniteMPO{O&lt;:MPOTensor}</code></pre><p>Matrix Product Operator (MPO) acting on a finite tensor product space with a linear order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L12-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.FiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}"><a class="docstring-binding" href="#MPSKit.FiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}"><code>MPSKit.FiniteMPOHamiltonian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FiniteMPOHamiltonian(Ws::Vector{&lt;:Matrix})</code></pre><p>Create a <code>FiniteMPOHamiltonian</code> from a vector of matrices, such that <code>Ws[i][j, k]</code> represents the operator at site <code>i</code>, left level <code>j</code> and right level <code>k</code>. Here, the entries can be either <code>MPOTensor</code>, <code>Missing</code> or <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpohamiltonian.jl#L60-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.FiniteMPS"><a class="docstring-binding" href="#MPSKit.FiniteMPS"><code>MPSKit.FiniteMPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FiniteMPS{A&lt;:GenericMPSTensor,B&lt;:MPSBondTensor} &lt;: AbstractFiniteMPS</code></pre><p>Type that represents a finite Matrix Product State.</p><p><strong>Properties</strong></p><ul><li><code>AL</code> – left-gauged MPS tensors</li><li><code>AR</code> – right-gauged MPS tensors</li><li><code>AC</code> – center-gauged MPS tensors</li><li><code>C</code> – gauge tensors</li><li><code>center</code> – location of the gauge center</li></ul><p>The center property returns <code>center::HalfInt</code> that indicates the location of the MPS center:</p><ul><li><code>isinteger(center)</code> → <code>center</code> is a whole number and indicates the location of the first <code>AC</code> tensor present in the underlying <code>ψ.ACs</code> field.</li><li><code>ishalfodd(center)</code> → <code>center</code> is a half-odd-integer, meaning that there are no <code>AC</code> tensors, and indicating between which sites the bond tensor lives.</li></ul><p>e.g <code>mps.center = 7/2</code> means that the bond tensor is to the right of the 3rd site and can be accessed via <code>mps.C[3]</code>.</p><p><strong>Notes</strong></p><p>By convention, we have that:</p><ul><li><code>AL[i] * C[i]</code> = <code>AC[i]</code> = <code>C[i-1] * AR[i]</code></li><li><code>AL[i]&#39; * AL[i] = 1</code></li><li><code>AR[i] * AR[i]&#39; = 1</code></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FiniteMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S,CompositeSpace{S}}},
          maxvirtualspaces::Union{S,Vector{S}};
          normalize=true, left=unitspace(S), right=unitspace(S)) where {S&lt;:ElementarySpace}
FiniteMPS([f, eltype], N::Int, physicalspace::Union{S,CompositeSpace{S}},
          maxvirtualspaces::Union{S,Vector{S}};
          normalize=true, left=unitspace(S), right=unitspace(S)) where {S&lt;:ElementarySpace}
FiniteMPS(As::Vector{&lt;:GenericMPSTensor}; normalize=false, overwrite=false)</code></pre><p>Construct an MPS via a specification of physical and virtual spaces, or from a list of tensors <code>As</code>. All cases reduce to the latter. In particular, a state with a non-trivial total charge can be constructed by passing a non-trivially charged vector space as the <code>left</code> or <code>right</code> virtual spaces.</p><p><strong>Arguments</strong></p><ul><li><p><code>As::Vector{&lt;:GenericMPSTensor}</code>: vector of site tensors</p></li><li><p><code>f::Function=rand</code>: initializer function for tensor data</p></li><li><p><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</p></li><li><p><code>physicalspaces::Vector{&lt;:Union{S, CompositeSpace{S}}</code>: list of physical spaces</p></li><li><p><code>N::Int</code>: number of sites</p></li><li><p><code>physicalspace::Union{S,CompositeSpace{S}}</code>: local physical space</p></li><li><p><code>virtualspaces::Vector{&lt;:Union{S, CompositeSpace{S}}</code>: list of virtual spaces</p></li><li><p><code>maxvirtualspace::S</code>: maximum virtual space</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>normalize=true</code>: normalize the constructed state</li><li><code>overwrite=false</code>: overwrite the given input tensors</li><li><code>left=unitspace(S)</code>: left-most virtual space</li><li><code>right=unitspace(S)</code>: right-most virtual space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/finitemps.jl#L1-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.GeometryStyle"><a class="docstring-binding" href="#MPSKit.GeometryStyle"><code>MPSKit.GeometryStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type GeometryStyle
GeometryStyle(x)
GeometryStyle(::Type{T})</code></pre><p>Trait to describe the geometry of the input <code>x</code> or type <code>T</code>, which can be either</p><ul><li><code>FiniteChainStyle()</code>: object is defined on a finite chain;</li><li><code>InfiniteChainStyle()</code>: object is defined on an infinite chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/styles.jl#L26-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.GradientGrassmann"><a class="docstring-binding" href="#MPSKit.GradientGrassmann"><code>MPSKit.GradientGrassmann</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct GradientGrassmann{O&lt;:OptimKit.OptimizationAlgorithm, F} &lt;: MPSKit.Algorithm</code></pre><p>Variational gradient-based optimization algorithm that keeps the MPS in left-canonical form, as points on a Grassmann manifold. The optimization is then a Riemannian gradient descent  with a preconditioner to induce the metric from the Hilbert space inner product.</p><p><strong>Fields</strong></p><ul><li><p><code>method::OptimKit.OptimizationAlgorithm</code>: optimization algorithm</p></li><li><p><code>finalize!::Any</code>: callback function applied after each iteration, of signature <code>finalize!(x, f, g, numiter) -&gt; x, f, g</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#hauru2021">Hauru et al. SciPost Phys. 10 (2021)</a></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">GradientGrassmann(; kwargs...)</code></pre><p><strong>Keywords</strong></p><ul><li><code>method=ConjugateGradient</code>: instance of optimization algorithm, or type of optimization   algorithm to construct</li><li><code>finalize!</code>: finalizer algorithm</li><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: level of information display</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/gradient_grassmann.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.HamiltonianStyle"><a class="docstring-binding" href="#MPSKit.HamiltonianStyle"><code>MPSKit.HamiltonianStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type OperatorStyle
OperatorStyle(x)
OperatorStyle(::Type{T})</code></pre><p>Trait to describe the operator behavior of the input <code>x</code> or type <code>T</code>, which can be either</p><ul><li><code>MPOStyle()</code>: product of local factors;</li><li><code>HamiltonianStyle()</code>: sum of local terms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/styles.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.IDMRG"><a class="docstring-binding" href="#MPSKit.IDMRG"><code>MPSKit.IDMRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IDMRG{A} &lt;: MPSKit.Algorithm</code></pre><p>Single site infinite DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the MPS</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/idmrg.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.IDMRG2"><a class="docstring-binding" href="#MPSKit.IDMRG2"><code>MPSKit.IDMRG2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IDMRG2{A, S} &lt;: MPSKit.Algorithm</code></pre><p>Two-site infinite DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the MPS</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for <a href="https://quantumkithub.github.io/MatrixAlgebraKit.jl/stable/library/#MatrixAlgebraKit.TruncationStrategy">truncation</a> of the two-site update</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/idmrg.jl#L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.InfiniteChainStyle"><a class="docstring-binding" href="#MPSKit.InfiniteChainStyle"><code>MPSKit.InfiniteChainStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type GeometryStyle
GeometryStyle(x)
GeometryStyle(::Type{T})</code></pre><p>Trait to describe the geometry of the input <code>x</code> or type <code>T</code>, which can be either</p><ul><li><code>FiniteChainStyle()</code>: object is defined on a finite chain;</li><li><code>InfiniteChainStyle()</code>: object is defined on an infinite chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/styles.jl#L26-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.InfiniteEnvironments"><a class="docstring-binding" href="#MPSKit.InfiniteEnvironments"><code>MPSKit.InfiniteEnvironments</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InfiniteEnvironments &lt;: AbstractMPSEnvironments</code></pre><p>Environments for an infinite MPS-MPO-MPS combination. These solve the corresponding fixedpoint equations:</p><p class="math-container">\[GLs[i] * T_LL[i] = λ GLs[i + 1]
T_RR[i] * GRs[i] = λ GRs[i - 1]\]</p><p>where <code>T_LL</code> and <code>T_RR</code> are the (regularized) transfer matrix operators on a give site for <code>AL-O-AL</code> and <code>AR-O-AR</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/environments/infinite_envs.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.InfiniteMPO"><a class="docstring-binding" href="#MPSKit.InfiniteMPO"><code>MPSKit.InfiniteMPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InfiniteMPO(Os::PeriodicVector{O}) -&gt; InfiniteMPO{O}</code></pre><p>Matrix Product Operator (MPO) acting on an infinite tensor product space with a linear order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L35-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.InfiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}"><a class="docstring-binding" href="#MPSKit.InfiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}"><code>MPSKit.InfiniteMPOHamiltonian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfiniteMPOHamiltonian(Ws::Vector{&lt;:Matrix})</code></pre><p>Create a <code>InfiniteMPOHamiltonian</code> from a vector of matrices, such that <code>Ws[i][j, k]</code> represents the the operator at site <code>i</code>, left level <code>j</code> and right level <code>k</code>. Here, the entries can be either <code>MPOTensor</code>, <code>Missing</code> or <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpohamiltonian.jl#L152-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.InfiniteMPS"><a class="docstring-binding" href="#MPSKit.InfiniteMPS"><code>MPSKit.InfiniteMPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InfiniteMPS{A&lt;:GenericMPSTensor,B&lt;:MPSBondTensor} &lt;: AbtractMPS</code></pre><p>Type that represents an infinite Matrix Product State.</p><p><strong>Fields</strong></p><ul><li><code>AL</code> – left-gauged MPS tensors</li><li><code>AR</code> – right-gauged MPS tensors</li><li><code>AC</code> – center-gauged MPS tensors</li><li><code>C</code> – gauge tensors</li></ul><p><strong>Notes</strong></p><p>By convention, we have that:</p><ul><li><code>AL[i] * C[i]</code> = <code>AC[i]</code> = <code>C[i-1] * AR[i]</code></li><li><code>AL[i]&#39; * AL[i] = 1</code></li><li><code>AR[i] * AR[i]&#39; = 1</code></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">InfiniteMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S, CompositeSpace{S}},
            virtualspaces::Vector{&lt;:Union{S, CompositeSpace{S}};
            kwargs...) where {S&lt;:ElementarySpace}
InfiniteMPS(As::AbstractVector{&lt;:GenericMPSTensor}; kwargs...)
InfiniteMPS(ALs::AbstractVector{&lt;:GenericMPSTensor}, C₀::MPSBondTensor;
            kwargs...)</code></pre><p>Construct an MPS via a specification of physical and virtual spaces, or from a list of tensors <code>As</code>, or a list of left-gauged tensors <code>ALs</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>As::AbstractVector{&lt;:GenericMPSTensor}</code>: vector of site tensors</p></li><li><p><code>ALs::AbstractVector{&lt;:GenericMPSTensor}</code>: vector of left-gauged site tensors</p></li><li><p><code>C₀::MPSBondTensor</code>: initial gauge tensor</p></li><li><p><code>f::Function=rand</code>: initializer function for tensor data</p></li><li><p><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</p></li><li><p><code>physicalspaces::AbstractVector{&lt;:Union{S, CompositeSpace{S}}</code>: list of physical spaces</p></li><li><p><code>virtualspaces::AbstractVector{&lt;:Union{S, CompositeSpace{S}}</code>: list of virtual spaces</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>tol</code>: gauge fixing tolerance</li><li><code>maxiter</code>: gauge fixing maximum iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L1-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.InfiniteQPEnvironments"><a class="docstring-binding" href="#MPSKit.InfiniteQPEnvironments"><code>MPSKit.InfiniteQPEnvironments</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InfiniteQPEnvironments &lt;: AbstractMPSEnvironments</code></pre><p>Environments for an infinite QP-MPO-QP combination. These solve the corresponding fixedpoint equations:</p><p class="math-container">\[GLs[i] * T_BL[i] + GBLs[i] * T_RL[i] = GBLs[i + 1]
T_BR[i] * GRs[i] + T_LR[i] * GBRs[i] = GBRs[i - 1]\]</p><p>where <code>T_BL</code>, <code>T_BR</code>, <code>T_RL</code> and <code>T_LR</code> are the (regularized) transfer matrix operators on a given site for <code>B-O-AL</code>, <code>B-O-AR</code>, <code>AR-O-AL</code> and <code>AL-O-AR</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/environments/qp_envs.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.Jeckelmann"><a class="docstring-binding" href="#MPSKit.Jeckelmann"><code>MPSKit.Jeckelmann</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Jeckelmann &lt;: MPSKit.DDMRG_Flavour</code></pre><p>The original flavour of dynamical DMRG, which minimizes the following (quadratic) cost function:</p><p class="math-container">\[|| (H - E) |ψ₀⟩ - |ψ⟩ ||\]</p><p>See also <a href="#MPSKit.NaiveInvert"><code>NaiveInvert</code></a> for a less costly but less accurate alternative.</p><p><strong>References</strong></p><ul><li><a href="../../references/#jeckelmann2002">Jeckelmann. Phys. Rev. B 66 (2002)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/propagator/corvector.jl#L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.JordanMPOTensor"><a class="docstring-binding" href="#MPSKit.JordanMPOTensor"><code>MPSKit.JordanMPOTensor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JordanMPOTensor{E,S,TA,TB,TC,TD} &lt;: AbstractBlockTensorMap{E,S,2,2}</code></pre><p>A tensor map that represents the upper triangular block form of a matrix product operator (MPO).</p><p class="math-container">\[\begin{pmatrix}
1 &amp; C &amp; D \\
0 &amp; A &amp; B \\
0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/jordanmpotensor.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.JordanMPO_AC2_Hamiltonian"><a class="docstring-binding" href="#MPSKit.JordanMPO_AC2_Hamiltonian"><code>MPSKit.JordanMPO_AC2_Hamiltonian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JordanMPO_AC2_Hamiltonian{O1,O2,O3,O4}</code></pre><p>Efficient operator for representing the single-site derivative of a <code>MPOHamiltonian</code> sandwiched between two MPSs. In particular, this operator aims to make maximal use of the structure of the <code>MPOHamiltonian</code> to reduce the number of operations required to apply the operator to a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/hamiltonian_derivatives.jl#L35-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.JordanMPO_AC_Hamiltonian"><a class="docstring-binding" href="#MPSKit.JordanMPO_AC_Hamiltonian"><code>MPSKit.JordanMPO_AC_Hamiltonian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JordanMPO_AC_Hamiltonian{O1,O2,O3}</code></pre><p>Efficient operator for representing the single-site derivative of a <code>MPOHamiltonian</code> sandwiched between two MPSs. In particular, this operator aims to make maximal use of the structure of the <code>MPOHamiltonian</code> to reduce the number of operations required to apply the operator to a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/hamiltonian_derivatives.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.LazySum"><a class="docstring-binding" href="#MPSKit.LazySum"><code>MPSKit.LazySum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LazySum{O} &lt;: AbstractVector{O}</code></pre><p>Type that represents a lazy sum i.e explicit summation is only done when needed.  This type is basically an <code>AbstractVector</code> with some extra functionality to calculate things efficiently.</p><p><strong>Fields</strong></p><ul><li>ops – Vector of summable objects</li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LazySum(x::Vector)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/lazysum.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.LeftCanonical"><a class="docstring-binding" href="#MPSKit.LeftCanonical"><code>MPSKit.LeftCanonical</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LeftCanonical &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for bringing an <code>InfiniteMPS</code> into the left-canonical form.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_orth::Any</code>: algorithm used for orthogonalization of the tensors</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigensolver</p></li><li><p><code>eig_miniter::Int64</code>: minimal amount of iterations before using the eigensolver steps</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/ortho.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPO"><a class="docstring-binding" href="#MPSKit.MPO"><code>MPSKit.MPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MPO{O,V&lt;:AbstractVector{O}} &lt;: AbstractMPO{O}</code></pre><p>Matrix Product Operator (MPO) acting on a tensor product space with a linear order.</p><p>See also: <a href="../../man/operators/#FiniteMPO"><code>FiniteMPO</code></a>, <a href="../../man/operators/#InfiniteMPO"><code>InfiniteMPO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPODerivativeOperator"><a class="docstring-binding" href="#MPSKit.MPODerivativeOperator"><code>MPSKit.MPODerivativeOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MPODerivativeOperator{L,O&lt;:Tuple,R}</code></pre><p>Effective local operator obtained from taking the partial derivative of an MPS-MPO-MPS sandwich.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/mpo_derivatives.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPOHamiltonian"><a class="docstring-binding" href="#MPSKit.MPOHamiltonian"><code>MPSKit.MPOHamiltonian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MPOHamiltonian(lattice::AbstractArray{&lt;:VectorSpace}, local_operators...)
MPOHamiltonian(lattice::AbstractArray{&lt;:VectorSpace})
MPOHamiltonian(x::AbstractArray{&lt;:Any,3})</code></pre><p>MPO representation of a Hamiltonian. This is a specific form of an <a href="#MPSKit.AbstractMPO"><code>AbstractMPO</code></a>, where all the sites are represented by an upper triangular block matrix of the following form:</p><p class="math-container">\[\begin{pmatrix}
1 &amp; C &amp; D \\
0 &amp; A &amp; B \\
0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p>where <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> are <code>MPOTensor</code>s, or (sparse) blocks thereof.</p><p><strong>Examples</strong></p><p>For example, constructing a nearest-neighbour Hamiltonian would look like this:</p><pre><code class="language-julia hljs">lattice = fill(ℂ^2, 10)
H = MPOHamiltonian(lattice, (i, i+1) =&gt; O for i in 1:length(lattice)-1)</code></pre><p>See also <a href="#MPSKit.instantiate_operator-Tuple{MPSKit.AbstractMPS, Pair}"><code>instantiate_operator</code></a>, which is responsable for instantiating the local operators in a form that is compatible with this constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpohamiltonian.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPOStyle"><a class="docstring-binding" href="#MPSKit.MPOStyle"><code>MPSKit.MPOStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type OperatorStyle
OperatorStyle(x)
OperatorStyle(::Type{T})</code></pre><p>Trait to describe the operator behavior of the input <code>x</code> or type <code>T</code>, which can be either</p><ul><li><code>MPOStyle()</code>: product of local factors;</li><li><code>HamiltonianStyle()</code>: sum of local terms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/styles.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPOTensor"><a class="docstring-binding" href="#MPSKit.MPOTensor"><code>MPSKit.MPOTensor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MPOTensor{S}</code></pre><p>Tensor type for representing local MPO tensors, with the index convention <code>W ⊗ S ← N ⊗ E</code>, where <code>N</code>, <code>E</code>, <code>S</code> and <code>W</code> denote the north, east, south and west virtual spaces respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L5-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPSTensor"><a class="docstring-binding" href="#MPSKit.MPSTensor"><code>MPSKit.MPSTensor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MPSTensor([f, eltype], d::Int, Dₗ::Int, [Dᵣ]::Int])</code></pre><p>Construct an <code>MPSTensor</code> with given physical and virtual dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function=rand</code>: initializer function for tensor data</li><li><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</li><li><code>d::Int</code>: physical dimension</li><li><code>Dₗ::Int</code>: left virtual dimension</li><li><code>Dᵣ::Int</code>: right virtual dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L61-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPSTensor-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number"><a class="docstring-binding" href="#MPSKit.MPSTensor-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number"><code>MPSKit.MPSTensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MPSTensor(A::AbstractArray)</code></pre><p>Convert an array to an <code>MPSTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MPSTensor-Union{Tuple{S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S, S}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#MPSKit.MPSTensor-Union{Tuple{S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>MPSKit.MPSTensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MPSTensor([f, eltype], d::Int, left_D::Int, [right_D]::Int])
MPSTensor([f, eltype], physicalspace::Union{S,CompositeSpace{S}}, 
          left_virtualspace::S, [right_virtualspace]::S) where {S&lt;:ElementarySpace}</code></pre><p>Construct an <code>MPSTensor</code> with given physical and virtual spaces.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function=rand</code>: initializer function for tensor data</p></li><li><p><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</p></li><li><p><code>physicalspace::Union{S,CompositeSpace{S}}</code>: physical space</p></li><li><p><code>left_virtualspace::S</code>: left virtual space</p></li><li><p><code>right_virtualspace::S</code>: right virtual space, defaults to equal left</p></li><li><p><code>d::Int</code>: physical dimension</p></li><li><p><code>left_D::Int</code>: left virtual dimension</p></li><li><p><code>right_D::Int</code>: right virtual dimension</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L16-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MixedCanonical"><a class="docstring-binding" href="#MPSKit.MixedCanonical"><code>MPSKit.MixedCanonical</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MixedCanonical &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for bringing an <code>InfiniteMPS</code> into the mixed-canonical form.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_leftcanonical::MPSKit.LeftCanonical</code>: algorithm for bringing an <code>InfiniteMPS</code> into left-canonical form.</p></li><li><p><code>alg_rightcanonical::MPSKit.RightCanonical</code>: algorithm for bringing an <code>InfiniteMPS</code> into right-canonical form.</p></li><li><p><code>order::Symbol</code>: order in which to apply the canonicalizations, should be <code>:L</code>, <code>:R</code>, <code>:LR</code> or <code>:RL</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/ortho.jl#L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.Multiline"><a class="docstring-binding" href="#MPSKit.Multiline"><code>MPSKit.Multiline</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Multiline{T}</code></pre><p>Object that represents multiple lines of objects of type <code>T</code>. Typically used to represent multiple lines of <code>InfiniteMPS</code> (<code>MultilineMPS</code>) or MPO (<code>Multiline{&lt;:AbstractMPO}</code>).</p><p><strong>Fields</strong></p><ul><li><code>data::PeriodicArray{T,1}</code>: the data of the multiline object</li></ul><p>See also: <a href="../../man/states/#MultilineMPS"><code>MultilineMPS</code></a> and <a href="#MPSKit.MultilineMPO"><code>MultilineMPO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/multiline.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MultilineMPO"><a class="docstring-binding" href="#MPSKit.MultilineMPO"><code>MPSKit.MultilineMPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const MultilineMPO = Multiline{&lt;:AbstractMPO}</code></pre><p>Type that represents multiple lines of <code>MPO</code> objects.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">MultilineMPO(mpos::AbstractVector{&lt;:Union{SparseMPO,DenseMPO}})
MultilineMPO(Os::AbstractMatrix{&lt;:MPOTensor})</code></pre><p>See also: <a href="#MPSKit.Multiline"><code>Multiline</code></a>, <a href="#MPSKit.AbstractMPO"><code>AbstractMPO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/multilinempo.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MultilineMPS"><a class="docstring-binding" href="#MPSKit.MultilineMPS"><code>MPSKit.MultilineMPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const MultilineMPS = Multiline{&lt;:InfiniteMPS}</code></pre><p>Type that represents multiple lines of <code>InfiniteMPS</code> objects.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">MultilineMPS(mpss::AbstractVector{&lt;:InfiniteMPS})
MultilineMPS([f, eltype], physicalspaces::Matrix{&lt;:Union{S, CompositeSpace{S}},
             virtualspaces::Matrix{&lt;:Union{S, CompositeSpace{S}}) where
             {S&lt;:ElementarySpace}
MultilineMPS(As::AbstractMatrix{&lt;:GenericMPSTensor}; kwargs...)
MultilineMPS(ALs::AbstractMatrix{&lt;:GenericMPSTensor},
             C₀::AbstractVector{&lt;:MPSBondTensor}; kwargs...)</code></pre><p>See also: <a href="#MPSKit.Multiline"><code>Multiline</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/multilinemps.jl#L5-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.MultipliedOperator"><a class="docstring-binding" href="#MPSKit.MultipliedOperator"><code>MPSKit.MultipliedOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Structure representing a multiplied operator. Consists of
    - An operator op (MPO, Hamiltonian, ...)
    - An object f that gets multiplied with the operator (Number, function, ...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/multipliedoperator.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.NaiveInvert"><a class="docstring-binding" href="#MPSKit.NaiveInvert"><code>MPSKit.NaiveInvert</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NaiveInvert &lt;: MPSKit.DDMRG_Flavour</code></pre><p>An alternative approach to the dynamical DMRG algorithm, without quadratic terms but with a less controlled approximation. This algorithm minimizes the following cost function</p><p class="math-container">\[⟨ψ|(H - E)|ψ⟩ - ⟨ψ|ψ₀⟩ - ⟨ψ₀|ψ⟩\]</p><p>which is equivalent to the original approach if</p><p class="math-container">\[|ψ₀⟩ = (H - E)|ψ⟩\]</p><p>See also <a href="#MPSKit.Jeckelmann"><code>Jeckelmann</code></a> for the original approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/propagator/corvector.jl#L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.OperatorStyle"><a class="docstring-binding" href="#MPSKit.OperatorStyle"><code>MPSKit.OperatorStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type OperatorStyle
OperatorStyle(x)
OperatorStyle(::Type{T})</code></pre><p>Trait to describe the operator behavior of the input <code>x</code> or type <code>T</code>, which can be either</p><ul><li><code>MPOStyle()</code>: product of local factors;</li><li><code>HamiltonianStyle()</code>: sum of local terms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/styles.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.OptimalExpand"><a class="docstring-binding" href="#MPSKit.OptimalExpand"><code>MPSKit.OptimalExpand</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct OptimalExpand{S} &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that expands the given mps as described in <a href="../../references/#zauner-stauber2018">Zauner-Stauber et al. Phys. Rev. B 97 (2018)</a>, by selecting the dominant contributions of a two-site updated MPS tensor, orthogonal to the original ψ.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for truncating the expanded space</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/changebonds/optimalexpand.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.PeriodicArray"><a class="docstring-binding" href="#MPSKit.PeriodicArray"><code>MPSKit.PeriodicArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PeriodicArray{T,N} &lt;: AbstractArray{T,N}</code></pre><p>Array wrapper with periodic boundary conditions.</p><p><strong>Fields</strong></p><ul><li><code>data::Array{T,N}</code>: the data of the array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = PeriodicArray([1, 2, 3])
A[0], A[2], A[4]

# output

(3, 2, 1)</code></pre><pre><code class="language-julia hljs">A = PeriodicArray([1 2; 3 4])
A[-1, 1], A[1, 1], A[4, 5]

# output

(1, 1, 3)</code></pre><p>See also <a href="#MPSKit.PeriodicVector"><code>PeriodicVector</code></a>, <a href="#MPSKit.PeriodicMatrix"><code>PeriodicMatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/periodicarray.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.PeriodicMatrix"><a class="docstring-binding" href="#MPSKit.PeriodicMatrix"><code>MPSKit.PeriodicMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PeriodicMatrix{T}</code></pre><p>Two-dimensional dense array with elements of type <code>T</code> and periodic boundary conditions. Alias for <a href="#MPSKit.PeriodicArray"><code>PeriodicArray{T,2}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/periodicarray.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.PeriodicVector"><a class="docstring-binding" href="#MPSKit.PeriodicVector"><code>MPSKit.PeriodicVector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PeriodicVector{T}</code></pre><p>One-dimensional dense array with elements of type <code>T</code> and periodic boundary conditions. Alias for <a href="#MPSKit.PeriodicArray"><code>PeriodicArray{T,1}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/periodicarray.jl#L41-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.QuasiparticleAnsatz"><a class="docstring-binding" href="#MPSKit.QuasiparticleAnsatz"><code>MPSKit.QuasiparticleAnsatz</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct QuasiparticleAnsatz{A, E} &lt;: MPSKit.Algorithm</code></pre><p>Optimization algorithm for quasi-particle excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><p><code>alg::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_environments::Any</code>: algorithm used for the quasiparticle environments</p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">QuasiparticleAnsatz()
QuasiparticleAnsatz(; kwargs...)
QuasiparticleAnsatz(alg)</code></pre><p>Create a <code>QuasiparticleAnsatz</code> algorithm with the given algorithm, or by passing the  keyword arguments to <code>Arnoldi</code>.</p><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2013">Haegeman et al. Phys. Rev. Let. 111 (2013)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/quasiparticleexcitation.jl#L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.RandExpand"><a class="docstring-binding" href="#MPSKit.RandExpand"><code>MPSKit.RandExpand</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RandExpand{S} &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that expands the bond dimension by adding random unitary vectors that are orthogonal to the existing state. This means that additional directions are added to <code>AL</code> and <code>AR</code> that are contained in the nullspace of both. Note that this is happens in parallel, and therefore the expansion will never go beyond the local two-site subspace.</p><p>The truncation strategy dictates the number of expanded states, by generating uniformly distributed weights for each state in the two-site space and truncating that.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for [truncation](@extref MatrixAlgebraKit.TruncationStrategy] the expanded space</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/changebonds/randexpand.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.RightCanonical"><a class="docstring-binding" href="#MPSKit.RightCanonical"><code>MPSKit.RightCanonical</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RightCanonical &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for bringing an <code>InfiniteMPS</code> into the right-canonical form.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_orth::Any</code>: algorithm used for orthogonalization of the tensors</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigensolver</p></li><li><p><code>eig_miniter::Int64</code>: minimal amount of iterations before using the eigensolver steps</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/ortho.jl#L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.SvdCut"><a class="docstring-binding" href="#MPSKit.SvdCut"><code>MPSKit.SvdCut</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SvdCut{S} &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that uses truncated SVD to change the bond dimension of a state or operator. This is achieved by a sweeping algorithm that locally performs (optimal) truncations in a gauged basis.</p><p>See also <a href="../../man/algorithms/#changebonds"><code>changebonds(!)</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for [truncation][@extref MatrixAlgebraKit.TruncationStrategy] of the gauge tensors</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#parker2020">Parker et al. Phys. Rev. B 102 (2020)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/changebonds/svdcut.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.TDVP"><a class="docstring-binding" href="#MPSKit.TDVP"><code>MPSKit.TDVP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TDVP{A, F} &lt;: MPSKit.Algorithm</code></pre><p>Single site MPS time-evolution algorithm based on the Time-Dependent Variational Principle.</p><p><strong>Fields</strong></p><ul><li><p><code>integrator::Any</code>: algorithm used in the exponential solvers</p></li><li><p><code>tolgauge::Float64</code>: tolerance for gauging algorithm</p></li><li><p><code>gaugemaxiter::Int64</code>: maximal amount of iterations for gauging algorithm</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2011">Haegeman et al. Phys. Rev. Lett. 107 (2011)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/tdvp.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.TDVP2"><a class="docstring-binding" href="#MPSKit.TDVP2"><code>MPSKit.TDVP2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TDVP2{A, S, F} &lt;: MPSKit.Algorithm</code></pre><p>Two-site MPS time-evolution algorithm based on the Time-Dependent Variational Principle.</p><p><strong>Fields</strong></p><ul><li><p><code>integrator::Any</code>: algorithm used in the exponential solvers</p></li><li><p><code>tolgauge::Float64</code>: tolerance for gauging algorithm</p></li><li><p><code>gaugemaxiter::Int64</code>: maximal amount of iterations for gauging algorithm</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for truncation of the two-site update</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2011">Haegeman et al. Phys. Rev. Lett. 107 (2011)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/tdvp.jl#L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.TaylorCluster"><a class="docstring-binding" href="#MPSKit.TaylorCluster"><code>MPSKit.TaylorCluster</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TaylorCluster &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for constructing the <code>N</code>th order time evolution MPO using the Taylor cluster expansion.</p><p><strong>Fields</strong></p><ul><li><p><code>N::Int64</code>: order of the Taylor expansion</p></li><li><p><code>extension::Bool</code>: include higher-order corrections</p></li><li><p><code>compression::Bool</code>: approximate compression of corrections, accurate up to order <code>N</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#vandamme2024">Van Damme et al. SciPost Phys. 17 (2024)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/taylorcluster.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.TimedOperator"><a class="docstring-binding" href="#MPSKit.TimedOperator"><code>MPSKit.TimedOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Structure representing a time-dependent operator. Consists of
    - An operator op (MPO, Hamiltonian, ...)
    - An function f that gives the time-dependence according to op(t) = f(t)*op</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/multipliedoperator.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.UnionAlg"><a class="docstring-binding" href="#MPSKit.UnionAlg"><code>MPSKit.UnionAlg</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct UnionAlg{A, B} &lt;: MPSKit.Algorithm</code></pre><p>Algorithm wrapper representing the sequential application of two algorithms.</p><p><strong>Fields</strong></p><ul><li><p><code>alg1::Any</code>: first algorithm</p></li><li><p><code>alg2::Any</code>: second algorithm</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/unionalg.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.UntimedOperator"><a class="docstring-binding" href="#MPSKit.UntimedOperator"><code>MPSKit.UntimedOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Structure representing a time-independent operator that will be multiplied with a constant coefficient. Consists of
    - An operator (MPO, Hamiltonian, ...)
    - A number f that gets multiplied with the operator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/multipliedoperator.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.VOMPS"><a class="docstring-binding" href="#MPSKit.VOMPS"><code>MPSKit.VOMPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VOMPS{F} &lt;: MPSKit.Algorithm</code></pre><p>Power method algorithm for finding dominant eigenvectors of infinite MPOs. This method works by iteratively approximating the product of an operator and a state with a new state of the same bond dimension.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_environments::Any</code>: algorithm used for the MPS environments</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#vanhecke2021">Vanhecke et al. SciPost Phys. Core 4 (2021)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/statmech/vomps.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.VUMPS"><a class="docstring-binding" href="#MPSKit.VUMPS"><code>MPSKit.VUMPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VUMPS{F} &lt;: MPSKit.Algorithm</code></pre><p>Variational optimization algorithm for uniform matrix product states, based on the combination of DMRG with matrix product state tangent space concepts.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_environments::Any</code>: algorithm used for the MPS environments</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#zauner-stauber2018">Zauner-Stauber et al. Phys. Rev. B 97 (2018)</a></li><li><a href="../../references/#vanderstraeten2019">Vanderstraeten et al. SciPost Phys. Lect. Notes 7 (2019)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/vumps.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.VUMPSSvdCut"><a class="docstring-binding" href="#MPSKit.VUMPSSvdCut"><code>MPSKit.VUMPSSvdCut</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VUMPSSvdCut &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that uses a two-site update step to change the bond dimension of a state.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::MatrixAlgebraKit.TruncationStrategy</code>: algorithm used for [truncation][@extref MatrixAlgebraKit.TruncationStrategy] of the two-site update</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/changebonds/vumpssvd.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.WII"><a class="docstring-binding" href="#MPSKit.WII"><code>MPSKit.WII</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct WII &lt;: MPSKit.Algorithm</code></pre><p>Generalization of the Euler approximation of the operator exponential for MPOs.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal number of iterations</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#zaletel2015">Zaletel et al. Phys. Rev. B 91 (2015)</a></li><li><a href="../../references/#paeckel2019">Paeckel et al. Ann. of Phys. 411 (2019)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/wii.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.WindowArray"><a class="docstring-binding" href="#MPSKit.WindowArray"><code>MPSKit.WindowArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindowArray{T} &lt;: AbstractVector{T}</code></pre><p>A vector embedded in a periodic environment to the left and right, which can be accessed with arbitrary integer indices. The <code>middle</code> part is a regular <code>Vector{T}</code> and the <code>left</code> and <code>right</code> parts are <code>PeriodicVector{T}</code>s.</p><p>This vector inherits most of its properties from the middle part, including its length and axes. Nevertheless, indexing operations are overloaded to allow for out-of-bounds access, which is resolved by the periodic enviroments.</p><p>See also <a href="#MPSKit.PeriodicVector"><code>PeriodicVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/windowarray.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.WindowMPS"><a class="docstring-binding" href="#MPSKit.WindowMPS"><code>MPSKit.WindowMPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindowMPS{A&lt;:GenericMPSTensor,B&lt;:MPSBondTensor} &lt;: AbstractFiniteMPS</code></pre><p>Type that represents a finite Matrix Product State embedded in an infinte Matrix Product State.</p><p><strong>Fields</strong></p><ul><li><code>left_gs::InfiniteMPS</code> – left infinite environment</li><li><code>window::FiniteMPS</code> – finite window Matrix Product State</li><li><code>right_gs::InfiniteMPS</code> – right infinite environment</li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">WindowMPS(left_gs::InfiniteMPS, window_state::FiniteMPS, [right_gs::InfiniteMPS])
WindowMPS(left_gs::InfiniteMPS, window_tensors::AbstractVector, [right_gs::InfiniteMPS])
WindowMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S, CompositeSpace{S}},
          virtualspaces::Vector{&lt;:Union{S, CompositeSpace{S}}, left_gs::InfiniteMPS,
          [right_gs::InfiniteMPS])
WindowMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S,CompositeSpace{S}}},
          maxvirtualspace::S, left_gs::InfiniteMPS, [right_gs::InfiniteMPS])</code></pre><p>Construct a WindowMPS via a specification of left and right infinite environment, and either a window state or a vector of tensors to construct the window. Alternatively, it is possible to supply the same arguments as for the constructor of <a href="../../man/states/#FiniteMPS"><code>FiniteMPS</code></a>, followed by a left (and right) environment to construct the WindowMPS in one step.</p><div class="admonition is-info" id="Note-4229e66851d0dcbf"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4229e66851d0dcbf" title="Permalink"></a></header><div class="admonition-body"><p>By default, the right environment is chosen to be equal to the left, however no copy is made. In this case, changing the left state will also affect the right state.</p><p>WindowMPS(state::InfiniteMPS, L::Int)</p></div></div><p>Construct a WindowMPS from an InfiniteMPS, by promoting a region of length <code>L</code> to a <code>FiniteMPS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/windowmps.jl#L1-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AC2"><a class="docstring-binding" href="#MPSKit.AC2"><code>MPSKit.AC2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AC2(ψ::AbstractMPS, i; kind=:ACAR)</code></pre><p>Obtain the two-site (center) gauge tensor at site <code>i</code> of the MPS <code>ψ</code>. If this hasn&#39;t been computed before, this can be computed as:</p><ul><li><code>kind=:ACAR</code> : AC[i] * AR[i+1]</li><li><code>kind=:ALAC</code> : AL[i] * AC[i+1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L158-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AC2_hamiltonian"><a class="docstring-binding" href="#MPSKit.AC2_hamiltonian"><code>MPSKit.AC2_hamiltonian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AC2_hamiltonian(site, below, operator, above, envs)</code></pre><p>Effective two-site local operator acting at <code>site</code>.</p><pre><code class="language-julia hljs"> ┌──        ──┐ 
 │   │    │   │ 
┌┴┐┌─┴─┐┌─┴─┐┌┴┐
│ ├┤   ├┤   ├┤ │
└┬┘└─┬─┘└─┬─┘└┬┘
 │   │    │   │ 
 └──        ──┘ </code></pre><p>See also <a href="#MPSKit.AC2_projection"><code>AC2_projection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L52-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AC2_projection"><a class="docstring-binding" href="#MPSKit.AC2_projection"><code>MPSKit.AC2_projection</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AC2_projection(site, below, operator, above, envs)</code></pre><p>Application of the effective two-site local operator at a given site.</p><pre><code class="language-julia hljs">    ┌──────┐    
 ┌──┤      ├──┐ 
 │  └┬────┬┘  │ 
┌┴┐┌─┴─┐┌─┴─┐┌┴┐
│ ├┤   ├┤   ├┤ │
└┬┘└─┬─┘└─┬─┘└┬┘
 │   │    │   │ 
 └──        ──┘ </code></pre><p>See also <a href="#MPSKit.AC2_hamiltonian"><code>AC2_hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L145-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AC_hamiltonian"><a class="docstring-binding" href="#MPSKit.AC_hamiltonian"><code>MPSKit.AC_hamiltonian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AC_hamiltonian(site, below, operator, above, envs)::DerivativeOperator</code></pre><p>Effective one-site local operator acting at <code>site</code>.</p><pre><code class="language-julia hljs"> ┌───   ───┐ 
 │    │    │ 
┌┴┐ ┌─┴─┐ ┌┴┐
│ ├─┤   ├─┤ │
└┬┘ └─┬─┘ └┬┘
 │    │    │ 
 └───   ───┘ </code></pre><p>See also <a href="#MPSKit.AC_projection"><code>AC_projection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L34-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.AC_projection"><a class="docstring-binding" href="#MPSKit.AC_projection"><code>MPSKit.AC_projection</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AC_projection(site, below, operator, above, envs)</code></pre><p>Application of the effective one-site local operator at a given site.</p><pre><code class="language-julia hljs">    ┌───┐    
 ┌──┤   ├──┐ 
 │  └─┬─┘  │ 
┌┴┐ ┌─┴─┐ ┌┴┐
│ ├─┤   ├─┤ │
└┬┘ └─┬─┘ └┬┘
 │    │    │ 
 └──     ──┘ </code></pre><p>See also <a href="#MPSKit.AC_hamiltonian"><code>AC_hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L126-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.C_hamiltonian"><a class="docstring-binding" href="#MPSKit.C_hamiltonian"><code>MPSKit.C_hamiltonian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">C_hamiltonian(site, below, operator, above, envs)::DerivativeOperator</code></pre><p>Effective zero-site local operator acting at <code>site</code>.</p><pre><code class="language-julia hljs"> ┌─   ─┐ 
 │     │ 
┌┴┐   ┌┴┐
│ ├───┤ │
└┬┘   └┬┘
 │     │ 
 └─   ─┘ </code></pre><p>See also <a href="#MPSKit.C_projection"><code>C_projection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L16-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.C_projection"><a class="docstring-binding" href="#MPSKit.C_projection"><code>MPSKit.C_projection</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">C_projection(site, below, operator, above, envs)</code></pre><p>Application of the effective zero-site local operator at a given site.</p><pre><code class="language-julia hljs">   ┌─┐   
 ┌─┤ ├─┐ 
 │ └─┘ │ 
┌┴┐   ┌┴┐
│ ├───┤ │
└┬┘   └┬┘
 │     │ 
 └─   ─┘ </code></pre><p>See also <a href="#MPSKit.C_hamiltonian"><code>C_hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/derivatives/derivatives.jl#L107-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit._gaugecenter-Tuple{FiniteMPS}"><a class="docstring-binding" href="#MPSKit._gaugecenter-Tuple{FiniteMPS}"><code>MPSKit._gaugecenter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_gaugecenter(ψ::FiniteMPS)::HalfInt</code></pre><p>Return the location of the MPS center.</p><p><code>center::HalfInt</code>:</p><ul><li><code>isinteger(center)</code> → <code>center</code> is a whole number and indicates the location of the first <code>AC</code> tensor present in <code>ψ.ACs</code></li><li><code>ishalfodd(center)</code> → <code>center</code> is a half-odd-integer, meaning that there are no <code>AC</code> tensors, and indicating between which sites the bond tensor lives.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ψ = FiniteMPS(3, ℂ^2, ℂ^16)
ψ.center # returns 7/2, bond tensor is to the right of the 3rd site
ψ.AC[1]   # moves center to first site
ψ.center # returns 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/finitemps.jl#L176-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.add_util_leg-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N1, N2}}, Tuple{N2}, Tuple{N1}, Tuple{S}, Tuple{T}} where {T, S, N1, N2}"><a class="docstring-binding" href="#MPSKit.add_util_leg-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N1, N2}}, Tuple{N2}, Tuple{N1}, Tuple{S}, Tuple{T}} where {T, S, N1, N2}"><code>MPSKit.add_util_leg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_util_leg(tensor::AbstractTensorMap{T, S, N1, N2}) where {T, S, N1, N2}
    -&gt; AbstractTensorMap{T, S, N1+1, N2+1}</code></pre><p>Add trivial one-dimensional utility spaces with trivial sector to the left and right of a given tensor map, i.e. as the first space of the codomain and the last space of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/utility.jl#L51-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.approx_angles-Tuple{Any}"><a class="docstring-binding" href="#MPSKit.approx_angles-Tuple{Any}"><code>MPSKit.approx_angles</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Find the closest fractions of π, differing at most <code>tol_angle</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L142-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.approximate"><a class="docstring-binding" href="#MPSKit.approximate"><code>MPSKit.approximate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">approximate(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)
approximate!(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)</code></pre><p>Compute an approximation to the application of an operator <code>O</code> to the state <code>ψ</code> in the form of an MPS <code>ψ₀</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess of the approximated state</li><li><code>(O::AbstractMPO, ψ::AbstractMPS)</code>: operator <code>O</code> and state <code>ψ</code> to be approximated</li><li><code>algorithm</code>: approximation algorithm. See below for a list of available algorithms.</li><li><code>[environments]</code>: MPS environment manager</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Algorithms</strong></p><ul><li><p><code>DMRG</code>: Alternating least square method for maximizing the fidelity with a single-site scheme.</p></li><li><p><code>DMRG2</code>: Alternating least square method for maximizing the fidelity with a two-site scheme.</p></li><li><p><code>IDMRG</code>: Variant of <code>DMRG</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>IDMRG2</code>: Variant of <code>DMRG2</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>VOMPS</code>: Tangent space method for truncating uniform MPS.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/approximate/approximate.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.approximate!"><a class="docstring-binding" href="#MPSKit.approximate!"><code>MPSKit.approximate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">approximate(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)
approximate!(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)</code></pre><p>Compute an approximation to the application of an operator <code>O</code> to the state <code>ψ</code> in the form of an MPS <code>ψ₀</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess of the approximated state</li><li><code>(O::AbstractMPO, ψ::AbstractMPS)</code>: operator <code>O</code> and state <code>ψ</code> to be approximated</li><li><code>algorithm</code>: approximation algorithm. See below for a list of available algorithms.</li><li><code>[environments]</code>: MPS environment manager</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Algorithms</strong></p><ul><li><p><code>DMRG</code>: Alternating least square method for maximizing the fidelity with a single-site scheme.</p></li><li><p><code>DMRG2</code>: Alternating least square method for maximizing the fidelity with a two-site scheme.</p></li><li><p><code>IDMRG</code>: Variant of <code>DMRG</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>IDMRG2</code>: Variant of <code>DMRG2</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>VOMPS</code>: Tangent space method for truncating uniform MPS.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/approximate/approximate.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.bond_type-Tuple{MPSKit.AbstractMPS}"><a class="docstring-binding" href="#MPSKit.bond_type-Tuple{MPSKit.AbstractMPS}"><code>MPSKit.bond_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bond_type(ψ::AbstractMPS)
bond_type(ψtype::Type{&lt;:AbstractMPS})</code></pre><p>Return the type of the bond tensors of an <code>AbstractMPS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L190-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.braille-Tuple{IO, Union{AbstractMPO{O} where O&lt;:BlockTensorKit.SparseBlockTensorMap, MPOHamiltonian}}"><a class="docstring-binding" href="#MPSKit.braille-Tuple{IO, Union{AbstractMPO{O} where O&lt;:BlockTensorKit.SparseBlockTensorMap, MPOHamiltonian}}"><code>MPSKit.braille</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">braille(io::IO, H::Union{SparseMPO, MPOHamiltonian})
braille(H::Union{SparseMPO, MPOHamiltonian})</code></pre><p>Prints a compact, human-readable &quot;braille&quot; visualization of a sparseMPO or MPOHamiltonian. Each site of the MPO is represented as a block of Unicode braille characters, with sites separated by dashes. This visualization is useful for quickly inspecting the structure and sparsity pattern of MPOs.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The output stream to print to (e.g., <code>stdout</code>).</li><li><code>H::Union{SparseMPO, MPOHamiltonian}</code>: The <code>SparseMPO</code> or <code>MPOHamiltonian</code> to visualize.</li></ul><p>If called without an <code>io</code> argument, output is printed to <code>stdout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/show.jl#L190-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.calc_galerkin-Tuple{Int64, Union{FiniteMPS, InfiniteMPS, WindowMPS}, Any, Any, Any}"><a class="docstring-binding" href="#MPSKit.calc_galerkin-Tuple{Int64, Union{FiniteMPS, InfiniteMPS, WindowMPS}, Any, Any, Any}"><code>MPSKit.calc_galerkin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calc_galerkin(below, operator, above, envs)
calc_galerkin(pos, below, operator, above, envs)</code></pre><p>Calculate the Galerkin error, which is the error between the solution of the original problem, and the solution of the problem projected on the tangent space. Concretely, this is the overlap of the current state with the single-site derivative, projected onto the nullspace of the current state:</p><p class="math-container">\[\epsilon = \left|VL ⋅ \left(VL^{\dagger} ⋅ \frac{\partial \text{above}}{\partial AC_{\text{pos}}}\right)\right|\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L47-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.changebonds"><a class="docstring-binding" href="#MPSKit.changebonds"><code>MPSKit.changebonds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">changebonds(ψ::AbstractMPS, H, alg, envs) -&gt; ψ′, envs′
changebonds(ψ::AbstractMPS, alg) -&gt; ψ′</code></pre><p>Change the bond dimension of <code>ψ</code> using the algorithm <code>alg</code>, and return the new <code>ψ</code> and the new <code>envs</code>.</p><p>See also: <a href="#MPSKit.SvdCut"><code>SvdCut</code></a>, <a href="#MPSKit.RandExpand"><code>RandExpand</code></a>, <a href="#MPSKit.VUMPSSvdCut"><code>VUMPSSvdCut</code></a>, <a href="#MPSKit.OptimalExpand"><code>OptimalExpand</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/changebonds/changebonds.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.check_unambiguous_braiding-Tuple{Type{Bool}, TensorKit.VectorSpace}"><a class="docstring-binding" href="#MPSKit.check_unambiguous_braiding-Tuple{Type{Bool}, TensorKit.VectorSpace}"><code>MPSKit.check_unambiguous_braiding</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_unambiguous_braiding(::Type{Bool}, V::VectorSpace)::Bool
check_unambiguous_braiding(V::VectorSpace)</code></pre><p>Verify that the braiding of a vector space is unambiguous. This is the case if the braiding is symmetric or if all sectors are trivial. The signature with <code>Type{Bool}</code> is used to check while the signature without is used to throw an error if the braiding is ambiguous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/utility.jl#L130-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.correlation_length-Tuple{InfiniteMPS}"><a class="docstring-binding" href="#MPSKit.correlation_length-Tuple{InfiniteMPS}"><code>MPSKit.correlation_length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">correlation_length(above::InfiniteMPS; kwargs...)</code></pre><p>Compute the correlation length of a given InfiniteMPS based on the next-to-leading eigenvalue of the transfer matrix. The <code>kwargs</code> are passed to <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>, and can for example be used to target the correlation length in a specific sector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L188-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.correlator"><a class="docstring-binding" href="#MPSKit.correlator"><code>MPSKit.correlator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">correlator(ψ, O1, O2, i, j)
correlator(ψ, O12, i, j)</code></pre><p>Compute the 2-point correlator &lt;ψ|O1[i]O2[j]|ψ&gt; for inserting <code>O1</code> at <code>i</code> and <code>O2</code> at <code>j</code>. Also accepts ranges for <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/correlators.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.eachsite-Tuple{MPSKit.AbstractMPS}"><a class="docstring-binding" href="#MPSKit.eachsite-Tuple{MPSKit.AbstractMPS}"><code>MPSKit.eachsite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachsite(state::AbstractMPS)</code></pre><p>Return an iterator over the sites of the MPS <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L245-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.entanglement_spectrum"><a class="docstring-binding" href="#MPSKit.entanglement_spectrum"><code>MPSKit.entanglement_spectrum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">entanglement_spectrum(ψ, site::Int) -&gt; SectorVector{T, sectortype(ψ), AbstractVector{T}}</code></pre><p>Compute the entanglement spectrum at a given site, i.e. the singular values of the gauge matrix to the right of a given site. This is a vector containing the singular values. The contributions from specific sectors can be viewed by indexing accordingly, i.e. <code>entanglement_spectrum(ψ, site)[sector]</code>.</p><p>For <code>InfiniteMPS</code> and <code>WindowMPS</code> the default value for <code>site</code> is 0.</p><p>For <code>FiniteMPS</code> no default value for <code>site</code> is given; it is up to the user to specify.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L121-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.entanglementplot"><a class="docstring-binding" href="#MPSKit.entanglementplot"><code>MPSKit.entanglementplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">entanglementplot(state; site=0[, kwargs...])</code></pre><p>Plot the <a href="#MPSKit.entanglement_spectrum">entanglement spectrum</a> of a given MPS <code>state</code>. </p><p><strong>Arguments</strong></p><ul><li><code>state</code>: the MPS for which to compute the entanglement spectrum.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>site::Int=0</code>: MPS index for multisite unit cells. The spectrum is computed for the bond between <code>site</code> and <code>site + 1</code>.</li><li><code>expand_symmetry::Logical=false</code>: add quantum dimension degeneracies.</li><li><code>sortby=maximum</code>: the method of sorting the sectors.</li><li><code>sector_margin=1//10</code>: the amount of whitespace between sectors.</li><li><code>sector_formatter=string</code>: how to convert sectors to strings.</li><li><code>kwargs...</code>: other kwargs are passed on to the plotting backend.</li></ul><div class="admonition is-info" id="Note-38f4784ec8b3ec8f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-38f4784ec8b3ec8f" title="Permalink"></a></header><div class="admonition-body"><p>You will need to manually import <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> to be able to use this function. MPSKit.jl defines its plots based on <a href="https://github.com/JuliaPlots/Plots.jl/tree/v2/RecipesBase">RecipesBase.jl</a>, but the user still has to add <code>using Plots</code> to be able to actually produce the plots.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/plotting.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.entropy-Tuple{InfiniteMPS}"><a class="docstring-binding" href="#MPSKit.entropy-Tuple{InfiniteMPS}"><code>MPSKit.entropy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">entropy(state, [site::Int])
entropy(spectrum::SectorVector)</code></pre><p>Calculate the von Neumann entanglement entropy. The entropy can be computed from either an MPS state or directly from an entanglement spectrum as obtained from <a href="#MPSKit.entanglement_spectrum"><code>entanglement_spectrum</code></a>.</p><p>When called on an MPS with an integer <code>site</code>, the entropy is computed across the entanglement cut to the right of site <code>site</code>. For <code>InfiniteMPS</code>, omitting <code>site</code> returns a vector of entropies, one for each site. For <code>FiniteMPS</code> and <code>WindowMPS</code>, <code>site</code> is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.environment_alg-Tuple{Union{InfiniteMPS, MultilineMPS}, Union{InfiniteMPO, MultilineMPO}, Union{InfiniteMPS, MultilineMPS}}"><a class="docstring-binding" href="#MPSKit.environment_alg-Tuple{Union{InfiniteMPS, MultilineMPS}, Union{InfiniteMPO, MultilineMPO}, Union{InfiniteMPS, MultilineMPS}}"><code>MPSKit.environment_alg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">environment_alg(below, operator, above; kwargs...)</code></pre><p>Determine an appropriate algorithm for computing the environments, based on the given <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/environments/abstract_envs.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.exact_diagonalization-Tuple{FiniteMPOHamiltonian}"><a class="docstring-binding" href="#MPSKit.exact_diagonalization-Tuple{FiniteMPOHamiltonian}"><code>MPSKit.exact_diagonalization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">exact_diagonalization(H::FiniteMPOHamiltonian;
                      sector=rightunit(H),
                      len::Int=length(H), num::Int=1, which::Symbol=:SR,
                      alg=Defaults.alg_eigsolve(; dynamic_tols=false))
                        -&gt; vals, state_vecs, convhist</code></pre><p>Use <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a> to perform exact diagonalization on a <code>FiniteMPOHamiltonian</code> to find its eigenvectors as <code>FiniteMPS</code> of maximal rank, essentially equivalent to dense eigenvectors.</p><p><strong>Arguments</strong></p><ul><li><code>H::FiniteMPOHamiltonian</code>: the Hamiltonian to diagonalize.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sector=rightunit(H)</code>: the total charge of the eigenvectors, which is chosen trivial by default.</li><li><code>len::Int=length(H)</code>: the length of the system.</li><li><code>num::Int=1</code>: the number of eigenvectors to find.</li><li><code>which::Symbol=:SR</code>: the kind eigenvalues to find, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a>. </li><li><code>alg=Defaults.alg_eigsolve(; dynamic_tols=false)</code>: the diagonalization algorithm to use, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a>.</li></ul><div class="admonition is-info" id="Valid-sector-values-b92a6f6c8a97b7c4"><header class="admonition-header">Valid `sector` values<a class="admonition-anchor" href="#Valid-sector-values-b92a6f6c8a97b7c4" title="Permalink"></a></header><div class="admonition-body"><p>The total charge of the eigenvectors is imposed by adding a charged auxiliary space as the leftmost virtualspace of each eigenvector. Specifically, this is achieved by passing <code>left=Vect[typeof(sector)](sector =&gt; 1)</code> to the <a href="../../man/states/#FiniteMPS"><code>FiniteMPS</code></a> constructor. As such, the only valid <code>sector</code> values (i.e. <code>sector</code> values for which the corresponding eigenstates have valid fusion channels) are those that occur in the dual of the fusion of all the physical spaces in the system.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/ED.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.excitations"><a class="docstring-binding" href="#MPSKit.excitations"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, left_ψ::FiniteMPS, [left_environment],
            [right_ψ::FiniteMPS], [right_environment]; kwargs...)</code></pre><p>Create and optimize finite quasiparticle states.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm::QuasiparticleAnsatz</code>: optimization algorithm</li><li><code>left_ψ::FiniteMPS</code>: left ground state</li><li><code>[left_environment]</code>: left ground state environment</li><li><code>[right_ψ::FiniteMPS]</code>: right ground state</li><li><code>[right_environment]</code>: right ground state environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>sector=leftunit(lmps)</code>: charge of the quasiparticle state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/quasiparticleexcitation.jl#L161-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.excitations"><a class="docstring-binding" href="#MPSKit.excitations"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, momentum::Union{Number, Vector{&lt;:Number}},
            left_ψ::InfiniteMPS, [left_environment],
            [right_ψ::InfiniteMPS], [right_environment];
            kwargs...)</code></pre><p>Create and optimize infinite quasiparticle states.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm::QuasiparticleAnsatz</code>: optimization algorithm</li><li><code>momentum::Union{Number, Vector{&lt;:Number}}</code>: momentum or list of momenta</li><li><code>left_ψ::InfiniteMPS</code>: left ground state</li><li><code>[left_environment]</code>: left ground state environment</li><li><code>[right_ψ::InfiniteMPS]</code>: right ground state</li><li><code>[right_environment]</code>: right ground state environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>solver</code>: algorithm for the linear solver of the quasiparticle environments</li><li><code>sector=leftunit(left_ψ)</code>: charge of the quasiparticle state</li><li><code>parallel=true</code>: enable multi-threading over different momenta</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/quasiparticleexcitation.jl#L68-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.excitations"><a class="docstring-binding" href="#MPSKit.excitations"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, ψ::FiniteQP, [left_environments],
            [right_environments]; num=1) -&gt; (energies, states)
excitations(H, algorithm::QuasiparticleAnsatz, ψ::InfiniteQP, [left_environments],
            [right_environments]; num=1, solver=Defaults.solver) -&gt; (energies, states)
excitations(H, algorithm::FiniteExcited, ψs::NTuple{&lt;:Any, &lt;:FiniteMPS};
            num=1, init=copy(first(ψs))) -&gt; (energies, states)
excitations(H, algorithm::ChepigaAnsatz, ψ::FiniteMPS, [envs];
            num=1, pos=length(ψ)÷2) -&gt; (energies, states)
excitations(H, algorithm::ChepigaAnsatz2, ψ::FiniteMPS, [envs];
            num=1, pos=length(ψ)÷2) -&gt; (energies, states)</code></pre><p>Compute the first excited states and their energy gap above a ground state.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm</code>: optimization algorithm</li><li><code>ψ::QP</code>: initial quasiparticle guess</li><li><code>ψs::NTuple{N, &lt;:FiniteMPS}</code>: <code>N</code> first excited states</li><li><code>[left_environments]</code>: left ground state environment</li><li><code>[right_environments]</code>: right ground state environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>solver</code>: algorithm for the linear solver of the quasiparticle environments</li><li><code>init</code>: initial excited state guess</li><li><code>pos</code>: position of perturbation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/excitation/excitations.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.expectation_value"><a class="docstring-binding" href="#MPSKit.expectation_value"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">expectation_value(ψ, O, [environments])
expectation_value(ψ, inds =&gt; O)
expectation_value(ψ, (mpo, site =&gt; O), [environments])</code></pre><p>Compute the expectation value of an operator <code>O</code> on a state <code>ψ</code>.  Optionally, it is possible to make the computations more efficient by also passing in previously calculated <code>environments</code>.</p><p>In general, the operator <code>O</code> may consist of an arbitrary MPO <code>O &lt;: AbstractMPO</code> that acts on all sites, a local operator <code>O = inds =&gt; operator</code> acting on a subset of sites, or a local MPO tensor acting on a site within a network whose environment is determined by another MPO <code>mpo</code>. In the second case, <code>inds</code> is a tuple of indices that specify the sites on which the operator acts, while the operator is either a <code>AbstractTensorMap</code> or a <code>FiniteMPO</code>. In the latter case, the operator is a <code>AbstractTensorMap</code> that acts on the physical space of a single site.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::AbstractMPS</code> : the state on which to compute the expectation value</li><li><code>O::Union{AbstractMPO,Pair,AbstractTensorMap}</code> : the operator to compute the expectation value of.    This can either be an <code>AbstractMPO</code>, a pair of indices and local operator, or a local MPO tensor   represented as a <code>AbstractTensorMap</code>.</li><li><code>environments::AbstractMPSEnvironments</code> : the environments to use for the calculation. If not given, they will be calculated.   Depending on the type of <code>O</code>, these will be the environments of the operator <code>O</code> or the MPO <code>mpo</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = FiniteMPS(ones(Float64, (ℂ^2)^4));

julia&gt; S_x = TensorMap(Float64[0 1; 1 0], ℂ^2, ℂ^2);

julia&gt; round(expectation_value(ψ, 2 =&gt; S_x))
1.0

julia&gt; round(expectation_value(ψ, (2, 3) =&gt; S_x ⊗ S_x))
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/expval.jl#L1-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.fidelity_susceptibility-Union{Tuple{T}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}, Any}} where T&lt;:MPOHamiltonian"><a class="docstring-binding" href="#MPSKit.fidelity_susceptibility-Union{Tuple{T}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}, Any}} where T&lt;:MPOHamiltonian"><code>MPSKit.fidelity_susceptibility</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity_susceptibility(state::Union{FiniteMPS,InfiniteMPS}, H₀::T,
                        Vs::AbstractVector{T}, [henvs=environments(state, H₀)];
                        maxiter=Defaults.maxiter,
                        tol=Defaults.tol) where {T&lt;:MPOHamiltonian}</code></pre><p>Computes the fidelity susceptibility of a the ground state <code>state</code> of a base Hamiltonian <code>H₀</code> with respect to a set of perturbing Hamiltonians <code>Vs</code>. Each of the perturbing Hamiltonians can be interpreted as corresponding to a tuning parameter <span>$aᵢ$</span> in a &#39;total&#39; Hamiltonian <span>$H = H₀ + ∑ᵢ aᵢ Vᵢ$</span>.</p><p>Returns a matrix containing the overlaps of the elementary excitations on top of <code>state</code> corresponding to each of the perturbing Hamiltonians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/fidelity_susceptibility.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.find_groundstate"><a class="docstring-binding" href="#MPSKit.find_groundstate"><code>MPSKit.find_groundstate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_groundstate(ψ₀, H, [environments]; kwargs...) -&gt; (ψ, environments, ϵ)
find_groundstate(ψ₀, H, algorithm, environments) -&gt; (ψ, environments, ϵ)</code></pre><p>Compute the ground state for Hamiltonian <code>H</code> with initial guess <code>ψ</code>. If not specified, an optimization algorithm will be attempted based on the supplied keywords.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess</li><li><code>H::AbstractMPO</code>: operator for which to find the ground state</li><li><code>[environments]</code>: MPS environment manager</li><li><code>algorithm</code>: optimization algorithm</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>ψ::AbstractMPS</code>: converged ground state</li><li><code>environments</code>: environments corresponding to the converged state</li><li><code>ϵ::Float64</code>: final convergence error upon terminating the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/groundstate/find_groundstate.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.fixedpoint-Tuple{Any, Any, Symbol, KrylovKit.Lanczos}"><a class="docstring-binding" href="#MPSKit.fixedpoint-Tuple{Any, Any, Symbol, KrylovKit.Lanczos}"><code>MPSKit.fixedpoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fixedpoint(A, x₀, which::Symbol; kwargs...) -&gt; val, vec
fixedpoint(A, x₀, which::Symbol, alg) -&gt; val, vec</code></pre><p>Compute the fixed point of a linear operator <code>A</code> using the specified eigensolver <code>alg</code>. The fixedpoint is assumed to be unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/fixedpoint.jl#L3-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.fuse_mul_mpo-Tuple{Any, Any}"><a class="docstring-binding" href="#MPSKit.fuse_mul_mpo-Tuple{Any, Any}"><code>MPSKit.fuse_mul_mpo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fuse_mul_mpo(O1, O2)</code></pre><p>Compute the mpo tensor that arises from multiplying MPOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/abstractmpo.jl#L148-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.gaugefix!"><a class="docstring-binding" href="#MPSKit.gaugefix!"><code>MPSKit.gaugefix!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gaugefix!(ψ::InfiniteMPS, A, C₀; kwargs...) -&gt; ψ
gaugefix!(ψ::InfiniteMPS, A, C₀, alg::Algorithm) -&gt; ψ</code></pre><p>Bring an <code>InfiniteMPS</code> into a uniform gauge, using the specified algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/ortho.jl#L103-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.infinite_temperature_density_matrix-Tuple{MPOHamiltonian}"><a class="docstring-binding" href="#MPSKit.infinite_temperature_density_matrix-Tuple{MPOHamiltonian}"><code>MPSKit.infinite_temperature_density_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">infinite_temperature_density_matrix(H::MPOHamiltonian) -&gt; MPO</code></pre><p>Return the density matrix of the infinite temperature state for a given Hamiltonian. This is the identity matrix in the physical space, and the identity in the auxiliary space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.instantiate_operator-Tuple{MPSKit.AbstractMPS, Pair}"><a class="docstring-binding" href="#MPSKit.instantiate_operator-Tuple{MPSKit.AbstractMPS, Pair}"><code>MPSKit.instantiate_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">instantiate_operator(state, O::Pair)
instantiate_operator(lattice::AbstractArray{&lt;:VectorSpace}, O::Pair)</code></pre><p>Instantiate a local operator <code>O</code> for a <code>state</code> or <code>lattice</code> as a vector of MPO tensors, and a vector of linear site indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpohamiltonian.jl#L313-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.integrate"><a class="docstring-binding" href="#MPSKit.integrate"><code>MPSKit.integrate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">integrate(f, y₀, t, dt, alg)</code></pre><p>Integrate the differential equation <span>$i dy/dt = f(y, t)$</span> over a time step &#39;dt&#39; starting from <span>$y(t₀)=y₀$</span>, using the provided algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: driving function</li><li><code>y₀</code>: object to integrate</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>alg</code>: integration scheme</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/integrators.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.isfullrank-Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}"><a class="docstring-binding" href="#MPSKit.isfullrank-Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}"><code>MPSKit.isfullrank</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isfullrank(A::GenericMPSTensor; side=:both)</code></pre><p>Determine whether the given tensor is full rank, i.e. whether both the map from the left virtual space and the physical space to the right virtual space, and the map from the right virtual space and the physical space to the left virtual space are injective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L89-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.l_LL-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A"><a class="docstring-binding" href="#MPSKit.l_LL-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A"><code>MPSKit.l_LL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">l_LL(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AL</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L341-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.l_LR"><a class="docstring-binding" href="#MPSKit.l_LR"><code>MPSKit.l_LR</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l_LR(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AL</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L334-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.l_RL"><a class="docstring-binding" href="#MPSKit.l_RL"><code>MPSKit.l_RL</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l_RL(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AR</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L327-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.l_RR"><a class="docstring-binding" href="#MPSKit.l_RR"><code>MPSKit.l_RR</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l_RR(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AR</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L320-L324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.leading_boundary"><a class="docstring-binding" href="#MPSKit.leading_boundary"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">leading_boundary(ψ, opp, alg, envs=environments(ψ, opp))</code></pre><p>Approximate the leading eigenvector for opp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/statmech/vumps.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.leading_boundary"><a class="docstring-binding" href="#MPSKit.leading_boundary"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">leading_boundary(ψ₀, O, [environments]; kwargs...) -&gt; (ψ, environments, ϵ)
leading_boundary(ψ₀, O, algorithm, environments) -&gt; (ψ, environments, ϵ)</code></pre><p>Compute the leading boundary MPS for operator <code>O</code> with initial guess <code>ψ</code>. If not specified, an optimization algorithm will be attempted based on the supplied keywords.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess</li><li><code>O::AbstractMPO</code>: operator for which to find the leading_boundary</li><li><code>[environments]</code>: MPS environment manager</li><li><code>algorithm</code>: optimization algorithm</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>ψ::AbstractMPS</code>: converged leading boundary MPS</li><li><code>environments</code>: environments corresponding to the converged boundary</li><li><code>ϵ::Float64</code>: final convergence error upon terminating the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/statmech/leading_boundary.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.left_virtualspace"><a class="docstring-binding" href="#MPSKit.left_virtualspace"><code>MPSKit.left_virtualspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_virtualspace(ψ::AbstractMPS, [pos=1:length(ψ)])</code></pre><p>Return the virtual space of the bond to the left of sites <code>pos</code>.</p><div class="admonition is-warning" id="Warning-222ef5b4bd5a719c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-222ef5b4bd5a719c" title="Permalink"></a></header><div class="admonition-body"><p>In rare cases, the gauge tensor on the virtual space might not be square, and as a result it cannot always be guaranteed that <code>right_virtualspace(ψ, i - 1) == left_virtualspace(ψ, i)</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L205-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.make_time_mpo"><a class="docstring-binding" href="#MPSKit.make_time_mpo"><code>MPSKit.make_time_mpo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_time_mpo(H::MPOHamiltonian, dt::Number, alg; kwargs...) -&gt; O::MPO</code></pre><p>Construct an <code>MPO</code> that approximates <span>$\exp(-iHdt)$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution operator is constructed   with an imaginary time step instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>).   This can be useful for using this function to compute the ground state of a Hamiltonian,   or to compute finite-temperature properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/time_evolve.jl#L75-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.makefullrank!-Tuple{PeriodicVector{&lt;:TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}}"><a class="docstring-binding" href="#MPSKit.makefullrank!-Tuple{PeriodicVector{&lt;:TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}}"><code>MPSKit.makefullrank!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">makefullrank!(A::PeriodicVector{&lt;:GenericMPSTensor}; alg=Defaults.alg_qr())</code></pre><p>Make the set of MPS tensors full rank by performing a series of orthogonalizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L112-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.marek_gap-Tuple{InfiniteMPS}"><a class="docstring-binding" href="#MPSKit.marek_gap-Tuple{InfiniteMPS}"><code>MPSKit.marek_gap</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given an InfiniteMPS, compute the gap <code>ϵ</code> for the asymptotics of the transfer matrix, as well as the Marek gap <code>δ</code> as a scaling measure of the bond dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L155-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.max_Ds-Tuple{FiniteMPS}"><a class="docstring-binding" href="#MPSKit.max_Ds-Tuple{FiniteMPS}"><code>MPSKit.max_Ds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_Ds(ψ::FiniteMPS) -&gt; Vector{Float64}</code></pre><p>Compute the dimension of the maximal virtual space at a given site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/finitemps.jl#L443-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.max_virtualspaces-Union{Tuple{Vector{&lt;:Union{TensorKit.CompositeSpace{S}, S}}}, Tuple{S}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#MPSKit.max_virtualspaces-Union{Tuple{Vector{&lt;:Union{TensorKit.CompositeSpace{S}, S}}}, Tuple{S}} where S&lt;:TensorKit.ElementarySpace"><code>MPSKit.max_virtualspaces</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_virtualspaces(ψ::FiniteMPS)
max_virtualspaces(Ps::Vector{&lt;:Union{S,CompositeSpace{S}}}; left=unitspace(S), right=unitspace(S))</code></pre><p>Compute the maximal virtual spaces of a given finite MPS or its physical spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/finitemps.jl#L416-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.multiply_neighbours"><a class="docstring-binding" href="#MPSKit.multiply_neighbours"><code>MPSKit.multiply_neighbours</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multiply_neighbours(mpo::FiniteMPO, i::Integer)
multiply_neighbours!(mpo::FiniteMPO, i::Integer)</code></pre><p>Construct the mpo of length <code>length(mpo) - 1</code> which is formed by multiplying the operators on site <code>i</code> and <code>i + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L431-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.multiply_neighbours!"><a class="docstring-binding" href="#MPSKit.multiply_neighbours!"><code>MPSKit.multiply_neighbours!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multiply_neighbours(mpo::FiniteMPO, i::Integer)
multiply_neighbours!(mpo::FiniteMPO, i::Integer)</code></pre><p>Construct the mpo of length <code>length(mpo) - 1</code> which is formed by multiplying the operators on site <code>i</code> and <code>i + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L431-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.open_boundary_conditions"><a class="docstring-binding" href="#MPSKit.open_boundary_conditions"><code>MPSKit.open_boundary_conditions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">open_boundary_conditions(mpo::InfiniteMPOHamiltonian, L::Int) -&gt; FiniteMPOHamiltonian</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by applying open boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L466-L470">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.open_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O&lt;:BlockTensorKit.SparseBlockTensorMap"><a class="docstring-binding" href="#MPSKit.open_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O&lt;:BlockTensorKit.SparseBlockTensorMap"><code>MPSKit.open_boundary_conditions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">open_boundary_conditions(mpo::InfiniteMPO, L::Int) -&gt; FiniteMPO</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by applying open boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L446-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.periodic_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O"><a class="docstring-binding" href="#MPSKit.periodic_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O"><code>MPSKit.periodic_boundary_conditions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">periodic_boundary_conditions(mpo::AbstractInfiniteMPO, L::Int)</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by mapping periodic boundary conditions onto an open system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L275-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.physicalspace"><a class="docstring-binding" href="#MPSKit.physicalspace"><code>MPSKit.physicalspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">physicalspace(ψ::AbstractMPS, [pos=1:length(ψ)])</code></pre><p>Return the physical space of the site tensor at site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L233-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.propagator"><a class="docstring-binding" href="#MPSKit.propagator"><code>MPSKit.propagator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">propagator(ψ₀::AbstractFiniteMPS, z::Number, H::MPOHamiltonian, alg::DynamicalDMRG; init=copy(ψ₀))</code></pre><p>Calculate the propagator <span>$\frac{1}{E₀ + z - H}|ψ₀⟩$</span> using the dynamical DMRG algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/propagator/corvector.jl#L35-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.r_LL"><a class="docstring-binding" href="#MPSKit.r_LL"><code>MPSKit.r_LL</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">r_LL(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AL</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L375-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.r_LR"><a class="docstring-binding" href="#MPSKit.r_LR"><code>MPSKit.r_LR</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">r_LR(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AL</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L368-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.r_RL"><a class="docstring-binding" href="#MPSKit.r_RL"><code>MPSKit.r_RL</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">r_RL(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AR</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L361-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.r_RR-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A"><a class="docstring-binding" href="#MPSKit.r_RR-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A"><code>MPSKit.r_RR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">r_RR(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AR</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/infinitemps.jl#L350-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.recalculate!"><a class="docstring-binding" href="#MPSKit.recalculate!"><code>MPSKit.recalculate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Recalculate in-place each sub-env in MultipleEnvironments</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/environments/multiple_envs.jl#L30-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.regauge!"><a class="docstring-binding" href="#MPSKit.regauge!"><code>MPSKit.regauge!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">regauge!(AC::GenericMPSTensor, C::MPSBondTensor; alg) -&gt; AL
regauge!(CL::MPSBondTensor, AC::GenericMPSTensor; alg) -&gt; AR</code></pre><p>Bring updated <code>AC</code> and <code>C</code> tensors back into a consistent set of left or right canonical tensors. This minimizes <code>∥AC_i - AL_i * C_i∥</code> or <code>∥AC_i - C_{i-1} * AR_i∥</code>.</p><p>The <code>alg</code> is passed on to <code>left_orth!</code> and <code>right_orth!</code>, and can be used to control the kind of  factorization used. By default, this is set to a (positive) QR/LQ, even though the optimal algorithm would use a polar decompositions instead, sacrificing a bit of performance for accuracy.</p><div class="admonition is-info" id="Note-4be575b841203b0f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4be575b841203b0f" title="Permalink"></a></header><div class="admonition-body"><p>Computing <code>AL</code> is slightly faster than <code>AR</code>, as it avoids an intermediate transposition.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/ortho.jl#L147-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.right_virtualspace"><a class="docstring-binding" href="#MPSKit.right_virtualspace"><code>MPSKit.right_virtualspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_virtualspace(ψ::AbstractMPS, [pos=1:length(ψ)])</code></pre><p>Return the virtual space of the bond to the right of site(s) <code>pos</code>.</p><div class="admonition is-warning" id="Warning-222ef5b4bd5a719c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-222ef5b4bd5a719c" title="Permalink"></a></header><div class="admonition-body"><p>In rare cases, the gauge tensor on the virtual space might not be square, and as a result it cannot always be guaranteed that <code>right_virtualspace(ψ, i - 1) == left_virtualspace(ψ, i)</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L219-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.sample_space-Tuple{Any, Any}"><a class="docstring-binding" href="#MPSKit.sample_space-Tuple{Any, Any}"><code>MPSKit.sample_space</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample_space(V, strategy)</code></pre><p>Sample basis states within a given <code>V::VectorSpace</code> by creating weights for each state that are distributed uniformly, and then truncating according to the given <code>strategy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/changebonds/randexpand.jl#L78-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.site_type-Tuple{MPSKit.AbstractMPS}"><a class="docstring-binding" href="#MPSKit.site_type-Tuple{MPSKit.AbstractMPS}"><code>MPSKit.site_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">site_type(ψ::AbstractMPS)
site_type(ψtype::Type{&lt;:AbstractMPS})</code></pre><p>Return the type of the site tensors of an <code>AbstractMPS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/states/abstractmps.jl#L182-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.swap"><a class="docstring-binding" href="#MPSKit.swap"><code>MPSKit.swap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">swap(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=Defaults.alg_svd(), trscheme)
swap!(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=Defaults.alg_svd(), trscheme)</code></pre><p>Compose the mpo with a swap gate applied to indices <code>i</code> and <code>i + 1</code>, effectively creating an operator that acts on the Hilbert spaces with those factors swapped. The keyword arguments <code>alg</code> and <code>trscheme</code> can be used to control how the resulting tensor is truncated again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L398-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.swap!"><a class="docstring-binding" href="#MPSKit.swap!"><code>MPSKit.swap!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">swap(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=Defaults.alg_svd(), trscheme)
swap!(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=Defaults.alg_svd(), trscheme)</code></pre><p>Compose the mpo with a swap gate applied to indices <code>i</code> and <code>i + 1</code>, effectively creating an operator that acts on the Hilbert spaces with those factors swapped. The keyword arguments <code>alg</code> and <code>trscheme</code> can be used to control how the resulting tensor is truncated again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/operators/mpo.jl#L398-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.tensorexpr-Tuple{Any, Any}"><a class="docstring-binding" href="#MPSKit.tensorexpr-Tuple{Any, Any}"><code>MPSKit.tensorexpr</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tensorexpr(name, ind_out, [ind_in])</code></pre><p>Generates expressions for use within <a href="https://quantumkithub.github.io/TensorOperations.jl/stable/man/indexnotation/#TensorOperations.%40tensor"><code>@tensor</code></a> environments of the form <code>name[ind_out...; ind_in]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/utility.jl#L107-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.time_evolve"><a class="docstring-binding" href="#MPSKit.time_evolve"><code>MPSKit.time_evolve</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">time_evolve(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
time_evolve!(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-evolve the initial state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time span by stepping through each of the time points obtained by iterating t_span.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t_span::AbstractVector{&lt;:Number}</code>: time points over which the time evolution is stepped</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbosity::Int=0</code>: verbosity level for logging</li><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/time_evolve.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.time_evolve!"><a class="docstring-binding" href="#MPSKit.time_evolve!"><code>MPSKit.time_evolve!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">time_evolve(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
time_evolve!(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-evolve the initial state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time span by stepping through each of the time points obtained by iterating t_span.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t_span::AbstractVector{&lt;:Number}</code>: time points over which the time evolution is stepped</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbosity::Int=0</code>: verbosity level for logging</li><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/time_evolve.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.timestep"><a class="docstring-binding" href="#MPSKit.timestep"><code>MPSKit.timestep</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
timestep!(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-step the state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time step <code>dt</code> at time <code>t</code>, solving the Schroedinger equation: <span>$i ∂ψ/∂t = H ψ$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/time_evolve.jl#L50-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.timestep!"><a class="docstring-binding" href="#MPSKit.timestep!"><code>MPSKit.timestep!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
timestep!(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-step the state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time step <code>dt</code> at time <code>t</code>, solving the Schroedinger equation: <span>$i ∂ψ/∂t = H ψ$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/timestep/time_evolve.jl#L50-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}"><a class="docstring-binding" href="#MPSKit.transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}"><code>MPSKit.transfer_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transfer_left(v, A, Ā)</code></pre><p>apply a transfer matrix to the left.</p><pre><code class="language-julia hljs"> ┌─A─
-v │
 └─Ā─</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/transfermatrix/transfer.jl#L7-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}"><a class="docstring-binding" href="#MPSKit.transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}"><code>MPSKit.transfer_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transfer_right(v, A, Ā)</code></pre><p>apply a transfer matrix to the right.</p><pre><code class="language-julia hljs">─A─┐
 │ v-
─Ā─┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/transfermatrix/transfer.jl#L32-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><a class="docstring-binding" href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>MPSKit.transfer_spectrum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transfer_spectrum(above::InfiniteMPS; below=above, tol=Defaults.tol, num_vals=20,
                       sector=leftunit(above))</code></pre><p>Calculate the partial spectrum of the left mixed transfer matrix corresponding to the overlap of a given <code>above</code> state and a <code>below</code> state. The <code>sector</code> keyword argument can be used to specify a non-trivial total charge for the transfer matrix eigenvectors. Specifically, an auxiliary space <code>ℂ[typeof(sector)](sector =&gt; 1)&#39;</code> will be added to the domain of each eigenvector. The <code>tol</code> and <code>num_vals</code> keyword arguments are passed to <code>KrylovKit.eigsolve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L88-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.transferplot"><a class="docstring-binding" href="#MPSKit.transferplot"><code>MPSKit.transferplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transferplot(above, below=above; sectors=[], transferkwargs=(;)[, kwargs...])</code></pre><p>Plot the partial transfer matrix spectrum of two InfiniteMPS&#39;s.</p><p><strong>Arguments</strong></p><ul><li><code>above::InfiniteMPS</code>: above mps for <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>.</li><li><code>below::InfiniteMPS=above</code>: below mps for <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>sectors=[]</code>: vector of sectors for which to compute the spectrum.</li><li><code>transferkwargs</code>: kwargs for call to <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>.</li><li><code>kwargs</code>: other kwargs are passed on to the plotting backend.</li><li><code>thetaorigin=0</code>: origin of the angle range.</li><li><code>sector_formatter=string</code>: how to convert sectors to strings.</li></ul><div class="admonition is-info" id="Note-38f4784ec8b3ec8f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-38f4784ec8b3ec8f" title="Permalink"></a></header><div class="admonition-body"><p>You will need to manually import <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> to be able to use this function. MPSKit.jl defines its plots based on <a href="https://github.com/JuliaPlots/Plots.jl/tree/v2/RecipesBase">RecipesBase.jl</a>, but the user still has to add <code>using Plots</code> to be able to actually produce the plots.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/utility/plotting.jl#L91-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.variance"><a class="docstring-binding" href="#MPSKit.variance"><code>MPSKit.variance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">variance(state, hamiltonian, [envs=environments(state, hamiltonian)])</code></pre><p>Compute the variance of the energy of the state with respect to the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/f008b087ba774270f08f9531f8d0435489d5764f/src/algorithms/toolbox.jl#L205-L209">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/">« Examples</a><a class="docs-footer-nextpage" href="../../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 13:53">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
