<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · MPSKit.jl</title><meta name="title" content="Library · MPSKit.jl"/><meta property="og:title" content="Library · MPSKit.jl"/><meta property="twitter:title" content="Library · MPSKit.jl"/><meta name="description" content="Documentation for MPSKit.jl."/><meta property="og:description" content="Documentation for MPSKit.jl."/><meta property="twitter:description" content="Documentation for MPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Prerequisites</a></li><li><a class="tocitem" href="../../man/states/">States</a></li><li><a class="tocitem" href="../../man/operators/">Operators</a></li><li><a class="tocitem" href="../../man/algorithms/">Algorithms</a></li><li><a class="tocitem" href="../../man/parallelism/">Parallelism in julia</a></li><li><a class="tocitem" href="../../man/lattices/">Lattices</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Library</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/main/docs/src/lib/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-documentation"><a class="docs-heading-anchor" href="#Library-documentation">Library documentation</a><a id="Library-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.WI" href="#MPSKit.WI"><code>MPSKit.WI</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const WI = TaylorCluster(; N=1, extension=false, compression=false)</code></pre><p>First order Taylor expansion for a time-evolution MPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/taylorcluster.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AbstractMPO" href="#MPSKit.AbstractMPO"><code>MPSKit.AbstractMPO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMPO{O} &lt;: AbstractVector{O} end</code></pre><p>Abstract supertype for Matrix Product Operators (MPOs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/abstractmpo.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AbstractMPSEnvironments" href="#MPSKit.AbstractMPSEnvironments"><code>MPSKit.AbstractMPSEnvironments</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractEnvironments end</code></pre><p>Abstract supertype for all environment types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/environments/abstract_envs.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.Algorithm" href="#MPSKit.Algorithm"><code>MPSKit.Algorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Algorithm</code></pre><p>Abstract supertype for all algorithm structs. These can be thought of as <code>NamedTuple</code>s that hold the settings for a given algorithm, which can be used for dispatch. Additionally, the constructors can be used to provide default values and input sanitation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/algorithm.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.ChepigaAnsatz" href="#MPSKit.ChepigaAnsatz"><code>MPSKit.ChepigaAnsatz</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ChepigaAnsatz{A&lt;:KrylovKit.KrylovAlgorithm} &lt;: MPSKit.Algorithm</code></pre><p>Single-site optimization algorithm for excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><code>alg::KrylovKit.KrylovAlgorithm</code>: algorithm used for the eigenvalue solvers</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ChepigaAnsatz()
ChepigaAnsatz(; kwargs...)
ChepigaAnsatz(alg)</code></pre><p>Create a <code>ChepigaAnsatz</code> algorithm with the given eigensolver, or by passing the keyword arguments to [<code>Arnoldi</code>][@extref KrylovKit.Arnoldi].</p><p><strong>References</strong></p><ul><li><a href="../../references/#chepiga2017">Chepiga et al. Phys. Rev. B 96 (2017)</a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/chepigaansatz.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.ChepigaAnsatz2" href="#MPSKit.ChepigaAnsatz2"><code>MPSKit.ChepigaAnsatz2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChepigaAnsatz2 &lt;: Algorithm</code></pre><p>Two-site optimization algorithm for excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><code>alg::A = Defaults.eigsolver</code>: algorithm to use for the eigenvalue problem.</li><li><code>trscheme = Defaults.trscheme</code>: algorithm to use for truncation.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ChepigaAnsatz2()
ChepigaAnsatz2(; kwargs...)
ChepigaAnsatz2(alg, trscheme)</code></pre><p>Create a <code>ChepigaAnsatz2</code> algorithm with the given eigensolver and truncation, or by passing the keyword arguments to <code>Arnoldi</code>.</p><p><strong>References</strong></p><ul><li><a href="../../references/#chepiga2017">Chepiga et al. Phys. Rev. B 96 (2017)</a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/chepigaansatz.jl#L66-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DDMRG_Flavour" href="#MPSKit.DDMRG_Flavour"><code>MPSKit.DDMRG_Flavour</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type DDMRG_Flavour</code></pre><p>Abstract supertype for the different flavours of dynamical DMRG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/propagator/corvector.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DMRG" href="#MPSKit.DMRG"><code>MPSKit.DMRG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DMRG{A, F} &lt;: MPSKit.Algorithm</code></pre><p>Single-site DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/dmrg.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DMRG2" href="#MPSKit.DMRG2"><code>MPSKit.DMRG2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DMRG2{A, S, F} &lt;: MPSKit.Algorithm</code></pre><p>Two-site DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for <a href="https://quantumkithub.github.io/TensorKit.jl/stable/lib/tensors/#TensorKit.tsvd">truncation</a> of the two-site update</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/dmrg.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DerivativeOperator" href="#MPSKit.DerivativeOperator"><code>MPSKit.DerivativeOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DerivativeOperator</code></pre><p>Abstract supertype for derivative operators acting on MPS. These operators are used to represent the effective local operators obtained from taking the partial derivative of an MPS-MPO-MPS sandwich.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.DynamicalDMRG" href="#MPSKit.DynamicalDMRG"><code>MPSKit.DynamicalDMRG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DynamicalDMRG{F&lt;:MPSKit.DDMRG_Flavour, S} &lt;: MPSKit.Algorithm</code></pre><p>A dynamical DMRG method for calculating dynamical properties and excited states, based on a variational principle for dynamical correlation functions.</p><p><strong>Fields</strong></p><ul><li><p><code>flavour::MPSKit.DDMRG_Flavour</code>: flavour of the algorithm to use, either of type <a href="#MPSKit.NaiveInvert"><code>NaiveInvert</code></a> or <a href="#MPSKit.Jeckelmann"><code>Jeckelmann</code></a></p></li><li><p><code>solver::Any</code>: algorithm used for the linear solvers</p></li><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#jeckelmann2002">Jeckelmann. Phys. Rev. B 66 (2002)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/propagator/corvector.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.FiniteEnvironments" href="#MPSKit.FiniteEnvironments"><code>MPSKit.FiniteEnvironments</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteEnvironments &lt;: AbstractMPSEnvironments</code></pre><p>Environment manager for <code>FiniteMPS</code> and <code>WindowMPS</code>. This structure is responsable for automatically checking if the queried environment is still correctly cached and if not recalculates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/environments/finite_envs.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.FiniteExcited" href="#MPSKit.FiniteExcited"><code>MPSKit.FiniteExcited</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteExcited{A} &lt;: MPSKit.Algorithm</code></pre><p>Variational optimization algorithm for excitations of finite MPS by minimizing the energy of</p><p class="math-container">\[H - λᵢ |ψᵢ⟩⟨ψᵢ|\]</p><p><strong>Fields</strong></p><ul><li><p><code>gsalg::Any</code>: optimization algorithm</p></li><li><p><code>weight::Float64</code>: energy penalty for enforcing orthogonality with previous states</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/dmrgexcitation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.FiniteMPO" href="#MPSKit.FiniteMPO"><code>MPSKit.FiniteMPO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteMPO(Os::Vector{O}) -&gt; FiniteMPO{O}
FiniteMPO(O::AbstractTensorMap{S,N,N}) where {S,N} -&gt; FiniteMPO{O&lt;:MPOTensor}</code></pre><p>Matrix Product Operator (MPO) acting on a finite tensor product space with a linear order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.FiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}" href="#MPSKit.FiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}"><code>MPSKit.FiniteMPOHamiltonian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteMPOHamiltonian(Ws::Vector{&lt;:Matrix})</code></pre><p>Create a <code>FiniteMPOHamiltonian</code> from a vector of matrices, such that <code>Ws[i][j, k]</code> represents the operator at site <code>i</code>, left level <code>j</code> and right level <code>k</code>. Here, the entries can be either <code>MPOTensor</code>, <code>Missing</code> or <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpohamiltonian.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.FiniteMPS" href="#MPSKit.FiniteMPS"><code>MPSKit.FiniteMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteMPS{A&lt;:GenericMPSTensor,B&lt;:MPSBondTensor} &lt;: AbstractFiniteMPS</code></pre><p>Type that represents a finite Matrix Product State.</p><p><strong>Properties</strong></p><ul><li><code>AL</code> – left-gauged MPS tensors</li><li><code>AR</code> – right-gauged MPS tensors</li><li><code>AC</code> – center-gauged MPS tensors</li><li><code>C</code> – gauge tensors</li><li><code>center</code> – location of the gauge center</li></ul><p>The center property returns <code>center::HalfInt</code> that indicates the location of the MPS center:</p><ul><li><code>isinteger(center)</code> → <code>center</code> is a whole number and indicates the location of the first <code>AC</code> tensor present in the underlying <code>ψ.ACs</code> field.</li><li><code>ishalfodd(center)</code> → <code>center</code> is a half-odd-integer, meaning that there are no <code>AC</code> tensors, and indicating between which sites the bond tensor lives.</li></ul><p>e.g <code>mps.center = 7/2</code> means that the bond tensor is to the right of the 3rd site and can be accessed via <code>mps.C[3]</code>.</p><p><strong>Notes</strong></p><p>By convention, we have that:</p><ul><li><code>AL[i] * C[i]</code> = <code>AC[i]</code> = <code>C[i-1] * AR[i]</code></li><li><code>AL[i]&#39; * AL[i] = 1</code></li><li><code>AR[i] * AR[i]&#39; = 1</code></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">FiniteMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S,CompositeSpace{S}}},
          maxvirtualspaces::Union{S,Vector{S}};
          normalize=true, left=oneunit(S), right=oneunit(S)) where {S&lt;:ElementarySpace}
FiniteMPS([f, eltype], N::Int, physicalspace::Union{S,CompositeSpace{S}},
          maxvirtualspaces::Union{S,Vector{S}};
          normalize=true, left=oneunit(S), right=oneunit(S)) where {S&lt;:ElementarySpace}
FiniteMPS(As::Vector{&lt;:GenericMPSTensor}; normalize=false, overwrite=false)</code></pre><p>Construct an MPS via a specification of physical and virtual spaces, or from a list of tensors <code>As</code>. All cases reduce to the latter. In particular, a state with a non-trivial total charge can be constructed by passing a non-trivially charged vector space as the <code>left</code> or <code>right</code> virtual spaces.</p><p><strong>Arguments</strong></p><ul><li><p><code>As::Vector{&lt;:GenericMPSTensor}</code>: vector of site tensors</p></li><li><p><code>f::Function=rand</code>: initializer function for tensor data</p></li><li><p><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</p></li><li><p><code>physicalspaces::Vector{&lt;:Union{S, CompositeSpace{S}}</code>: list of physical spaces</p></li><li><p><code>N::Int</code>: number of sites</p></li><li><p><code>physicalspace::Union{S,CompositeSpace{S}}</code>: local physical space</p></li><li><p><code>virtualspaces::Vector{&lt;:Union{S, CompositeSpace{S}}</code>: list of virtual spaces</p></li><li><p><code>maxvirtualspace::S</code>: maximum virtual space</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>normalize=true</code>: normalize the constructed state</li><li><code>overwrite=false</code>: overwrite the given input tensors</li><li><code>left=oneunit(S)</code>: left-most virtual space</li><li><code>right=oneunit(S)</code>: right-most virtual space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/finitemps.jl#L1-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.GradientGrassmann" href="#MPSKit.GradientGrassmann"><code>MPSKit.GradientGrassmann</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GradientGrassmann{O&lt;:OptimKit.OptimizationAlgorithm, F} &lt;: MPSKit.Algorithm</code></pre><p>Variational gradient-based optimization algorithm that keeps the MPS in left-canonical form, as points on a Grassmann manifold. The optimization is then a Riemannian gradient descent  with a preconditioner to induce the metric from the Hilbert space inner product.</p><p><strong>Fields</strong></p><ul><li><p><code>method::OptimKit.OptimizationAlgorithm</code>: optimization algorithm</p></li><li><p><code>finalize!::Any</code>: callback function applied after each iteration, of signature <code>finalize!(x, f, g, numiter) -&gt; x, f, g</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#hauru2021">Hauru et al. SciPost Phys. 10 (2021)</a></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">GradientGrassmann(; kwargs...)</code></pre><p><strong>Keywords</strong></p><ul><li><code>method=ConjugateGradient</code>: instance of optimization algorithm, or type of optimization   algorithm to construct</li><li><code>finalize!</code>: finalizer algorithm</li><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: level of information display</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/gradient_grassmann.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.IDMRG" href="#MPSKit.IDMRG"><code>MPSKit.IDMRG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IDMRG{A} &lt;: MPSKit.Algorithm</code></pre><p>Single site infinite DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the MPS</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/idmrg.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.IDMRG2" href="#MPSKit.IDMRG2"><code>MPSKit.IDMRG2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IDMRG2{A, S} &lt;: MPSKit.Algorithm</code></pre><p>Two-site infinite DMRG algorithm for finding the dominant eigenvector.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the MPS</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for <a href="https://quantumkithub.github.io/TensorKit.jl/stable/lib/tensors/#TensorKit.tsvd">truncation</a> of the two-site update</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/idmrg.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.InfiniteEnvironments" href="#MPSKit.InfiniteEnvironments"><code>MPSKit.InfiniteEnvironments</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteEnvironments &lt;: AbstractMPSEnvironments</code></pre><p>Environments for an infinite MPS-MPO-MPS combination. These solve the corresponding fixedpoint equations:</p><p class="math-container">\[GLs[i] * T_LL[i] = λ GLs[i + 1]
T_RR[i] * GRs[i] = λ GRs[i - 1]\]</p><p>where <code>T_LL</code> and <code>T_RR</code> are the (regularized) transfer matrix operators on a give site for <code>AL-O-AL</code> and <code>AR-O-AR</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/environments/infinite_envs.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.InfiniteMPO" href="#MPSKit.InfiniteMPO"><code>MPSKit.InfiniteMPO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteMPO(Os::PeriodicVector{O}) -&gt; InfiniteMPO{O}</code></pre><p>Matrix Product Operator (MPO) acting on an infinite tensor product space with a linear order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.InfiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}" href="#MPSKit.InfiniteMPOHamiltonian-Tuple{Vector{&lt;:Matrix}}"><code>MPSKit.InfiniteMPOHamiltonian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteMPOHamiltonian(Ws::Vector{&lt;:Matrix})</code></pre><p>Create a <code>InfiniteMPOHamiltonian</code> from a vector of matrices, such that <code>Ws[i][j, k]</code> represents the the operator at site <code>i</code>, left level <code>j</code> and right level <code>k</code>. Here, the entries can be either <code>MPOTensor</code>, <code>Missing</code> or <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpohamiltonian.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.InfiniteMPS" href="#MPSKit.InfiniteMPS"><code>MPSKit.InfiniteMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteMPS{A&lt;:GenericMPSTensor,B&lt;:MPSBondTensor} &lt;: AbtractMPS</code></pre><p>Type that represents an infinite Matrix Product State.</p><p><strong>Fields</strong></p><ul><li><code>AL</code> – left-gauged MPS tensors</li><li><code>AR</code> – right-gauged MPS tensors</li><li><code>AC</code> – center-gauged MPS tensors</li><li><code>C</code> – gauge tensors</li></ul><p><strong>Notes</strong></p><p>By convention, we have that:</p><ul><li><code>AL[i] * C[i]</code> = <code>AC[i]</code> = <code>C[i-1] * AR[i]</code></li><li><code>AL[i]&#39; * AL[i] = 1</code></li><li><code>AR[i] * AR[i]&#39; = 1</code></li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">InfiniteMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S, CompositeSpace{S}},
            virtualspaces::Vector{&lt;:Union{S, CompositeSpace{S}};
            kwargs...) where {S&lt;:ElementarySpace}
InfiniteMPS(As::AbstractVector{&lt;:GenericMPSTensor}; kwargs...)
InfiniteMPS(ALs::AbstractVector{&lt;:GenericMPSTensor}, C₀::MPSBondTensor;
            kwargs...)</code></pre><p>Construct an MPS via a specification of physical and virtual spaces, or from a list of tensors <code>As</code>, or a list of left-gauged tensors <code>ALs</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>As::AbstractVector{&lt;:GenericMPSTensor}</code>: vector of site tensors</p></li><li><p><code>ALs::AbstractVector{&lt;:GenericMPSTensor}</code>: vector of left-gauged site tensors</p></li><li><p><code>C₀::MPSBondTensor</code>: initial gauge tensor</p></li><li><p><code>f::Function=rand</code>: initializer function for tensor data</p></li><li><p><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</p></li><li><p><code>physicalspaces::AbstractVector{&lt;:Union{S, CompositeSpace{S}}</code>: list of physical spaces</p></li><li><p><code>virtualspaces::AbstractVector{&lt;:Union{S, CompositeSpace{S}}</code>: list of virtual spaces</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>tol</code>: gauge fixing tolerance</li><li><code>maxiter</code>: gauge fixing maximum iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.InfiniteQPEnvironments" href="#MPSKit.InfiniteQPEnvironments"><code>MPSKit.InfiniteQPEnvironments</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteQPEnvironments &lt;: AbstractMPSEnvironments</code></pre><p>Environments for an infinite QP-MPO-QP combination. These solve the corresponding fixedpoint equations:</p><p class="math-container">\[GLs[i] * T_BL[i] + GBLs[i] * T_RL[i] = GBLs[i + 1]
T_BR[i] * GRs[i] + T_LR[i] * GBRs[i] = GBRs[i - 1]\]</p><p>where <code>T_BL</code>, <code>T_BR</code>, <code>T_RL</code> and <code>T_LR</code> are the (regularized) transfer matrix operators on a given site for <code>B-O-AL</code>, <code>B-O-AR</code>, <code>AR-O-AL</code> and <code>AL-O-AR</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/environments/qp_envs.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.Jeckelmann" href="#MPSKit.Jeckelmann"><code>MPSKit.Jeckelmann</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Jeckelmann &lt;: MPSKit.DDMRG_Flavour</code></pre><p>The original flavour of dynamical DMRG, which minimizes the following (quadratic) cost function:</p><p class="math-container">\[|| (H - E) |ψ₀⟩ - |ψ⟩ ||\]</p><p>See also <a href="#MPSKit.NaiveInvert"><code>NaiveInvert</code></a> for a less costly but less accurate alternative.</p><p><strong>References</strong></p><ul><li><a href="../../references/#jeckelmann2002">Jeckelmann. Phys. Rev. B 66 (2002)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/propagator/corvector.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.JordanMPOTensor" href="#MPSKit.JordanMPOTensor"><code>MPSKit.JordanMPOTensor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JordanMPOTensor{E,S,TA,TB,TC,TD} &lt;: AbstractBlockTensorMap{E,S,2,2}</code></pre><p>A tensor map that represents the upper triangular block form of a matrix product operator (MPO).</p><p class="math-container">\[\begin{pmatrix}
1 &amp; C &amp; D \\
0 &amp; A &amp; B \\
0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/jordanmpotensor.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.JordanMPO_AC2_Hamiltonian" href="#MPSKit.JordanMPO_AC2_Hamiltonian"><code>MPSKit.JordanMPO_AC2_Hamiltonian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JordanMPO_AC2_Hamiltonian{O1,O2,O3,O4}</code></pre><p>Efficient operator for representing the single-site derivative of a <code>MPOHamiltonian</code> sandwiched between two MPSs. In particular, this operator aims to make maximal use of the structure of the <code>MPOHamiltonian</code> to reduce the number of operations required to apply the operator to a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/hamiltonian_derivatives.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.JordanMPO_AC_Hamiltonian" href="#MPSKit.JordanMPO_AC_Hamiltonian"><code>MPSKit.JordanMPO_AC_Hamiltonian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JordanMPO_AC_Hamiltonian{O1,O2,O3}</code></pre><p>Efficient operator for representing the single-site derivative of a <code>MPOHamiltonian</code> sandwiched between two MPSs. In particular, this operator aims to make maximal use of the structure of the <code>MPOHamiltonian</code> to reduce the number of operations required to apply the operator to a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/hamiltonian_derivatives.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.LazySum" href="#MPSKit.LazySum"><code>MPSKit.LazySum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LazySum{O} &lt;: AbstractVector{O}</code></pre><p>Type that represents a lazy sum i.e explicit summation is only done when needed.  This type is basically an <code>AbstractVector</code> with some extra functionality to calculate things efficiently.</p><p><strong>Fields</strong></p><ul><li>ops – Vector of summable objects</li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">LazySum(x::Vector)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/lazysum.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.LeftCanonical" href="#MPSKit.LeftCanonical"><code>MPSKit.LeftCanonical</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LeftCanonical &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for bringing an <code>InfiniteMPS</code> into the left-canonical form.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_orth::Any</code>: algorithm used for orthogonalization of the tensors</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigensolver</p></li><li><p><code>eig_miniter::Int64</code>: minimal amount of iterations before using the eigensolver steps</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/ortho.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPO" href="#MPSKit.MPO"><code>MPSKit.MPO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MPO{O,V&lt;:AbstractVector{O}} &lt;: AbstractMPO{O}</code></pre><p>Matrix Product Operator (MPO) acting on a tensor product space with a linear order.</p><p>See also: <a href="../../man/operators/#FiniteMPO"><code>FiniteMPO</code></a>, <a href="../../man/operators/#InfiniteMPO"><code>InfiniteMPO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPODerivativeOperator" href="#MPSKit.MPODerivativeOperator"><code>MPSKit.MPODerivativeOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MPODerivativeOperator{L,O&lt;:Tuple,R}</code></pre><p>Effective local operator obtained from taking the partial derivative of an MPS-MPO-MPS sandwich.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/mpo_derivatives.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPOHamiltonian" href="#MPSKit.MPOHamiltonian"><code>MPSKit.MPOHamiltonian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPOHamiltonian(lattice::AbstractArray{&lt;:VectorSpace}, local_operators...)
MPOHamiltonian(lattice::AbstractArray{&lt;:VectorSpace})
MPOHamiltonian(x::AbstractArray{&lt;:Any,3})</code></pre><p>MPO representation of a hamiltonian. This is a specific form of an <a href="#MPSKit.AbstractMPO"><code>AbstractMPO</code></a>, where all the sites are represented by an upper triangular block matrix of the following form:</p><p class="math-container">\[\begin{pmatrix}
1 &amp; C &amp; D \\
0 &amp; A &amp; B \\
0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p>where <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> are <code>MPOTensor</code>s, or (sparse) blocks thereof.</p><p><strong>Examples</strong></p><p>For example, constructing a nearest-neighbour Hamiltonian would look like this:</p><pre><code class="language-julia hljs">lattice = fill(ℂ^2, 10)
H = MPOHamiltonian(lattice, (i, i+1) =&gt; O for i in 1:length(lattice)-1)</code></pre><p>See also <a href="#MPSKit.instantiate_operator-Tuple{MPSKit.AbstractMPS, Pair}"><code>instantiate_operator</code></a>, which is responsable for instantiating the local operators in a form that is compatible with this constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpohamiltonian.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPOTensor" href="#MPSKit.MPOTensor"><code>MPSKit.MPOTensor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPOTensor{S}</code></pre><p>Tensor type for representing local MPO tensors, with the index convention <code>W ⊗ S ← N ⊗ E</code>, where <code>N</code>, <code>E</code>, <code>S</code> and <code>W</code> denote the north, east, south and west virtual spaces respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPSTensor" href="#MPSKit.MPSTensor"><code>MPSKit.MPSTensor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPSTensor([f, eltype], d::Int, Dₗ::Int, [Dᵣ]::Int])</code></pre><p>Construct an <code>MPSTensor</code> with given physical and virtual dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function=rand</code>: initializer function for tensor data</li><li><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</li><li><code>d::Int</code>: physical dimension</li><li><code>Dₗ::Int</code>: left virtual dimension</li><li><code>Dᵣ::Int</code>: right virtual dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPSTensor-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number" href="#MPSKit.MPSTensor-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number"><code>MPSKit.MPSTensor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPSTensor(A::AbstractArray)</code></pre><p>Convert an array to an <code>MPSTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MPSTensor-Union{Tuple{S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S, S}} where S&lt;:TensorKit.ElementarySpace" href="#MPSKit.MPSTensor-Union{Tuple{S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S}, Tuple{UndefInitializer, Any, Union{TensorKit.CompositeSpace{S}, S}, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>MPSKit.MPSTensor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPSTensor([f, eltype], d::Int, left_D::Int, [right_D]::Int])
MPSTensor([f, eltype], physicalspace::Union{S,CompositeSpace{S}}, 
          left_virtualspace::S, [right_virtualspace]::S) where {S&lt;:ElementarySpace}</code></pre><p>Construct an <code>MPSTensor</code> with given physical and virtual spaces.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function=rand</code>: initializer function for tensor data</p></li><li><p><code>eltype::Type{&lt;:Number}=ComplexF64</code>: scalar type of tensors</p></li><li><p><code>physicalspace::Union{S,CompositeSpace{S}}</code>: physical space</p></li><li><p><code>left_virtualspace::S</code>: left virtual space</p></li><li><p><code>right_virtualspace::S</code>: right virtual space, defaults to equal left</p></li><li><p><code>d::Int</code>: physical dimension</p></li><li><p><code>left_D::Int</code>: left virtual dimension</p></li><li><p><code>right_D::Int</code>: right virtual dimension</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MixedCanonical" href="#MPSKit.MixedCanonical"><code>MPSKit.MixedCanonical</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MixedCanonical &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for bringing an <code>InfiniteMPS</code> into the mixed-canonical form.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_leftcanonical::MPSKit.LeftCanonical</code>: algorithm for bringing an <code>InfiniteMPS</code> into left-canonical form.</p></li><li><p><code>alg_rightcanonical::MPSKit.RightCanonical</code>: algorithm for bringing an <code>InfiniteMPS</code> into right-canonical form.</p></li><li><p><code>order::Symbol</code>: order in which to apply the canonicalizations, should be <code>:L</code>, <code>:R</code>, <code>:LR</code> or <code>:RL</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/ortho.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.Multiline" href="#MPSKit.Multiline"><code>MPSKit.Multiline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Multiline{T}</code></pre><p>Object that represents multiple lines of objects of type <code>T</code>. Typically used to represent multiple lines of <code>InfiniteMPS</code> (<code>MultilineMPS</code>) or MPO (<code>Multiline{&lt;:AbstractMPO}</code>).</p><p><strong>Fields</strong></p><ul><li><code>data::PeriodicArray{T,1}</code>: the data of the multiline object</li></ul><p>See also: <a href="../../man/states/#MultilineMPS"><code>MultilineMPS</code></a> and <a href="#MPSKit.MultilineMPO"><code>MultilineMPO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/multiline.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MultilineMPO" href="#MPSKit.MultilineMPO"><code>MPSKit.MultilineMPO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const MultilineMPO = Multiline{&lt;:AbstractMPO}</code></pre><p>Type that represents multiple lines of <code>MPO</code> objects.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">MultilineMPO(mpos::AbstractVector{&lt;:Union{SparseMPO,DenseMPO}})
MultilineMPO(Os::AbstractMatrix{&lt;:MPOTensor})</code></pre><p>See also: <a href="#MPSKit.Multiline"><code>Multiline</code></a>, <a href="#MPSKit.AbstractMPO"><code>AbstractMPO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/multilinempo.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MultilineMPS" href="#MPSKit.MultilineMPS"><code>MPSKit.MultilineMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const MultilineMPS = Multiline{&lt;:InfiniteMPS}</code></pre><p>Type that represents multiple lines of <code>InfiniteMPS</code> objects.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">MultilineMPS(mpss::AbstractVector{&lt;:InfiniteMPS})
MultilineMPS([f, eltype], physicalspaces::Matrix{&lt;:Union{S, CompositeSpace{S}},
             virtualspaces::Matrix{&lt;:Union{S, CompositeSpace{S}}) where
             {S&lt;:ElementarySpace}
MultilineMPS(As::AbstractMatrix{&lt;:GenericMPSTensor}; kwargs...)
MultilineMPS(ALs::AbstractMatrix{&lt;:GenericMPSTensor}, 
             C₀::AbstractVector{&lt;:MPSBondTensor}; kwargs...)</code></pre><p>See also: <a href="#MPSKit.Multiline"><code>Multiline</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/multilinemps.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.MultipliedOperator" href="#MPSKit.MultipliedOperator"><code>MPSKit.MultipliedOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Structure representing a multiplied operator. Consists of
    - An operator op (MPO, Hamiltonian, ...)
    - An object f that gets multiplied with the operator (Number, function, ...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/multipliedoperator.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.NaiveInvert" href="#MPSKit.NaiveInvert"><code>MPSKit.NaiveInvert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NaiveInvert &lt;: MPSKit.DDMRG_Flavour</code></pre><p>An alternative approach to the dynamical DMRG algorithm, without quadratic terms but with a less controlled approximation. This algorithm minimizes the following cost function</p><p class="math-container">\[⟨ψ|(H - E)|ψ⟩ - ⟨ψ|ψ₀⟩ - ⟨ψ₀|ψ⟩\]</p><p>which is equivalent to the original approach if</p><p class="math-container">\[|ψ₀⟩ = (H - E)|ψ⟩\]</p><p>See also <a href="#MPSKit.Jeckelmann"><code>Jeckelmann</code></a> for the original approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/propagator/corvector.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.OptimalExpand" href="#MPSKit.OptimalExpand"><code>MPSKit.OptimalExpand</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct OptimalExpand{S} &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that expands the given mps as described in <a href="../../references/#zauner-stauber2018">Zauner-Stauber et al. Phys. Rev. B 97 (2018)</a>, by selecting the dominant contributions of a two-site updated MPS tensor, orthogonal to the original ψ.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for truncating the expanded space</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/changebonds/optimalexpand.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.PeriodicArray" href="#MPSKit.PeriodicArray"><code>MPSKit.PeriodicArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicArray{T,N} &lt;: AbstractArray{T,N}</code></pre><p>Array wrapper with periodic boundary conditions.</p><p><strong>Fields</strong></p><ul><li><code>data::Array{T,N}</code>: the data of the array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = PeriodicArray([1, 2, 3])
A[0], A[2], A[4]

# output

(3, 2, 1)</code></pre><pre><code class="language-julia hljs">A = PeriodicArray([1 2; 3 4])
A[-1, 1], A[1, 1], A[4, 5]

# output

(1, 1, 3)</code></pre><p>See also <a href="#MPSKit.PeriodicVector"><code>PeriodicVector</code></a>, <a href="#MPSKit.PeriodicMatrix"><code>PeriodicMatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/periodicarray.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.PeriodicMatrix" href="#MPSKit.PeriodicMatrix"><code>MPSKit.PeriodicMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicMatrix{T}</code></pre><p>Two-dimensional dense array with elements of type <code>T</code> and periodic boundary conditions. Alias for <a href="#MPSKit.PeriodicArray"><code>PeriodicArray{T,2}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/periodicarray.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.PeriodicVector" href="#MPSKit.PeriodicVector"><code>MPSKit.PeriodicVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicVector{T}</code></pre><p>One-dimensional dense array with elements of type <code>T</code> and periodic boundary conditions. Alias for <a href="#MPSKit.PeriodicArray"><code>PeriodicArray{T,1}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/periodicarray.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.QuasiparticleAnsatz" href="#MPSKit.QuasiparticleAnsatz"><code>MPSKit.QuasiparticleAnsatz</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct QuasiparticleAnsatz{A, E} &lt;: MPSKit.Algorithm</code></pre><p>Optimization algorithm for quasi-particle excitations on top of MPS groundstates.</p><p><strong>Fields</strong></p><ul><li><p><code>alg::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_environments::Any</code>: algorithm used for the quasiparticle environments</p></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">QuasiparticleAnsatz()
QuasiparticleAnsatz(; kwargs...)
QuasiparticleAnsatz(alg)</code></pre><p>Create a <code>QuasiparticleAnsatz</code> algorithm with the given algorithm, or by passing the  keyword arguments to <code>Arnoldi</code>.</p><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2013">Haegeman et al. Phys. Rev. Let. 111 (2013)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/quasiparticleexcitation.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.RandExpand" href="#MPSKit.RandExpand"><code>MPSKit.RandExpand</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct RandExpand{S} &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that expands the bond dimension by adding random unitary vectors that are orthogonal to the existing state. This is achieved by performing a truncated SVD on a random two-site MPS tensor, which is made orthogonal to the existing state.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for [truncation](@extref TensorKit.tsvd] the expanded space</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/changebonds/randexpand.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.RightCanonical" href="#MPSKit.RightCanonical"><code>MPSKit.RightCanonical</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct RightCanonical &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for bringing an <code>InfiniteMPS</code> into the right-canonical form.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_orth::Any</code>: algorithm used for orthogonalization of the tensors</p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigensolver</p></li><li><p><code>eig_miniter::Int64</code>: minimal amount of iterations before using the eigensolver steps</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/ortho.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.SvdCut" href="#MPSKit.SvdCut"><code>MPSKit.SvdCut</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SvdCut{S} &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that uses truncated SVD to change the bond dimension of a state or operator. This is achieved by a sweeping algorithm that locally performs (optimal) truncations in a gauged basis.</p><p>See also <a href="../../man/algorithms/#changebonds"><code>changebonds(!)</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for [truncation][@extref TensorKit.tsvd] of the gauge tensors</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#parker2020">Parker et al. Phys. Rev. B 102 (2020)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/changebonds/svdcut.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TDVP" href="#MPSKit.TDVP"><code>MPSKit.TDVP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TDVP{A, F} &lt;: MPSKit.Algorithm</code></pre><p>Single site MPS time-evolution algorithm based on the Time-Dependent Variational Principle.</p><p><strong>Fields</strong></p><ul><li><p><code>integrator::Any</code>: algorithm used in the exponential solvers</p></li><li><p><code>tolgauge::Float64</code>: tolerance for gauging algorithm</p></li><li><p><code>gaugemaxiter::Int64</code>: maximal amount of iterations for gauging algorithm</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2011">Haegeman et al. Phys. Rev. Lett. 107 (2011)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/tdvp.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TDVP2" href="#MPSKit.TDVP2"><code>MPSKit.TDVP2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TDVP2{A, S, F} &lt;: MPSKit.Algorithm</code></pre><p>Two-site MPS time-evolution algorithm based on the Time-Dependent Variational Principle.</p><p><strong>Fields</strong></p><ul><li><p><code>integrator::Any</code>: algorithm used in the exponential solvers</p></li><li><p><code>tolgauge::Float64</code>: tolerance for gauging algorithm</p></li><li><p><code>gaugemaxiter::Int64</code>: maximal amount of iterations for gauging algorithm</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for truncation of the two-site update</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#haegeman2011">Haegeman et al. Phys. Rev. Lett. 107 (2011)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/tdvp.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TaylorCluster" href="#MPSKit.TaylorCluster"><code>MPSKit.TaylorCluster</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TaylorCluster &lt;: MPSKit.Algorithm</code></pre><p>Algorithm for constructing the <code>N</code>th order time evolution MPO using the Taylor cluster expansion.</p><p><strong>Fields</strong></p><ul><li><p><code>N::Int64</code>: order of the Taylor expansion</p></li><li><p><code>extension::Bool</code>: include higher-order corrections</p></li><li><p><code>compression::Bool</code>: approximate compression of corrections, accurate up to order <code>N</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#vandamme2024">Van Damme et al. SciPost Phys. 17 (2024)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/taylorcluster.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.TimedOperator" href="#MPSKit.TimedOperator"><code>MPSKit.TimedOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Structure representing a time-dependent operator. Consists of
    - An operator op (MPO, Hamiltonian, ...)
    - An function f that gives the time-dependence according to op(t) = f(t)*op</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/multipliedoperator.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.UnionAlg" href="#MPSKit.UnionAlg"><code>MPSKit.UnionAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct UnionAlg{A, B} &lt;: MPSKit.Algorithm</code></pre><p>Algorithm wrapper representing the sequential application of two algorithms.</p><p><strong>Fields</strong></p><ul><li><p><code>alg1::Any</code>: first algorithm</p></li><li><p><code>alg2::Any</code>: second algorithm</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/unionalg.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.UntimedOperator" href="#MPSKit.UntimedOperator"><code>MPSKit.UntimedOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Structure representing a time-independent operator that will be multiplied with a constant coefficient. Consists of
    - An operator (MPO, Hamiltonian, ...)
    - A number f that gets multiplied with the operator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/multipliedoperator.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.VOMPS" href="#MPSKit.VOMPS"><code>MPSKit.VOMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VOMPS{F} &lt;: MPSKit.Algorithm</code></pre><p>Power method algorithm for finding dominant eigenvectors of infinite MPOs. This method works by iteratively approximating the product of an operator and a state with a new state of the same bond dimension.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_environments::Any</code>: algorithm used for the MPS environments</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#vanhecke2021">Vanhecke et al. SciPost Phys. Core 4 (2021)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/statmech/vomps.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.VUMPS" href="#MPSKit.VUMPS"><code>MPSKit.VUMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VUMPS{F} &lt;: MPSKit.Algorithm</code></pre><p>Variational optimization algorithm for uniform matrix product states, based on the combination of DMRG with matrix product state tangent space concepts.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal amount of iterations</p></li><li><p><code>verbosity::Int64</code>: setting for how much information is displayed</p></li><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_environments::Any</code>: algorithm used for the MPS environments</p></li><li><p><code>finalize::Any</code>: callback function applied after each iteration, of signature <code>finalize(iter, ψ, H, envs) -&gt; ψ, envs</code></p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#zauner-stauber2018">Zauner-Stauber et al. Phys. Rev. B 97 (2018)</a></li><li><a href="../../references/#vanderstraeten2019">Vanderstraeten et al. SciPost Phys. Lect. Notes 7 (2019)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/vumps.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.VUMPSSvdCut" href="#MPSKit.VUMPSSvdCut"><code>MPSKit.VUMPSSvdCut</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VUMPSSvdCut &lt;: MPSKit.Algorithm</code></pre><p>An algorithm that uses a two-site update step to change the bond dimension of a state.</p><p><strong>Fields</strong></p><ul><li><p><code>alg_gauge::Any</code>: algorithm used for gauging the <code>InfiniteMPS</code></p></li><li><p><code>alg_eigsolve::Any</code>: algorithm used for the eigenvalue solvers</p></li><li><p><code>alg_svd::Any</code>: algorithm used for the singular value decomposition</p></li><li><p><code>trscheme::TensorKit.TruncationScheme</code>: algorithm used for [truncation][@extref TensorKit.tsvd] of the two-site update</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/changebonds/vumpssvd.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.WII" href="#MPSKit.WII"><code>MPSKit.WII</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct WII &lt;: MPSKit.Algorithm</code></pre><p>Generalization of the Euler approximation of the operator exponential for MPOs.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: tolerance for convergence criterium</p></li><li><p><code>maxiter::Int64</code>: maximal number of iterations</p></li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#zaletel2015">Zaletel et al. Phys. Rev. B 91 (2015)</a></li><li><a href="../../references/#paeckel2019">Paeckel et al. Ann. of Phys. 411 (2019)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/wii.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.WindowArray" href="#MPSKit.WindowArray"><code>MPSKit.WindowArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowArray{T} &lt;: AbstractVector{T}</code></pre><p>A vector embedded in a periodic environment to the left and right, which can be accessed with arbitrary integer indices. The <code>middle</code> part is a regular <code>Vector{T}</code> and the <code>left</code> and <code>right</code> parts are <code>PeriodicVector{T}</code>s.</p><p>This vector inherits most of its properties from the middle part, including its length and axes. Nevertheless, indexing operations are overloaded to allow for out-of-bounds access, which is resolved by the periodic enviroments.</p><p>See also <a href="#MPSKit.PeriodicVector"><code>PeriodicVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/windowarray.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.WindowMPS" href="#MPSKit.WindowMPS"><code>MPSKit.WindowMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowMPS{A&lt;:GenericMPSTensor,B&lt;:MPSBondTensor} &lt;: AbstractFiniteMPS</code></pre><p>Type that represents a finite Matrix Product State embedded in an infinte Matrix Product State.</p><p><strong>Fields</strong></p><ul><li><code>left_gs::InfiniteMPS</code> – left infinite environment</li><li><code>window::FiniteMPS</code> – finite window Matrix Product State</li><li><code>right_gs::InfiniteMPS</code> – right infinite environment</li></ul><hr/><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">WindowMPS(left_gs::InfiniteMPS, window_state::FiniteMPS, [right_gs::InfiniteMPS])
WindowMPS(left_gs::InfiniteMPS, window_tensors::AbstractVector, [right_gs::InfiniteMPS])
WindowMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S, CompositeSpace{S}},
          virtualspaces::Vector{&lt;:Union{S, CompositeSpace{S}}, left_gs::InfiniteMPS,
          [right_gs::InfiniteMPS])
WindowMPS([f, eltype], physicalspaces::Vector{&lt;:Union{S,CompositeSpace{S}}},
          maxvirtualspace::S, left_gs::InfiniteMPS, [right_gs::InfiniteMPS])</code></pre><p>Construct a WindowMPS via a specification of left and right infinite environment, and either a window state or a vector of tensors to construct the window. Alternatively, it is possible to supply the same arguments as for the constructor of <a href="../../man/states/#FiniteMPS"><code>FiniteMPS</code></a>, followed by a left (and right) environment to construct the WindowMPS in one step.</p><div class="admonition is-info" id="Note-89571cb4302699ad"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-89571cb4302699ad" title="Permalink"></a></header><div class="admonition-body"><p>By default, the right environment is chosen to be equal to the left, however no copy is made. In this case, changing the left state will also affect the right state.</p><p>WindowMPS(state::InfiniteMPS, L::Int)</p></div></div><p>Construct a WindowMPS from an InfiniteMPS, by promoting a region of length <code>L</code> to a <code>FiniteMPS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/windowmps.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AC2" href="#MPSKit.AC2"><code>MPSKit.AC2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AC2(ψ::AbstractMPS, i; kind=:ACAR)</code></pre><p>Obtain the two-site (center) gauge tensor at site <code>i</code> of the MPS <code>ψ</code>. If this hasn&#39;t been computed before, this can be computed as:</p><ul><li><code>kind=:ACAR</code> : AC[i] * AR[i+1]</li><li><code>kind=:ALAC</code> : AL[i] * AC[i+1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L134-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AC2_hamiltonian" href="#MPSKit.AC2_hamiltonian"><code>MPSKit.AC2_hamiltonian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AC2_hamiltonian(site, below, operator, above, envs)</code></pre><p>Effective two-site local operator acting at <code>site</code>.</p><pre><code class="nohighlight hljs"> ┌──        ──┐ 
 │   │    │   │ 
┌┴┐┌─┴─┐┌─┴─┐┌┴┐
│ ├┤   ├┤   ├┤ │
└┬┘└─┬─┘└─┬─┘└┬┘
 │   │    │   │ 
 └──        ──┘ </code></pre><p>See also <a href="#MPSKit.AC2_projection"><code>AC2_projection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AC2_projection" href="#MPSKit.AC2_projection"><code>MPSKit.AC2_projection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AC2_projection(site, below, operator, above, envs)</code></pre><p>Application of the effective two-site local operator at a given site.</p><pre><code class="nohighlight hljs">    ┌──────┐    
 ┌──┤      ├──┐ 
 │  └┬────┬┘  │ 
┌┴┐┌─┴─┐┌─┴─┐┌┴┐
│ ├┤   ├┤   ├┤ │
└┬┘└─┬─┘└─┬─┘└┬┘
 │   │    │   │ 
 └──        ──┘ </code></pre><p>See also <a href="#MPSKit.AC2_hamiltonian"><code>AC2_hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L145-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AC_hamiltonian" href="#MPSKit.AC_hamiltonian"><code>MPSKit.AC_hamiltonian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AC_hamiltonian(site, below, operator, above, envs)::DerivativeOperator</code></pre><p>Effective one-site local operator acting at <code>site</code>.</p><pre><code class="nohighlight hljs"> ┌───   ───┐ 
 │    │    │ 
┌┴┐ ┌─┴─┐ ┌┴┐
│ ├─┤   ├─┤ │
└┬┘ └─┬─┘ └┬┘
 │    │    │ 
 └───   ───┘ </code></pre><p>See also <a href="#MPSKit.AC_projection"><code>AC_projection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L34-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.AC_projection" href="#MPSKit.AC_projection"><code>MPSKit.AC_projection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AC_projection(site, below, operator, above, envs)</code></pre><p>Application of the effective one-site local operator at a given site.</p><pre><code class="nohighlight hljs">    ┌───┐    
 ┌──┤   ├──┐ 
 │  └─┬─┘  │ 
┌┴┐ ┌─┴─┐ ┌┴┐
│ ├─┤   ├─┤ │
└┬┘ └─┬─┘ └┬┘
 │    │    │ 
 └──     ──┘ </code></pre><p>See also <a href="#MPSKit.AC_hamiltonian"><code>AC_hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L126-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.C_hamiltonian" href="#MPSKit.C_hamiltonian"><code>MPSKit.C_hamiltonian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">C_hamiltonian(site, below, operator, above, envs)::DerivativeOperator</code></pre><p>Effective zero-site local operator acting at <code>site</code>.</p><pre><code class="nohighlight hljs"> ┌─   ─┐ 
 │     │ 
┌┴┐   ┌┴┐
│ ├───┤ │
└┬┘   └┬┘
 │     │ 
 └─   ─┘ </code></pre><p>See also <a href="#MPSKit.C_projection"><code>C_projection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L16-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.C_projection" href="#MPSKit.C_projection"><code>MPSKit.C_projection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">C_projection(site, below, operator, above, envs)</code></pre><p>Application of the effective zero-site local operator at a given site.</p><pre><code class="nohighlight hljs">   ┌─┐   
 ┌─┤ ├─┐ 
 │ └─┘ │ 
┌┴┐   ┌┴┐
│ ├───┤ │
└┬┘   └┬┘
 │     │ 
 └─   ─┘ </code></pre><p>See also <a href="#MPSKit.C_hamiltonian"><code>C_hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/derivatives/derivatives.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit._gaugecenter-Tuple{FiniteMPS}" href="#MPSKit._gaugecenter-Tuple{FiniteMPS}"><code>MPSKit._gaugecenter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_gaugecenter(ψ::FiniteMPS)::HalfInt</code></pre><p>Return the location of the MPS center.</p><p><code>center::HalfInt</code>:</p><ul><li><code>isinteger(center)</code> → <code>center</code> is a whole number and indicates the location of the first <code>AC</code> tensor present in <code>ψ.ACs</code></li><li><code>ishalfodd(center)</code> → <code>center</code> is a half-odd-integer, meaning that there are no <code>AC</code> tensors, and indicating between which sites the bond tensor lives.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ψ = FiniteMPS(3, ℂ^2, ℂ^16)
ψ.center # returns 7/2, bond tensor is to the right of the 3rd site
ψ.AC[1]   # moves center to first site
ψ.center # returns 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/finitemps.jl#L176-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.add_util_leg-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N1, N2}}, Tuple{N2}, Tuple{N1}, Tuple{S}, Tuple{T}} where {T, S, N1, N2}" href="#MPSKit.add_util_leg-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N1, N2}}, Tuple{N2}, Tuple{N1}, Tuple{S}, Tuple{T}} where {T, S, N1, N2}"><code>MPSKit.add_util_leg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_util_leg(tensor::AbstractTensorMap{S,N1,N2}) where {S,N1,N2}
    -&gt; AbstractTensorMap{S,N1+1,N2+1}</code></pre><p>Add trivial one-dimensional utility spaces with trivial sector to the left and right of a given tensor map, i.e. as the first space of the codomain and the last space of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/utility.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.approx_angles-Tuple{Any}" href="#MPSKit.approx_angles-Tuple{Any}"><code>MPSKit.approx_angles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Find the closest fractions of π, differing at most <code>tol_angle</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L132-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.approximate" href="#MPSKit.approximate"><code>MPSKit.approximate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approximate(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)
approximate!(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)</code></pre><p>Compute an approximation to the application of an operator <code>O</code> to the state <code>ψ</code> in the form of an MPS <code>ψ₀</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess of the approximated state</li><li><code>(O::AbstractMPO, ψ::AbstractMPS)</code>: operator <code>O</code> and state <code>ψ</code> to be approximated</li><li><code>algorithm</code>: approximation algorithm. See below for a list of available algorithms.</li><li><code>[environments]</code>: MPS environment manager</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Algorithms</strong></p><ul><li><p><code>DMRG</code>: Alternating least square method for maximizing the fidelity with a single-site scheme.</p></li><li><p><code>DMRG2</code>: Alternating least square method for maximizing the fidelity with a two-site scheme.</p></li><li><p><code>IDMRG</code>: Variant of <code>DMRG</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>IDMRG2</code>: Variant of <code>DMRG2</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>VOMPS</code>: Tangent space method for truncating uniform MPS.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/approximate/approximate.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.approximate!" href="#MPSKit.approximate!"><code>MPSKit.approximate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approximate(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)
approximate!(ψ₀, (O, ψ), algorithm, [environments]; kwargs...) -&gt; (ψ, environments)</code></pre><p>Compute an approximation to the application of an operator <code>O</code> to the state <code>ψ</code> in the form of an MPS <code>ψ₀</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess of the approximated state</li><li><code>(O::AbstractMPO, ψ::AbstractMPS)</code>: operator <code>O</code> and state <code>ψ</code> to be approximated</li><li><code>algorithm</code>: approximation algorithm. See below for a list of available algorithms.</li><li><code>[environments]</code>: MPS environment manager</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Algorithms</strong></p><ul><li><p><code>DMRG</code>: Alternating least square method for maximizing the fidelity with a single-site scheme.</p></li><li><p><code>DMRG2</code>: Alternating least square method for maximizing the fidelity with a two-site scheme.</p></li><li><p><code>IDMRG</code>: Variant of <code>DMRG</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>IDMRG2</code>: Variant of <code>DMRG2</code> for maximizing fidelity density in the thermodynamic limit.</p></li><li><p><code>VOMPS</code>: Tangent space method for truncating uniform MPS.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/approximate/approximate.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.bond_type-Tuple{MPSKit.AbstractMPS}" href="#MPSKit.bond_type-Tuple{MPSKit.AbstractMPS}"><code>MPSKit.bond_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bond_type(ψ::AbstractMPS)
bond_type(ψtype::Type{&lt;:AbstractMPS})</code></pre><p>Return the type of the bond tensors of an <code>AbstractMPS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.braille-Tuple{IO, Union{AbstractMPO{O} where O&lt;:BlockTensorKit.SparseBlockTensorMap, MPOHamiltonian}}" href="#MPSKit.braille-Tuple{IO, Union{AbstractMPO{O} where O&lt;:BlockTensorKit.SparseBlockTensorMap, MPOHamiltonian}}"><code>MPSKit.braille</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">braille(io::IO, H::Union{SparseMPO, MPOHamiltonian})
braille(H::Union{SparseMPO, MPOHamiltonian})</code></pre><p>Prints a compact, human-readable &quot;braille&quot; visualization of a sparseMPO or MPOHamiltonian. Each site of the MPO is represented as a block of Unicode braille characters, with sites separated by dashes. This visualization is useful for quickly inspecting the structure and sparsity pattern of MPOs.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The output stream to print to (e.g., <code>stdout</code>).</li><li><code>H::Union{SparseMPO, MPOHamiltonian}</code>: The <code>SparseMPO</code> or <code>MPOHamiltonian</code> to visualize.</li></ul><p>If called without an <code>io</code> argument, output is printed to <code>stdout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/show.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.calc_galerkin-Tuple{Int64, Union{FiniteMPS, InfiniteMPS, WindowMPS}, Any, Any, Any}" href="#MPSKit.calc_galerkin-Tuple{Int64, Union{FiniteMPS, InfiniteMPS, WindowMPS}, Any, Any, Any}"><code>MPSKit.calc_galerkin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_galerkin(below, operator, above, envs)
calc_galerkin(pos, below, operator, above, envs)</code></pre><p>Calculate the Galerkin error, which is the error between the solution of the original problem, and the solution of the problem projected on the tangent space. Concretely, this is the overlap of the current state with the single-site derivative, projected onto the nullspace of the current state:</p><p class="math-container">\[\epsilon = |VL * (VL&#39; * \frac{above}{\partial AC_{pos}})|\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L38-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.changebonds" href="#MPSKit.changebonds"><code>MPSKit.changebonds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">changebonds(ψ::AbstractMPS, H, alg, envs) -&gt; ψ′, envs′
changebonds(ψ::AbstractMPS, alg) -&gt; ψ′</code></pre><p>Change the bond dimension of <code>ψ</code> using the algorithm <code>alg</code>, and return the new <code>ψ</code> and the new <code>envs</code>.</p><p>See also: <a href="#MPSKit.SvdCut"><code>SvdCut</code></a>, <a href="#MPSKit.RandExpand"><code>RandExpand</code></a>, <a href="#MPSKit.VUMPSSvdCut"><code>VUMPSSvdCut</code></a>, <a href="#MPSKit.OptimalExpand"><code>OptimalExpand</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/changebonds/changebonds.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.check_unambiguous_braiding-Tuple{Type{Bool}, TensorKit.VectorSpace}" href="#MPSKit.check_unambiguous_braiding-Tuple{Type{Bool}, TensorKit.VectorSpace}"><code>MPSKit.check_unambiguous_braiding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_unambiguous_braiding(::Type{Bool}, V::VectorSpace)::Bool
check_unambiguous_braiding(V::VectorSpace)</code></pre><p>Verify that the braiding of a vector space is unambiguous. This is the case if the braiding is symmetric or if all sectors are trivial. The signature with <code>Type{Bool}</code> is used to check while the signature without is used to throw an error if the braiding is ambiguous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/utility.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.correlation_length-Tuple{InfiniteMPS}" href="#MPSKit.correlation_length-Tuple{InfiniteMPS}"><code>MPSKit.correlation_length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correlation_length(above::InfiniteMPS; kwargs...)</code></pre><p>Compute the correlation length of a given InfiniteMPS based on the next-to-leading eigenvalue of the transfer matrix. The <code>kwargs</code> are passed to <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>, and can for example be used to target the correlation length in a specific sector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L178-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.correlator" href="#MPSKit.correlator"><code>MPSKit.correlator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correlator(ψ, O1, O2, i, j)
correlator(ψ, O12, i, j)</code></pre><p>Compute the 2-point correlator &lt;ψ|O1[i]O2[j]|ψ&gt; for inserting <code>O1</code> at <code>i</code> and <code>O2</code> at <code>j</code>. Also accepts ranges for <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/correlators.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.eachsite-Tuple{MPSKit.AbstractMPS}" href="#MPSKit.eachsite-Tuple{MPSKit.AbstractMPS}"><code>MPSKit.eachsite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachsite(state::AbstractMPS)</code></pre><p>Return an iterator over the sites of the MPS <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.entanglement_spectrum" href="#MPSKit.entanglement_spectrum"><code>MPSKit.entanglement_spectrum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entanglement_spectrum(ψ, site::Int) -&gt; SectorDict{sectortype(ψ),Vector{&lt;:Real}}</code></pre><p>Compute the entanglement spectrum at a given site, i.e. the singular values of the gauge matrix to the right of a given site. This is a dictionary mapping the charge to the singular values.</p><p>For <code>InfiniteMPS</code> and <code>WindowMPS</code> the default value for <code>site</code> is 0.</p><p>For <code>FiniteMPS</code> no default value for <code>site</code> is given, it is up to the user to specify.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.entanglementplot" href="#MPSKit.entanglementplot"><code>MPSKit.entanglementplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entanglementplot(state; site=0[, kwargs...])</code></pre><p>Plot the <a href="#MPSKit.entanglement_spectrum">entanglement spectrum</a> of a given MPS <code>state</code>. </p><p><strong>Arguments</strong></p><ul><li><code>state</code>: the MPS for which to compute the entanglement spectrum.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>site::Int=0</code>: MPS index for multisite unit cells. The spectrum is computed for the bond between <code>site</code> and <code>site + 1</code>.</li><li><code>expand_symmetry::Logical=false</code>: add quantum dimension degeneracies.</li><li><code>sortby=maximum</code>: the method of sorting the sectors.</li><li><code>sector_margin=1//10</code>: the amount of whitespace between sectors.</li><li><code>sector_formatter=string</code>: how to convert sectors to strings.</li><li><code>kwargs...</code>: other kwargs are passed on to the plotting backend.</li></ul><div class="admonition is-info" id="Note-c7a8b2f0af020757"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c7a8b2f0af020757" title="Permalink"></a></header><div class="admonition-body"><p>You will need to manually import <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> to be able to use this function. MPSKit.jl defines its plots based on <a href="https://github.com/JuliaPlots/Plots.jl/tree/v2/RecipesBase">RecipesBase.jl</a>, but the user still has to add <code>using Plots</code> to be able to actually produce the plots.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/plotting.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.entropy-Tuple{InfiniteMPS}" href="#MPSKit.entropy-Tuple{InfiniteMPS}"><code>MPSKit.entropy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entropy(state, [site::Int])</code></pre><p>Calculate the Von Neumann entanglement entropy of a given MPS. If an integer <code>site</code> is given, the entropy is across the entanglement cut to the right of site <code>site</code>. Otherwise, a vector of entropies is returned, one for each site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.environment_alg-Tuple{Union{InfiniteMPS, MultilineMPS}, Union{InfiniteMPO, MultilineMPO}, Union{InfiniteMPS, MultilineMPS}}" href="#MPSKit.environment_alg-Tuple{Union{InfiniteMPS, MultilineMPS}, Union{InfiniteMPO, MultilineMPO}, Union{InfiniteMPS, MultilineMPS}}"><code>MPSKit.environment_alg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">environment_alg(below, operator, above; kwargs...)</code></pre><p>Determine an appropriate algorithm for computing the environments, based on the given <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/environments/abstract_envs.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.exact_diagonalization-Tuple{FiniteMPOHamiltonian}" href="#MPSKit.exact_diagonalization-Tuple{FiniteMPOHamiltonian}"><code>MPSKit.exact_diagonalization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_diagonalization(H::FiniteMPOHamiltonian;
                      sector=first(sectors(oneunit(physicalspace(H, 1)))),
                      len::Int=length(H), num::Int=1, which::Symbol=:SR,
                      alg=Defaults.alg_eigsolve(; dynamic_tols=false))
                        -&gt; vals, state_vecs, convhist</code></pre><p>Use <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a> to perform exact diagonalization on a <code>FiniteMPOHamiltonian</code> to find its eigenvectors as <code>FiniteMPS</code> of maximal rank, essentially equivalent to dense eigenvectors.</p><p><strong>Arguments</strong></p><ul><li><code>H::FiniteMPOHamiltonian</code>: the Hamiltonian to diagonalize.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sector=first(sectors(oneunit(physicalspace(H, 1))))</code>: the total charge of the eigenvectors, which is chosen trivial by default.</li><li><code>len::Int=length(H)</code>: the length of the system.</li><li><code>num::Int=1</code>: the number of eigenvectors to find.</li><li><code>which::Symbol=:SR</code>: the kind eigenvalues to find, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a>. </li><li><code>alg=Defaults.alg_eigsolve(; dynamic_tols=false)</code>: the diagonalization algorithm to use, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a>.</li></ul><div class="admonition is-info" id="Valid-sector-values-ad1631d2fa8471f4"><header class="admonition-header">Valid `sector` values<a class="admonition-anchor" href="#Valid-sector-values-ad1631d2fa8471f4" title="Permalink"></a></header><div class="admonition-body"><p>The total charge of the eigenvectors is imposed by adding a charged auxiliary space as the leftmost virtualspace of each eigenvector. Specifically, this is achieved by passing <code>left=Vect[typeof(sector)](sector =&gt; 1)</code> to the <a href="../../man/states/#FiniteMPS"><code>FiniteMPS</code></a> constructor. As such, the only valid <code>sector</code> values (i.e. <code>sector</code> values for which the corresponding eigenstates have valid fusion channels) are those that occur in the dual of the fusion of all the physical spaces in the system.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/ED.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.excitations" href="#MPSKit.excitations"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, left_ψ::InfiniteMPS, [left_environment],
            [right_ψ::InfiniteMPS], [right_environment]; kwargs...)</code></pre><p>Create and optimise finite quasiparticle states.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm::QuasiparticleAnsatz</code>: optimization algorithm</li><li><code>left_ψ::FiniteMPS</code>: left groundstate</li><li><code>[left_environment]</code>: left groundstate environment</li><li><code>[right_ψ::FiniteMPS]</code>: right groundstate</li><li><code>[right_environment]</code>: right groundstate environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>sector=one(sectortype(left_ψ))</code>: charge of the quasiparticle state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/quasiparticleexcitation.jl#L154-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.excitations" href="#MPSKit.excitations"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, momentum::Union{Number, Vector{&lt;:Number}},
            left_ψ::InfiniteMPS, [left_environment],
            [right_ψ::InfiniteMPS], [right_environment];
            kwargs...)</code></pre><p>Create and optimise infinite quasiparticle states.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm::QuasiparticleAnsatz</code>: optimization algorithm</li><li><code>momentum::Union{Number, Vector{&lt;:Number}}</code>: momentum or list of momenta</li><li><code>left_ψ::InfiniteMPS</code>: left groundstate</li><li><code>[left_environment]</code>: left groundstate environment</li><li><code>[right_ψ::InfiniteMPS]</code>: right groundstate</li><li><code>[right_environment]</code>: right groundstate environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>solver</code>: algorithm for the linear solver of the quasiparticle environments</li><li><code>sector=one(sectortype(left_ψ))</code>: charge of the quasiparticle state</li><li><code>parallel=true</code>: enable multi-threading over different momenta</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/quasiparticleexcitation.jl#L69-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.excitations" href="#MPSKit.excitations"><code>MPSKit.excitations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">excitations(H, algorithm::QuasiparticleAnsatz, ψ::FiniteQP, [left_environments],
            [right_environments]; num=1) -&gt; (energies, states)
excitations(H, algorithm::QuasiparticleAnsatz, ψ::InfiniteQP, [left_environments],
            [right_environments]; num=1, solver=Defaults.solver) -&gt; (energies, states)
excitations(H, algorithm::FiniteExcited, ψs::NTuple{&lt;:Any, &lt;:FiniteMPS};
            num=1, init=copy(first(ψs))) -&gt; (energies, states)
excitations(H, algorithm::ChepigaAnsatz, ψ::FiniteMPS, [envs];
            num=1, pos=length(ψ)÷2) -&gt; (energies, states)
excitations(H, algorithm::ChepigaAnsatz2, ψ::FiniteMPS, [envs];
            num=1, pos=length(ψ)÷2) -&gt; (energies, states)</code></pre><p>Compute the first excited states and their energy gap above a groundstate.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractMPO</code>: operator for which to find the excitations</li><li><code>algorithm</code>: optimization algorithm</li><li><code>ψ::QP</code>: initial quasiparticle guess</li><li><code>ψs::NTuple{N, &lt;:FiniteMPS}</code>: <code>N</code> first excited states</li><li><code>[left_environments]</code>: left groundstate environment</li><li><code>[right_environments]</code>: right groundstate environment</li></ul><p><strong>Keywords</strong></p><ul><li><code>num::Int</code>: number of excited states to compute</li><li><code>solver</code>: algorithm for the linear solver of the quasiparticle environments</li><li><code>init</code>: initial excited state guess</li><li><code>pos</code>: position of perturbation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/excitation/excitations.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.expectation_value" href="#MPSKit.expectation_value"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expectation_value(ψ, O, [environments])
expectation_value(ψ, inds =&gt; O)</code></pre><p>Compute the expectation value of an operator <code>O</code> on a state <code>ψ</code>.  Optionally, it is possible to make the computations more efficient by also passing in previously calculated <code>environments</code>.</p><p>In general, the operator <code>O</code> may consist of an arbitrary MPO <code>O &lt;: AbstractMPO</code> that acts on all sites, or a local operator <code>O = inds =&gt; operator</code> acting on a subset of sites.  In the latter case, <code>inds</code> is a tuple of indices that specify the sites on which the operator acts, while the operator is either a <code>AbstractTensorMap</code> or a <code>FiniteMPO</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::AbstractMPS</code> : the state on which to compute the expectation value</li><li><code>O::Union{AbstractMPO,Pair}</code> : the operator to compute the expectation value of.    This can either be an <code>AbstractMPO</code>, or a pair of indices and local operator..</li><li><code>environments::AbstractMPSEnvironments</code> : the environments to use for the calculation. If not given, they will be calculated.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = FiniteMPS(ones(Float64, (ℂ^2)^4));

julia&gt; S_x = TensorMap(Float64[0 1; 1 0], ℂ^2, ℂ^2);

julia&gt; round(expectation_value(ψ, 2 =&gt; S_x))
1.0

julia&gt; round(expectation_value(ψ, (2, 3) =&gt; S_x ⊗ S_x))
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/expval.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.fidelity_susceptibility-Union{Tuple{T}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}, Any}} where T&lt;:MPOHamiltonian" href="#MPSKit.fidelity_susceptibility-Union{Tuple{T}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}}, Tuple{Union{FiniteMPS, InfiniteMPS}, T, AbstractVector{T}, Any}} where T&lt;:MPOHamiltonian"><code>MPSKit.fidelity_susceptibility</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fidelity_susceptibility(state::Union{FiniteMPS,InfiniteMPS}, H₀::T,
                        Vs::AbstractVector{T}, [henvs=environments(state, H₀)];
                        maxiter=Defaults.maxiter,
                        tol=Defaults.tol) where {T&lt;:MPOHamiltonian}</code></pre><p>Computes the fidelity susceptibility of a the ground state <code>state</code> of a base Hamiltonian <code>H₀</code> with respect to a set of perturbing Hamiltonians <code>Vs</code>. Each of the perturbing Hamiltonians can be interpreted as corresponding to a tuning parameter <span>$aᵢ$</span> in a &#39;total&#39; Hamiltonian <span>$H = H₀ + ∑ᵢ aᵢ Vᵢ$</span>.</p><p>Returns a matrix containing the overlaps of the elementary excitations on top of <code>state</code> corresponding to each of the perturbing Hamiltonians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/fidelity_susceptibility.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.find_groundstate" href="#MPSKit.find_groundstate"><code>MPSKit.find_groundstate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_groundstate(ψ₀, H, [environments]; kwargs...) -&gt; (ψ, environments, ϵ)
find_groundstate(ψ₀, H, algorithm, environments) -&gt; (ψ, environments, ϵ)</code></pre><p>Compute the groundstate for Hamiltonian <code>H</code> with initial guess <code>ψ</code>. If not specified, an optimization algorithm will be attempted based on the supplied keywords.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess</li><li><code>H::AbstractMPO</code>: operator for which to find the groundstate</li><li><code>[environments]</code>: MPS environment manager</li><li><code>algorithm</code>: optimization algorithm</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>ψ::AbstractMPS</code>: converged groundstate</li><li><code>environments</code>: environments corresponding to the converged state</li><li><code>ϵ::Float64</code>: final convergence error upon terminating the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/groundstate/find_groundstate.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.fixedpoint-Tuple{Any, Any, Symbol, KrylovKit.Lanczos}" href="#MPSKit.fixedpoint-Tuple{Any, Any, Symbol, KrylovKit.Lanczos}"><code>MPSKit.fixedpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixedpoint(A, x₀, which::Symbol; kwargs...) -&gt; val, vec
fixedpoint(A, x₀, which::Symbol, alg) -&gt; val, vec</code></pre><p>Compute the fixedpoint of a linear operator <code>A</code> using the specified eigensolver <code>alg</code>. The fixedpoint is assumed to be unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/fixedpoint.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.fuse_mul_mpo-Tuple{Any, Any}" href="#MPSKit.fuse_mul_mpo-Tuple{Any, Any}"><code>MPSKit.fuse_mul_mpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fuse_mul_mpo(O1, O2)</code></pre><p>Compute the mpo tensor that arises from multiplying MPOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/abstractmpo.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.gaugefix!" href="#MPSKit.gaugefix!"><code>MPSKit.gaugefix!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaugefix!(ψ::InfiniteMPS, A, C₀; kwargs...) -&gt; ψ
gaugefix!(ψ::InfiniteMPS, A, C₀, alg::Algorithm) -&gt; ψ</code></pre><p>Bring an <code>InfiniteMPS</code> into a uniform gauge, using the specified algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/ortho.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.infinite_temperature_density_matrix-Tuple{MPOHamiltonian}" href="#MPSKit.infinite_temperature_density_matrix-Tuple{MPOHamiltonian}"><code>MPSKit.infinite_temperature_density_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">infinite_temperature_density_matrix(H::MPOHamiltonian) -&gt; MPO</code></pre><p>Return the density matrix of the infinite temperature state for a given Hamiltonian. This is the identity matrix in the physical space, and the identity in the auxiliary space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.instantiate_operator-Tuple{MPSKit.AbstractMPS, Pair}" href="#MPSKit.instantiate_operator-Tuple{MPSKit.AbstractMPS, Pair}"><code>MPSKit.instantiate_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">instantiate_operator(state, O::Pair)
instantiate_operator(lattice::AbstractArray{&lt;:VectorSpace}, O::Pair)</code></pre><p>Instantiate a local operator <code>O</code> for a <code>state</code> or <code>lattice</code> as a vector of MPO tensors, and a vector of linear site indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpohamiltonian.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.integrate" href="#MPSKit.integrate"><code>MPSKit.integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(f, y₀, t, dt, alg)</code></pre><p>Integrate the differential equation <span>$i dy/dt = f(y, t)$</span> over a time step &#39;dt&#39; starting from <span>$y(t₀)=y₀$</span>, using the provided algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: driving function</li><li><code>y₀</code>: object to integrate</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>alg</code>: integration scheme</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/integrators.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.isfullrank-Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}" href="#MPSKit.isfullrank-Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}"><code>MPSKit.isfullrank</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isfullrank(A::GenericMPSTensor; side=:both)</code></pre><p>Determine whether the given tensor is full rank, i.e. whether both the map from the left virtual space and the physical space to the right virtual space, and the map from the right virtual space and the physical space to the left virtual space are injective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.l_LL-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A" href="#MPSKit.l_LL-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A"><code>MPSKit.l_LL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">l_LL(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AL</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.l_LR" href="#MPSKit.l_LR"><code>MPSKit.l_LR</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">l_LR(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AL</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.l_RL" href="#MPSKit.l_RL"><code>MPSKit.l_RL</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">l_RL(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AR</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L355-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.l_RR" href="#MPSKit.l_RR"><code>MPSKit.l_RR</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">l_RR(ψ, location)</code></pre><p>Left dominant eigenvector of the <code>AR</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.leading_boundary" href="#MPSKit.leading_boundary"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leading_boundary(ψ₀, O, [environments]; kwargs...) -&gt; (ψ, environments, ϵ)
leading_boundary(ψ₀, O, algorithm, environments) -&gt; (ψ, environments, ϵ)</code></pre><p>Compute the leading boundary MPS for operator <code>O</code> with initial guess <code>ψ</code>. If not specified, an optimization algorithm will be attempted based on the supplied keywords.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial guess</li><li><code>O::AbstractMPO</code>: operator for which to find the leading_boundary</li><li><code>[environments]</code>: MPS environment manager</li><li><code>algorithm</code>: optimization algorithm</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Float64</code>: tolerance for convergence criterium</li><li><code>maxiter::Int</code>: maximum amount of iterations</li><li><code>verbosity::Int</code>: display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>ψ::AbstractMPS</code>: converged leading boundary MPS</li><li><code>environments</code>: environments corresponding to the converged boundary</li><li><code>ϵ::Float64</code>: final convergence error upon terminating the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/statmech/leading_boundary.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.leading_boundary" href="#MPSKit.leading_boundary"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leading_boundary(ψ, opp, alg, envs=environments(ψ, opp))</code></pre><p>Approximate the leading eigenvector for opp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/statmech/vumps.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.left_virtualspace" href="#MPSKit.left_virtualspace"><code>MPSKit.left_virtualspace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_virtualspace(ψ::AbstractMPS, [pos=1:length(ψ)])</code></pre><p>Return the virtual space of the bond to the left of sites <code>pos</code>.</p><div class="admonition is-warning" id="Warning-d4790c74de09c3ef"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d4790c74de09c3ef" title="Permalink"></a></header><div class="admonition-body"><p>In rare cases, the gauge tensor on the virtual space might not be square, and as a result it cannot always be guaranteed that <code>right_virtualspace(ψ, i - 1) == left_virtualspace(ψ, i)</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.make_time_mpo" href="#MPSKit.make_time_mpo"><code>MPSKit.make_time_mpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_time_mpo(H::MPOHamiltonian, dt::Number, alg; kwargs...) -&gt; O::MPO</code></pre><p>Construct an <code>MPO</code> that approximates <span>$\exp(-iHdt)$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution operator is constructed   with an imaginary time step instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>).   This can be useful for using this function to compute the ground state of a Hamiltonian,   or to compute finite-temperature properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/time_evolve.jl#L75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.makefullrank!-Tuple{PeriodicVector{&lt;:TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}}" href="#MPSKit.makefullrank!-Tuple{PeriodicVector{&lt;:TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T}}}"><code>MPSKit.makefullrank!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makefullrank!(A::PeriodicVector{&lt;:GenericMPSTensor}; alg=QRpos())</code></pre><p>Make the set of MPS tensors full rank by performing a series of orthogonalizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.marek_gap-Tuple{InfiniteMPS}" href="#MPSKit.marek_gap-Tuple{InfiniteMPS}"><code>MPSKit.marek_gap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given an InfiniteMPS, compute the gap <code>ϵ</code> for the asymptotics of the transfer matrix, as well as the Marek gap <code>δ</code> as a scaling measure of the bond dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L145-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.max_Ds-Tuple{FiniteMPS}" href="#MPSKit.max_Ds-Tuple{FiniteMPS}"><code>MPSKit.max_Ds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_Ds(ψ::FiniteMPS) -&gt; Vector{Float64}</code></pre><p>Compute the dimension of the maximal virtual space at a given site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/finitemps.jl#L436-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.max_virtualspaces-Union{Tuple{Vector{&lt;:Union{TensorKit.CompositeSpace{S}, S}}}, Tuple{S}} where S&lt;:TensorKit.ElementarySpace" href="#MPSKit.max_virtualspaces-Union{Tuple{Vector{&lt;:Union{TensorKit.CompositeSpace{S}, S}}}, Tuple{S}} where S&lt;:TensorKit.ElementarySpace"><code>MPSKit.max_virtualspaces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_virtualspaces(ψ::FiniteMPS)
max_virtualspaces(Ps::Vector{&lt;:Union{S,CompositeSpace{S}}}; left=oneunit(S), right=oneunit(S))</code></pre><p>Compute the maximal virtual spaces of a given finite MPS or its physical spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/finitemps.jl#L409-L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.multiply_neighbours" href="#MPSKit.multiply_neighbours"><code>MPSKit.multiply_neighbours</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply_neighbours(mpo::FiniteMPO, i::Integer)
multiply_neighbours!(mpo::FiniteMPO, i::Integer)</code></pre><p>Construct the mpo of length <code>length(mpo) - 1</code> which is formed by multiplying the operators on site <code>i</code> and <code>i + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L427-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.multiply_neighbours!" href="#MPSKit.multiply_neighbours!"><code>MPSKit.multiply_neighbours!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply_neighbours(mpo::FiniteMPO, i::Integer)
multiply_neighbours!(mpo::FiniteMPO, i::Integer)</code></pre><p>Construct the mpo of length <code>length(mpo) - 1</code> which is formed by multiplying the operators on site <code>i</code> and <code>i + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L427-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.open_boundary_conditions" href="#MPSKit.open_boundary_conditions"><code>MPSKit.open_boundary_conditions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_boundary_conditions(mpo::InfiniteMPOHamiltonian, L::Int) -&gt; FiniteMPOHamiltonian</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by applying open boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L455-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.open_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O&lt;:BlockTensorKit.SparseBlockTensorMap" href="#MPSKit.open_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O&lt;:BlockTensorKit.SparseBlockTensorMap"><code>MPSKit.open_boundary_conditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_boundary_conditions(mpo::InfiniteMPO, L::Int) -&gt; FiniteMPO</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by applying open boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.periodic_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O" href="#MPSKit.periodic_boundary_conditions-Union{Tuple{InfiniteMPO{O}}, Tuple{O}, Tuple{InfiniteMPO{O}, Any}} where O"><code>MPSKit.periodic_boundary_conditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodic_boundary_conditions(mpo::AbstractInfiniteMPO, L::Int)</code></pre><p>Convert an infinite MPO into a finite MPO of length <code>L</code>, by mapping periodic boundary conditions onto an open system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.physicalspace" href="#MPSKit.physicalspace"><code>MPSKit.physicalspace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">physicalspace(ψ::AbstractMPS, [pos=1:length(ψ)])</code></pre><p>Return the physical space of the site tensor at site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.propagator" href="#MPSKit.propagator"><code>MPSKit.propagator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagator(ψ₀::AbstractFiniteMPS, z::Number, H::MPOHamiltonian, alg::DynamicalDMRG; init=copy(ψ₀))</code></pre><p>Calculate the propagator <span>$\frac{1}{E₀ + z - H}|ψ₀⟩$</span> using the dynamical DMRG algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/propagator/corvector.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.r_LL" href="#MPSKit.r_LL"><code>MPSKit.r_LL</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r_LL(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AL</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L403-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.r_LR" href="#MPSKit.r_LR"><code>MPSKit.r_LR</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r_LR(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AL</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L396-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.r_RL" href="#MPSKit.r_RL"><code>MPSKit.r_RL</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r_RL(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AR</code>-<code>AL</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L389-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.r_RR-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A" href="#MPSKit.r_RR-Union{Tuple{InfiniteMPS{A}}, Tuple{A}, Tuple{InfiniteMPS{A}, Int64}} where A"><code>MPSKit.r_RR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r_RR(ψ, location)</code></pre><p>Right dominant eigenvector of the <code>AR</code>-<code>AR</code> transfermatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/infinitemps.jl#L378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.recalculate!" href="#MPSKit.recalculate!"><code>MPSKit.recalculate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Recalculate in-place each sub-env in MultipleEnvironments</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/environments/multiple_envs.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.regauge!" href="#MPSKit.regauge!"><code>MPSKit.regauge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regauge!(AC::GenericMPSTensor, C::MPSBondTensor; alg=QRpos()) -&gt; AL
regauge!(CL::MPSBondTensor, AC::GenericMPSTensor; alg=LQpos()) -&gt; AR</code></pre><p>Bring updated <code>AC</code> and <code>C</code> tensors back into a consistent set of left or right canonical tensors. This minimizes <code>∥AC_i - AL_i * C_i∥</code> or <code>∥AC_i - C_{i-1} * AR_i∥</code>. The optimal algorithm uses <code>Polar()</code> decompositions, but <code>QR</code>-based algorithms are typically more performant.</p><div class="admonition is-info" id="Note-123672f6608c862b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-123672f6608c862b" title="Permalink"></a></header><div class="admonition-body"><p>Computing <code>AL</code> is slightly faster than <code>AR</code>, as it avoids an intermediate transposition.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/ortho.jl#L147-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.right_virtualspace" href="#MPSKit.right_virtualspace"><code>MPSKit.right_virtualspace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_virtualspace(ψ::AbstractMPS, [pos=1:length(ψ)])</code></pre><p>Return the virtual space of the bond to the right of site(s) <code>pos</code>.</p><div class="admonition is-warning" id="Warning-d4790c74de09c3ef"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d4790c74de09c3ef" title="Permalink"></a></header><div class="admonition-body"><p>In rare cases, the gauge tensor on the virtual space might not be square, and as a result it cannot always be guaranteed that <code>right_virtualspace(ψ, i - 1) == left_virtualspace(ψ, i)</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L192-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.site_type-Tuple{MPSKit.AbstractMPS}" href="#MPSKit.site_type-Tuple{MPSKit.AbstractMPS}"><code>MPSKit.site_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">site_type(ψ::AbstractMPS)
site_type(ψtype::Type{&lt;:AbstractMPS})</code></pre><p>Return the type of the site tensors of an <code>AbstractMPS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/states/abstractmps.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.swap" href="#MPSKit.swap"><code>MPSKit.swap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">swap(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=SDD(), trscheme)
swap!(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=SDD(), trscheme)</code></pre><p>Compose the mpo with a swap gate applied to indices <code>i</code> and <code>i + 1</code>, effectively creating an operator that acts on the Hilbert spaces with those factors swapped. The keyword arguments <code>alg</code> and <code>trscheme</code> can be used to control how the resulting tensor is truncated again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L394-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.swap!" href="#MPSKit.swap!"><code>MPSKit.swap!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">swap(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=SDD(), trscheme)
swap!(mpo::FiniteMPO, i::Integer; inv::Bool=false, alg=SDD(), trscheme)</code></pre><p>Compose the mpo with a swap gate applied to indices <code>i</code> and <code>i + 1</code>, effectively creating an operator that acts on the Hilbert spaces with those factors swapped. The keyword arguments <code>alg</code> and <code>trscheme</code> can be used to control how the resulting tensor is truncated again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/operators/mpo.jl#L394-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.tensorexpr-Tuple{Any, Any}" href="#MPSKit.tensorexpr-Tuple{Any, Any}"><code>MPSKit.tensorexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensorexpr(name, ind_out, [ind_in])</code></pre><p>Generates expressions for use within <a href="https://quantumkithub.github.io/TensorOperations.jl/stable/man/indexnotation/#TensorOperations.%40tensor"><code>@tensor</code></a> environments of the form <code>name[ind_out...; ind_in]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/utility.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.time_evolve" href="#MPSKit.time_evolve"><code>MPSKit.time_evolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_evolve(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
time_evolve!(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-evolve the initial state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time span by stepping through each of the time points obtained by iterating t_span.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t_span::AbstractVector{&lt;:Number}</code>: time points over which the time evolution is stepped</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbosity::Int=0</code>: verbosity level for logging</li><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/time_evolve.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.time_evolve!" href="#MPSKit.time_evolve!"><code>MPSKit.time_evolve!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_evolve(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
time_evolve!(ψ₀, H, t_span, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-evolve the initial state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time span by stepping through each of the time points obtained by iterating t_span.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t_span::AbstractVector{&lt;:Number}</code>: time points over which the time evolution is stepped</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbosity::Int=0</code>: verbosity level for logging</li><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/time_evolve.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.timestep" href="#MPSKit.timestep"><code>MPSKit.timestep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timestep(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
timestep!(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-step the state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time step <code>dt</code> at time <code>t</code>, solving the Schroedinger equation: <span>$i ∂ψ/∂t = H ψ$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/time_evolve.jl#L50-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.timestep!" href="#MPSKit.timestep!"><code>MPSKit.timestep!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timestep(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ, envs)
timestep!(ψ₀, H, t, dt, [alg], [envs]; kwargs...) -&gt; (ψ₀, envs)</code></pre><p>Time-step the state <code>ψ₀</code> with Hamiltonian <code>H</code> over a given time step <code>dt</code> at time <code>t</code>, solving the Schroedinger equation: <span>$i ∂ψ/∂t = H ψ$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ₀::AbstractMPS</code>: initial state</li><li><code>H::AbstractMPO</code>: operator that generates the time evolution (can be time-dependent).</li><li><code>t::Number</code>: starting time of time-step</li><li><code>dt::Number</code>: time-step magnitude</li><li><code>[alg]</code>: algorithm to use for the time evolution. Defaults to <a href="../../man/algorithms/#TDVP"><code>TDVP</code></a>.</li><li><code>[envs]</code>: MPS environment manager</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>imaginary_evolution::Bool=false</code>: if true, the time evolution is done with an imaginary time step   instead, (i.e. <span>$\exp(-Hdt)$</span> instead of <span>$\exp(-iHdt)$</span>). This can be useful for using this   function to compute the ground state of a Hamiltonian, or to compute finite-temperature   properties of a system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/timestep/time_evolve.jl#L50-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}" href="#MPSKit.transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}"><code>MPSKit.transfer_left</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transfer_left(v, A, Ā)</code></pre><p>apply a transfer matrix to the left.</p><pre><code class="nohighlight hljs"> ┌─A─
-v │
 └─Ā─</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/transfermatrix/transfer.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}" href="#MPSKit.transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T, TensorKit.AbstractTensorMap{T, S, N₂, 1} where T}} where {S, N₁, N₂}"><code>MPSKit.transfer_right</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transfer_right(v, A, Ā)</code></pre><p>apply a transfer matrix to the right.</p><pre><code class="nohighlight hljs">─A─┐
 │ v-
─Ā─┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/transfermatrix/transfer.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.transfer_spectrum-Tuple{InfiniteMPS}" href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>MPSKit.transfer_spectrum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transfer_spectrum(above::InfiniteMPS; below=above, tol=Defaults.tol, num_vals=20,
                       sector=first(sectors(oneunit(left_virtualspace(above, 1)))))</code></pre><p>Calculate the partial spectrum of the left mixed transfer matrix corresponding to the overlap of a given <code>above</code> state and a <code>below</code> state. The <code>sector</code> keyword argument can be used to specify a non-trivial total charge for the transfer matrix eigenvectors. Specifically, an auxiliary space <code>ℂ[typeof(sector)](sector =&gt; 1)&#39;</code> will be added to the domain of each eigenvector. The <code>tol</code> and <code>num_vals</code> keyword arguments are passed to <code>KrylovKit.eigolve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.transferplot" href="#MPSKit.transferplot"><code>MPSKit.transferplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transferplot(above, below=above; sectors=[], transferkwargs=(;)[, kwargs...])</code></pre><p>Plot the partial transfer matrix spectrum of two InfiniteMPS&#39;s.</p><p><strong>Arguments</strong></p><ul><li><code>above::InfiniteMPS</code>: above mps for <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>.</li><li><code>below::InfiniteMPS=above</code>: below mps for <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>sectors=[]</code>: vector of sectors for which to compute the spectrum.</li><li><code>transferkwargs</code>: kwargs for call to <a href="#MPSKit.transfer_spectrum-Tuple{InfiniteMPS}"><code>transfer_spectrum</code></a>.</li><li><code>kwargs</code>: other kwargs are passed on to the plotting backend.</li><li><code>thetaorigin=0</code>: origin of the angle range.</li><li><code>sector_formatter=string</code>: how to convert sectors to strings.</li></ul><div class="admonition is-info" id="Note-c7a8b2f0af020757"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c7a8b2f0af020757" title="Permalink"></a></header><div class="admonition-body"><p>You will need to manually import <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> to be able to use this function. MPSKit.jl defines its plots based on <a href="https://github.com/JuliaPlots/Plots.jl/tree/v2/RecipesBase">RecipesBase.jl</a>, but the user still has to add <code>using Plots</code> to be able to actually produce the plots.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/utility/plotting.jl#L91-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSKit.variance" href="#MPSKit.variance"><code>MPSKit.variance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variance(state, hamiltonian, [envs=environments(state, hamiltonian)])</code></pre><p>Compute the variance of the energy of the state with respect to the hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/2fe64ba982a4838119f5f87ccd51d4a6bc4db09f/src/algorithms/toolbox.jl#L195-L199">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/">« Examples</a><a class="docs-footer-nextpage" href="../../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 29 September 2025 17:52">Monday 29 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
