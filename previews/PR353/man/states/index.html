<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>States · MPSKit.jl</title><meta name="title" content="States · MPSKit.jl"/><meta property="og:title" content="States · MPSKit.jl"/><meta property="twitter:title" content="States · MPSKit.jl"/><meta name="description" content="Documentation for MPSKit.jl."/><meta property="og:description" content="Documentation for MPSKit.jl."/><meta property="twitter:description" content="Documentation for MPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Prerequisites</a></li><li class="is-active"><a class="tocitem" href>States</a><ul class="internal"><li><a class="tocitem" href="#FiniteMPS"><span>FiniteMPS</span></a></li><li><a class="tocitem" href="#InfiniteMPS"><span>InfiniteMPS</span></a></li><li><a class="tocitem" href="#WindowMPS"><span>WindowMPS</span></a></li><li><a class="tocitem" href="#MultilineMPS"><span>MultilineMPS</span></a></li></ul></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../parallelism/">Parallelism in julia</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../lib/lib/">Library</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>States</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>States</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MPSKit.jl/blob/main/docs/src/man/states.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="um_states"><a class="docs-heading-anchor" href="#um_states">States</a><a id="um_states-1"></a><a class="docs-heading-anchor-permalink" href="#um_states" title="Permalink"></a></h1><h2 id="FiniteMPS"><a class="docs-heading-anchor" href="#FiniteMPS">FiniteMPS</a><a id="FiniteMPS-1"></a><a class="docs-heading-anchor-permalink" href="#FiniteMPS" title="Permalink"></a></h2><p>A <a href="#FiniteMPS"><code>FiniteMPS</code></a> is - at its core - a chain of mps tensors.</p><img src="../finite_mps_definition.png" alt="finite MPS" class="color-invertible"/><h3 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h3><p>A <code>FiniteMPS</code> can be created by passing in a vector of tensormaps:</p><pre><code class="language-julia hljs">L = 10
data = [rand(ComplexF64, ℂ^1 ⊗ ℂ^2  ← ℂ^1) for _ in 1:L];
state = FiniteMPS(data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-site FiniteMPS(ComplexF64, TensorKit.ComplexSpace) with maximal dimension 1 and center 21/2:
┌─[10]─ ℂ^2
│ ℂ^1
├─[9]─ ℂ^2
│ ℂ^1
├─[8]─ ℂ^2
│ ℂ^1
├─[7]─ ℂ^2
│ ℂ^1
├─[6]─ ℂ^2
│ ℂ^1
├─[5]─ ℂ^2
│ ℂ^1
├─[4]─ ℂ^2
│ ℂ^1
├─[3]─ ℂ^2
│ ℂ^1
├─[2]─ ℂ^2
│ ℂ^1
└─[1]─ ℂ^2
</code></pre><p>Or alternatively by specifying its structure</p><pre><code class="language-julia hljs">max_bond_dimension = ℂ^4
physical_space = ℂ^2
state = FiniteMPS(rand, ComplexF64, L, physical_space, max_bond_dimension)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-site FiniteMPS(ComplexF64, TensorKit.ComplexSpace) with maximal dimension 4 and center 21/2:
┌─[10]─ ℂ^2
│ ℂ^2
├─[9]─ ℂ^2
│ ℂ^4
├─[8]─ ℂ^2
│ ℂ^4
├─[7]─ ℂ^2
│ ℂ^4
├─[6]─ ℂ^2
│ ℂ^4
├─[5]─ ℂ^2
│ ℂ^4
├─[4]─ ℂ^2
│ ℂ^4
├─[3]─ ℂ^2
│ ℂ^4
├─[2]─ ℂ^2
│ ℂ^2
└─[1]─ ℂ^2
</code></pre><p>You can take dot products, renormalize!, expectation values,....</p><h3 id="Gauging-and-canonical-forms"><a class="docs-heading-anchor" href="#Gauging-and-canonical-forms">Gauging and canonical forms</a><a id="Gauging-and-canonical-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Gauging-and-canonical-forms" title="Permalink"></a></h3><p>An MPS representation is not unique: for every virtual bond we can insert <span>$C \cdot C^{-1}$</span> without altering the state. Then, by redefining the tensors on both sides of the bond to include one factor each, we can change the representation.</p><img src="../mps_gauge_freedom.png" alt="MPS gauge freedom" class="color-invertible"/><p>There are two particularly convenient choices for the gauge at a site, the so-called left and right canonical form. For the left canonical form, all tensors to the left of a site are gauged such that they become left-isometries. By convention, we call these tensors <code>AL</code>.</p><pre><code class="language-julia hljs">al = state.AL[3]
al&#39; * al ≈ id(right_virtualspace(al))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Similarly, the right canonical form turns the tensors into right-isometries. By convention, these are called <code>AR</code>.</p><pre><code class="language-julia hljs">ar = state.AR[3]
repartition(ar, 1, 2) * repartition(ar, 1, 2)&#39; ≈ id(left_virtualspace(ar))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>It is also possible to mix and match these two forms, where all tensors to the left of a given site are in the left gauge, while all tensors to the right are in the right gauge. In this case, the final gauge transformation tensor can no longer be absorbed, since that would spoil the gauge either to the left or the right. This center-gauged tensor is called <code>C</code>, which is also the gauge transformation to relate left- and right-gauged tensors. Finally, for convenience it is also possible to leave a single MPS tensor in the center gauge, which we call <code>AC = AL * C</code></p><pre><code class="language-julia hljs">c = state.C[3] # to the right of site 3
c′ = state.C[2] # to the left of site 3
al * c ≈ state.AC[3] ≈ repartition(c′ * repartition(ar, 1, 2), 2, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>These forms are often used throughout MPS algorithms, and the <a href="#FiniteMPS"><code>FiniteMPS</code></a> object acts as an automatic manager for this. It will automatically compute and cache the different forms, and detect when to recompute whenever needed. For example, in order to compute the overlap of an MPS with itself, we can choose any site and bring that into the center gauge. Since then both the left and right side simplify to the identity, this simply becomes the overlap of the gauge tensors:</p><pre><code class="language-julia hljs">d = dot(state, state)
all(c -&gt; dot(c, c) ≈ d, state.C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h3><p>Behind the scenes, a <code>FiniteMPS</code> has 4 fields</p><pre><code class="language-julia hljs">ALs::Vector{Union{Missing,A}}
ARs::Vector{Union{Missing,A}}
ACs::Vector{Union{Missing,A}}
Cs::Vector{Union{Missing,B}}</code></pre><p>and calling <code>AL</code>, <code>AR</code>, <code>C</code> or <code>AC</code> returns lazy views over these vectors that instantiate the tensors whenever they are requested. Similarly, changing a tensor will poison the <code>ARs</code> to the left of that tensor, and the <code>ALs</code> to the right. The idea behind this construction is that one never has to worry about how the state is gauged, as this gets handled automagically.</p><div class="admonition is-warning" id="Warning-47ea1bb85e1b71fb"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-47ea1bb85e1b71fb" title="Permalink"></a></header><div class="admonition-body"><p>While a <code>FiniteMPS</code> can automatically detect when to recompute the different gauges, this requires that one of the tensors is set using an indexing operation. In particular, in-place changes to the different tensors will not trigger the recomputation.</p></div></div><h2 id="InfiniteMPS"><a class="docs-heading-anchor" href="#InfiniteMPS">InfiniteMPS</a><a id="InfiniteMPS-1"></a><a class="docs-heading-anchor-permalink" href="#InfiniteMPS" title="Permalink"></a></h2><p>An <a href="#InfiniteMPS"><code>InfiniteMPS</code></a> can be thought of as being very similar to a finite mps, where the set of tensors is repeated periodically.</p><p>It can also be created by passing in a vector of <code>TensorMap</code>s:</p><pre><code class="language-julia hljs">data = [rand(ComplexF64, ℂ^4 ⊗ ℂ^2  ← ℂ^4) for _ in 1:2]
state = InfiniteMPS(data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-site InfiniteMPS(ComplexF64, TensorKit.ComplexSpace) with maximal dimension 4:
| ⋮
| ℂ^4
├─[2]─ ℂ^2
│ ℂ^4
├─[1]─ ℂ^2
│ ℂ^4
| ⋮
</code></pre><p>or by initializing it from given spaces</p><pre><code class="language-julia hljs">phys_spaces = fill(ℂ^2, 2)
virt_spaces = [ℂ^4, ℂ^5] # by convention to the right of a site
state = InfiniteMPS(phys_spaces, virt_spaces)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-site InfiniteMPS(ComplexF64, TensorKit.ComplexSpace) with maximal dimension 5:
| ⋮
| ℂ^5
├─[2]─ ℂ^2
│ ℂ^4
├─[1]─ ℂ^2
│ ℂ^5
| ⋮
</code></pre><p>Note that the code above creates an <code>InfiniteMPS</code> with a two-site unit cell, where the given virtual spaces are located to the right of their respective sites.</p><h3 id="Gauging-and-canonical-forms-2"><a class="docs-heading-anchor" href="#Gauging-and-canonical-forms-2">Gauging and canonical forms</a><a class="docs-heading-anchor-permalink" href="#Gauging-and-canonical-forms-2" title="Permalink"></a></h3><p>Much like for <code>FiniteMPS</code>, we can again query the gauged tensors <code>AL</code>, <code>AR</code>, <code>C</code> and <code>AC</code>. Here however, the implementation is much easier, since they all have to be recomputed whenever a single tensor changes. This is a result of periodically repeating the tensors, every <code>AL</code> is to the right of the changed site, and every <code>AR</code> is to the left. As a result, the fields are simply</p><pre><code class="language-julia hljs">AL::PeriodicArray{A,1}
AR::PeriodicArray{A,1}
C::PeriodicArray{B,1}
AC::PeriodicArray{A,1}</code></pre><h2 id="WindowMPS"><a class="docs-heading-anchor" href="#WindowMPS">WindowMPS</a><a id="WindowMPS-1"></a><a class="docs-heading-anchor-permalink" href="#WindowMPS" title="Permalink"></a></h2><p>A <a href="#WindowMPS"><code>WindowMPS</code></a> or segment MPS can be seen as a mix between an <a href="#InfiniteMPS"><code>InfiniteMPS</code></a> and a <a href="#FiniteMPS"><code>FiniteMPS</code></a>. It represents a window of mutable tensors (a finite MPS), embedded in an infinite environment (two infinite MPSs). It can therefore be created accordingly, ensuring that the edges match:</p><pre><code class="language-julia hljs">infinite_state = InfiniteMPS(ℂ^2, ℂ^4)
finite_state = FiniteMPS(5, ℂ^2, ℂ^4; left=ℂ^4, right=ℂ^4)
window = WindowMPS(infinite_state, finite_state, infinite_state)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WindowMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}(InfiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5438918323904265 + 0.49827794290033073im, 0.10682199382259307 + 0.02220631407337581im, 0.01700160682202177 + 0.004212394210361841im, 0.0034495232015169797 + 0.0030352094863048467im, 0.4759145011381743 + 0.4509316194654077im, 0.10411323364005334 + 0.050641200015229315im, 0.02009744043948998 + 0.001163040795561808im, 0.004847839779605181 + 0.0014146415372364im, 0.3483958992911082 - 0.5331892751762883im, 0.05371101891775232 - 0.11920408121135781im  …  -0.15901293200798652 - 0.027835563961690582im, -0.001493326319312662 - 0.03144180631766163im, -0.1491645441594139 - 0.08454881286209102im, 0.6692046226283289 - 0.18480571050901895im, -0.09851627682844752 + 0.22507941249361674im, -0.0955549746909119 - 0.01798571737815417im, 0.1516628854222841 + 0.010189920094210818im, -0.36108727051180745 + 0.38682794691695976im, -0.11155652332679673 + 0.30894392217557076im, -0.004863229091485816 + 0.08805011532121612im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5284399754163909 + 0.36956109504616624im, -0.6979124871478467 - 0.22415305251724568im, -0.19248598518612473 - 0.06638406060168114im, 0.03190186328503997 - 0.0005436833492400601im, 0.4755465303803926 + 0.5979976289935695im, 0.5110010457740632 + 0.35268967866937667im, 0.13936767635531253 + 0.08679346377360153im, -0.014267929126394713 - 0.0243134456461106im, 0.00751492850351454 - 0.011333257782098507im, 0.09602608713430016 + 0.007656918482537344im  …  -0.22368234004952187 - 0.07544195078486446im, -0.11320539733134974 - 0.15111775408187655im, -6.629414029224376e-5 - 3.7576562801894126e-5im, 0.014388567088627749 - 0.003891728163050813im, -0.07175871808504737 + 0.11088204083160805im, -0.08750112161399004 + 0.06418807040965713im, 6.740449387601237e-5 + 4.528770533903933e-6im, -0.007905047152041973 + 0.008271262413768578im, -0.03651763250489226 + 0.12311075106548491im, -0.014295604035399355 + 0.18551477116525664im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}(ComplexF64[0.9785471515635263 + 0.0im, 0.15840700747042977 - 0.12717841193514737im, 0.024205127307119687 - 0.008936880890436897im, 0.00688918701759374 - 0.002514352364692355im, 0.0 + 0.0im, 0.021289037131137948 + 0.0im, 0.0019607163879200745 - 4.724513370269088e-5im, -0.0007297703364673361 - 8.664555134126806e-5im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0009606146195222607 + 0.0im, -0.00026914490007529085 + 0.0001030589355863503im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.00043490188981662594 + 0.0im], ℂ^4 ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5171034327160091 + 0.3616329568861237im, 0.11585090346126811 - 0.013437092390844141im, 0.014529776924048148 + 0.0037523711414873227im, 0.005132144869699878 + 0.0014391355388987841im, 0.46534470273965145 + 0.5851688764933998im, 0.16226101182442376 + 0.04175618601319747im, 0.018007367514509234 + 0.010975463229542385im, 0.004384691231790165 + 0.002602796628999334im, 0.007353711881318284 - 0.011090127120608383im, 0.0017933745433767797 - 0.0025879957011521733im  …  -0.0001545647096317201 - 0.0001213868272988329im, -9.199948949437841e-6 - 5.440289751636079e-5im, -6.487194214856466e-5 - 3.6770438495475636e-5im, 0.00029103835505508226 - 8.037235274927663e-5im, -4.28449149703897e-5 + 9.78874618522898e-5im, -4.1557039074457444e-5 - 7.82202247746698e-6im, 6.595847548519376e-5 + 4.431615506052696e-6im, -0.00015703753633431228 + 0.00016823220514807126im, -4.851614281619642e-5 + 0.00013436029560151634im, -2.115027522498374e-6 + 3.829316155176874e-5im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)]), FiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}(Union{Missing, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.2990845789412728 + 0.20085286931096952im, 0.14724735621130247 + 0.17357532295200231im, 0.3955849391035479 + 0.11053449397689297im, 0.23916253408916435 + 0.3244399102906943im, 0.2949939747648273 + 0.01116130966283374im, 0.15331063699786832 + 0.22523694609125056im, 0.41336918273648415 + 0.3278920015993373im, 0.07363469397040308 + 0.20503634796538384im, -0.18104880292823572 + 0.4684393494962113im, 0.47194651710395497 + 0.27094556802182573im  …  -0.2852653199247063 - 0.17758100541748137im, 0.3644633020482913 - 0.18579350839220551im, 0.1541572969349999 + 0.3113359463283323im, -0.22958525850589862 - 0.03465684140208751im, -0.3132417485066746 - 0.4078998121673141im, -0.05390274768830117 + 0.37298364455600685im, 0.1254128052235155 - 0.16323413215613633im, 0.1198200140113265 + 0.2260423674930758im, -0.3049353601044239 - 0.166852060991452im, 0.3911257826307405 + 0.1929759322975286im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4), TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.6033065686851775 + 0.2924221744539791im, 0.173826266248553 + 0.005336929551991106im, 0.16403423187248378 + 0.06293334233471173im, 0.08881057619490913 + 0.05088433397959219im, 0.3076512472684721 + 0.5630196587170965im, 0.11548483601042883 + 0.15087454932021205im, 0.07405667923997228 + 0.13580836563324009im, 0.05358392428269908 + 0.06619811051444734im, -0.4264047074746492 + 0.4182087554032096im, 0.15881811495797704 + 0.21826990056418866im  …  0.29007314433713566 + 0.21947740077763384im, -0.13968386202707384 + 0.29642527312950095im, -0.07908703540270827 + 0.16433872244029915im, -0.4044883694611974 + 0.13031817321637318im, 0.5375136004714278 - 0.24157102801668578im, -0.17900787476142632 + 0.11878146917640298im, 0.08837051026335187 + 0.01863494227812174im, -0.040848275123942186 - 0.5319886278175696im, 0.11502371349477694 + 0.20914112954566533im, 0.06615572026160896 + 0.19629043023064852im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4), TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.3954114814964793 + 0.4287232736166885im, 0.04541181592311082 + 0.13971418498930016im, 0.029363557401484844 + 0.028259082248367456im, 0.016826147330357127 + 0.0026275161588201457im, 0.5502452365929246 + 0.5467562773681265im, 0.13072116597746103 + 0.12123983400105141im, 0.019530211661833337 + 0.039587812475446835im, 0.02235581722319659 + 0.019111166733717225im, -0.10027041632511663 + 0.6590057920140161im, -0.09134626664001577 - 0.0992806423301687im  …  -0.04010155154118162 - 0.44549780930317634im, -0.14309257334897924 - 0.0894468195285064im, 0.3047133593136186 + 0.25286746651970277im, 0.25857956290066536 - 0.2038823953261505im, -0.03483373963233846 - 0.03800994342819912im, 0.07160756285523817 + 0.17497036134717384im, -0.08233062678127676 - 0.10785036386416468im, -0.6741706116418982 - 0.12709943463833767im, -0.4174879152834893 + 0.13289697801629477im, -0.10368141823370662 + 0.06780899862316322im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4), TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.6090342977039995 + 0.41498018333246145im, 0.06998901451167701 + 0.05466466304547446im, 0.009259108070555674 + 0.007348866913002202im, 0.006681859358778753 + 0.015222577684931739im, 0.36967640411242597 + 0.5497994223774119im, 0.08568512845974408 + 0.03251988278784587im, -0.013330102121546651 + 0.018907402744603886im, 0.007542716041209173 + 0.02518464600122832im, -0.20145957244206308 + 0.5917508459951449im, 0.05097203752338375 - 0.27328979625716154im  …  0.24249441445925835 - 0.09514505535352559im, -0.10542063829781279 - 0.17081541215697127im, 0.003868402445310573 + 0.03458654129943836im, -0.4619918146406143 + 0.05689198003684558im, 0.33020324430407705 - 0.24640176796376345im, 0.07971956162638372 - 0.21967667498716928im, 0.02934642665221339 + 0.015374885609719762im, -0.14809632052892002 - 0.33625311885249615im, -0.14853151596804381 + 0.5979430414848653im, 0.11768682670953141 + 0.16796025529332256im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4), TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.35722016431703096 + 0.49916820586852534im, 0.027513895304607648 + 0.06506869734557688im, 0.022363234867289986 + 0.013751091361701256im, 0.0008085031592912049 + 0.0033786803684658934im, 0.6823868672298171 + 0.3635781593114191im, 0.11362122211965622 + 0.07829218728796994im, 0.025194685785059283 - 0.0013962953633149637im, 0.003563983259135898 + 0.001686324092825936im, 0.7672423346502912 + 0.062236109658006106im, 0.14992732505770667 + 0.06563275357300269im  …  -0.11089915160883572 - 0.01368743803729584im, -0.001280613978467402 - 0.002847655961667162im, 0.024237868479454444 + 0.05443842267652527im, 0.012237295365540076 - 0.21200323626793002im, -0.09551288832407465 - 0.3096861238743198im, -0.015368703982496346 - 0.028098678700734764im, -0.1748781403998132 + 0.03714067076774158im, 0.850156019120926 - 0.16450199649034478im, 0.24282717269501064 + 0.0387219834232401im, 0.05442142772628136 - 0.009265182799915679im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], Union{Missing, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}}[missing, missing, missing, missing, missing], Union{Missing, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}}[missing, missing, missing, missing, missing], Union{Missing, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}[missing, missing, missing, missing, missing, TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}(ComplexF64[0.5244351339485234 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.4099987928173532 + 0.058195242705914176im, 0.16982307311897782 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.4761270405012685 + 0.12208788650906749im, -0.030618508240600827 + 0.10704477080956751im, 0.030431839551220016 + 0.0im, 0.0 + 0.0im, 0.47918510464434005 + 0.14804593657181686im, 0.12368545543316165 - 0.050932039842789746im, -0.0054291475711591665 + 0.011851167158291629im, 0.010935260248807224 + 0.0im], ℂ^4 ← ℂ^4)]), InfiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5438918323904265 + 0.49827794290033073im, 0.10682199382259307 + 0.02220631407337581im, 0.01700160682202177 + 0.004212394210361841im, 0.0034495232015169797 + 0.0030352094863048467im, 0.4759145011381743 + 0.4509316194654077im, 0.10411323364005334 + 0.050641200015229315im, 0.02009744043948998 + 0.001163040795561808im, 0.004847839779605181 + 0.0014146415372364im, 0.3483958992911082 - 0.5331892751762883im, 0.05371101891775232 - 0.11920408121135781im  …  -0.15901293200798652 - 0.027835563961690582im, -0.001493326319312662 - 0.03144180631766163im, -0.1491645441594139 - 0.08454881286209102im, 0.6692046226283289 - 0.18480571050901895im, -0.09851627682844752 + 0.22507941249361674im, -0.0955549746909119 - 0.01798571737815417im, 0.1516628854222841 + 0.010189920094210818im, -0.36108727051180745 + 0.38682794691695976im, -0.11155652332679673 + 0.30894392217557076im, -0.004863229091485816 + 0.08805011532121612im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5284399754163909 + 0.36956109504616624im, -0.6979124871478467 - 0.22415305251724568im, -0.19248598518612473 - 0.06638406060168114im, 0.03190186328503997 - 0.0005436833492400601im, 0.4755465303803926 + 0.5979976289935695im, 0.5110010457740632 + 0.35268967866937667im, 0.13936767635531253 + 0.08679346377360153im, -0.014267929126394713 - 0.0243134456461106im, 0.00751492850351454 - 0.011333257782098507im, 0.09602608713430016 + 0.007656918482537344im  …  -0.22368234004952187 - 0.07544195078486446im, -0.11320539733134974 - 0.15111775408187655im, -6.629414029224376e-5 - 3.7576562801894126e-5im, 0.014388567088627749 - 0.003891728163050813im, -0.07175871808504737 + 0.11088204083160805im, -0.08750112161399004 + 0.06418807040965713im, 6.740449387601237e-5 + 4.528770533903933e-6im, -0.007905047152041973 + 0.008271262413768578im, -0.03651763250489226 + 0.12311075106548491im, -0.014295604035399355 + 0.18551477116525664im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}(ComplexF64[0.9785471515635263 + 0.0im, 0.15840700747042977 - 0.12717841193514737im, 0.024205127307119687 - 0.008936880890436897im, 0.00688918701759374 - 0.002514352364692355im, 0.0 + 0.0im, 0.021289037131137948 + 0.0im, 0.0019607163879200745 - 4.724513370269088e-5im, -0.0007297703364673361 - 8.664555134126806e-5im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0009606146195222607 + 0.0im, -0.00026914490007529085 + 0.0001030589355863503im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.00043490188981662594 + 0.0im], ℂ^4 ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5171034327160091 + 0.3616329568861237im, 0.11585090346126811 - 0.013437092390844141im, 0.014529776924048148 + 0.0037523711414873227im, 0.005132144869699878 + 0.0014391355388987841im, 0.46534470273965145 + 0.5851688764933998im, 0.16226101182442376 + 0.04175618601319747im, 0.018007367514509234 + 0.010975463229542385im, 0.004384691231790165 + 0.002602796628999334im, 0.007353711881318284 - 0.011090127120608383im, 0.0017933745433767797 - 0.0025879957011521733im  …  -0.0001545647096317201 - 0.0001213868272988329im, -9.199948949437841e-6 - 5.440289751636079e-5im, -6.487194214856466e-5 - 3.6770438495475636e-5im, 0.00029103835505508226 - 8.037235274927663e-5im, -4.28449149703897e-5 + 9.78874618522898e-5im, -4.1557039074457444e-5 - 7.82202247746698e-6im, 6.595847548519376e-5 + 4.431615506052696e-6im, -0.00015703753633431228 + 0.00016823220514807126im, -4.851614281619642e-5 + 0.00013436029560151634im, -2.115027522498374e-6 + 3.829316155176874e-5im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)]))</code></pre><p>Algorithms will then act on this window of tensors, while leaving the left and right infinite states invariant.</p><h2 id="MultilineMPS"><a class="docs-heading-anchor" href="#MultilineMPS">MultilineMPS</a><a id="MultilineMPS-1"></a><a class="docs-heading-anchor-permalink" href="#MultilineMPS" title="Permalink"></a></h2><p>A two-dimensional classical partition function can often be represented by an infinite tensor network. There are many ways to evaluate such a network, but here we focus on the so-called boundary MPS methods. These first reduce the problem from contracting a two-dimensional network to the contraction of a one-dimensional MPS, by finding the fixed point of the row-to-row (or column-to-column) transfer matrix. In these cases however, there might be a non-trivial periodicity in both the horizontal as well as vertical direction. Therefore, in MPSKit they are represented by <a href="#MultilineMPS"><code>MultilineMPS</code></a>, which are simply a repeating set of <a href="#InfiniteMPS"><code>InfiniteMPS</code></a>.</p><pre><code class="language-julia hljs">state = MultilineMPS(fill(infinite_state, 2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MultilineMPS{InfiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}}(InfiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}[InfiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5438918323904265 + 0.49827794290033073im, 0.10682199382259307 + 0.02220631407337581im, 0.01700160682202177 + 0.004212394210361841im, 0.0034495232015169797 + 0.0030352094863048467im, 0.4759145011381743 + 0.4509316194654077im, 0.10411323364005334 + 0.050641200015229315im, 0.02009744043948998 + 0.001163040795561808im, 0.004847839779605181 + 0.0014146415372364im, 0.3483958992911082 - 0.5331892751762883im, 0.05371101891775232 - 0.11920408121135781im  …  -0.15901293200798652 - 0.027835563961690582im, -0.001493326319312662 - 0.03144180631766163im, -0.1491645441594139 - 0.08454881286209102im, 0.6692046226283289 - 0.18480571050901895im, -0.09851627682844752 + 0.22507941249361674im, -0.0955549746909119 - 0.01798571737815417im, 0.1516628854222841 + 0.010189920094210818im, -0.36108727051180745 + 0.38682794691695976im, -0.11155652332679673 + 0.30894392217557076im, -0.004863229091485816 + 0.08805011532121612im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5284399754163909 + 0.36956109504616624im, -0.6979124871478467 - 0.22415305251724568im, -0.19248598518612473 - 0.06638406060168114im, 0.03190186328503997 - 0.0005436833492400601im, 0.4755465303803926 + 0.5979976289935695im, 0.5110010457740632 + 0.35268967866937667im, 0.13936767635531253 + 0.08679346377360153im, -0.014267929126394713 - 0.0243134456461106im, 0.00751492850351454 - 0.011333257782098507im, 0.09602608713430016 + 0.007656918482537344im  …  -0.22368234004952187 - 0.07544195078486446im, -0.11320539733134974 - 0.15111775408187655im, -6.629414029224376e-5 - 3.7576562801894126e-5im, 0.014388567088627749 - 0.003891728163050813im, -0.07175871808504737 + 0.11088204083160805im, -0.08750112161399004 + 0.06418807040965713im, 6.740449387601237e-5 + 4.528770533903933e-6im, -0.007905047152041973 + 0.008271262413768578im, -0.03651763250489226 + 0.12311075106548491im, -0.014295604035399355 + 0.18551477116525664im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}(ComplexF64[0.9785471515635263 + 0.0im, 0.15840700747042977 - 0.12717841193514737im, 0.024205127307119687 - 0.008936880890436897im, 0.00688918701759374 - 0.002514352364692355im, 0.0 + 0.0im, 0.021289037131137948 + 0.0im, 0.0019607163879200745 - 4.724513370269088e-5im, -0.0007297703364673361 - 8.664555134126806e-5im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0009606146195222607 + 0.0im, -0.00026914490007529085 + 0.0001030589355863503im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.00043490188981662594 + 0.0im], ℂ^4 ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5171034327160091 + 0.3616329568861237im, 0.11585090346126811 - 0.013437092390844141im, 0.014529776924048148 + 0.0037523711414873227im, 0.005132144869699878 + 0.0014391355388987841im, 0.46534470273965145 + 0.5851688764933998im, 0.16226101182442376 + 0.04175618601319747im, 0.018007367514509234 + 0.010975463229542385im, 0.004384691231790165 + 0.002602796628999334im, 0.007353711881318284 - 0.011090127120608383im, 0.0017933745433767797 - 0.0025879957011521733im  …  -0.0001545647096317201 - 0.0001213868272988329im, -9.199948949437841e-6 - 5.440289751636079e-5im, -6.487194214856466e-5 - 3.6770438495475636e-5im, 0.00029103835505508226 - 8.037235274927663e-5im, -4.28449149703897e-5 + 9.78874618522898e-5im, -4.1557039074457444e-5 - 7.82202247746698e-6im, 6.595847548519376e-5 + 4.431615506052696e-6im, -0.00015703753633431228 + 0.00016823220514807126im, -4.851614281619642e-5 + 0.00013436029560151634im, -2.115027522498374e-6 + 3.829316155176874e-5im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)]), InfiniteMPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5438918323904265 + 0.49827794290033073im, 0.10682199382259307 + 0.02220631407337581im, 0.01700160682202177 + 0.004212394210361841im, 0.0034495232015169797 + 0.0030352094863048467im, 0.4759145011381743 + 0.4509316194654077im, 0.10411323364005334 + 0.050641200015229315im, 0.02009744043948998 + 0.001163040795561808im, 0.004847839779605181 + 0.0014146415372364im, 0.3483958992911082 - 0.5331892751762883im, 0.05371101891775232 - 0.11920408121135781im  …  -0.15901293200798652 - 0.027835563961690582im, -0.001493326319312662 - 0.03144180631766163im, -0.1491645441594139 - 0.08454881286209102im, 0.6692046226283289 - 0.18480571050901895im, -0.09851627682844752 + 0.22507941249361674im, -0.0955549746909119 - 0.01798571737815417im, 0.1516628854222841 + 0.010189920094210818im, -0.36108727051180745 + 0.38682794691695976im, -0.11155652332679673 + 0.30894392217557076im, -0.004863229091485816 + 0.08805011532121612im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5284399754163909 + 0.36956109504616624im, -0.6979124871478467 - 0.22415305251724568im, -0.19248598518612473 - 0.06638406060168114im, 0.03190186328503997 - 0.0005436833492400601im, 0.4755465303803926 + 0.5979976289935695im, 0.5110010457740632 + 0.35268967866937667im, 0.13936767635531253 + 0.08679346377360153im, -0.014267929126394713 - 0.0243134456461106im, 0.00751492850351454 - 0.011333257782098507im, 0.09602608713430016 + 0.007656918482537344im  …  -0.22368234004952187 - 0.07544195078486446im, -0.11320539733134974 - 0.15111775408187655im, -6.629414029224376e-5 - 3.7576562801894126e-5im, 0.014388567088627749 - 0.003891728163050813im, -0.07175871808504737 + 0.11088204083160805im, -0.08750112161399004 + 0.06418807040965713im, 6.740449387601237e-5 + 4.528770533903933e-6im, -0.007905047152041973 + 0.008271262413768578im, -0.03651763250489226 + 0.12311075106548491im, -0.014295604035399355 + 0.18551477116525664im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}(ComplexF64[0.9785471515635263 + 0.0im, 0.15840700747042977 - 0.12717841193514737im, 0.024205127307119687 - 0.008936880890436897im, 0.00688918701759374 - 0.002514352364692355im, 0.0 + 0.0im, 0.021289037131137948 + 0.0im, 0.0019607163879200745 - 4.724513370269088e-5im, -0.0007297703364673361 - 8.664555134126806e-5im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0009606146195222607 + 0.0im, -0.00026914490007529085 + 0.0001030589355863503im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.00043490188981662594 + 0.0im], ℂ^4 ← ℂ^4)], TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}(ComplexF64[0.5171034327160091 + 0.3616329568861237im, 0.11585090346126811 - 0.013437092390844141im, 0.014529776924048148 + 0.0037523711414873227im, 0.005132144869699878 + 0.0014391355388987841im, 0.46534470273965145 + 0.5851688764933998im, 0.16226101182442376 + 0.04175618601319747im, 0.018007367514509234 + 0.010975463229542385im, 0.004384691231790165 + 0.002602796628999334im, 0.007353711881318284 - 0.011090127120608383im, 0.0017933745433767797 - 0.0025879957011521733im  …  -0.0001545647096317201 - 0.0001213868272988329im, -9.199948949437841e-6 - 5.440289751636079e-5im, -6.487194214856466e-5 - 3.6770438495475636e-5im, 0.00029103835505508226 - 8.037235274927663e-5im, -4.28449149703897e-5 + 9.78874618522898e-5im, -4.1557039074457444e-5 - 7.82202247746698e-6im, 6.595847548519376e-5 + 4.431615506052696e-6im, -0.00015703753633431228 + 0.00016823220514807126im, -4.851614281619642e-5 + 0.00013436029560151634im, -2.115027522498374e-6 + 3.829316155176874e-5im], (ℂ^4 ⊗ ℂ^2) ← ℂ^4)])])</code></pre><p>They offer some convenience functionality for using cartesian indexing (row - column):</p><p>You can access properties by calling</p><pre><code class="language-julia hljs">row = 2
col = 2
al = state.AL[row, col];</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2←4 TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 1, Vector{ComplexF64}}:
 codomain: (ℂ^4 ⊗ ℂ^2)
 domain: ⊗(ℂ^4)
</code></pre><p>These objects are also used extensively in the context of <a href="https://github.com/QuantumKitHub/PEPSKit.jl">PEPSKit.jl</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Prerequisites</a><a class="docs-footer-nextpage" href="../operators/">Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Saturday 15 November 2025 01:22">Saturday 15 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
