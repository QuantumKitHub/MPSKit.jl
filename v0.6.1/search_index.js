var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library-documentation-1","page":"Library documentation","title":"Library documentation","text":"","category":"section"},{"location":"lib/lib/#lib_states-1","page":"Library documentation","title":"States","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"FiniteMPS\nInfiniteMPS\nMPSComoving\nMPSMultiline","category":"page"},{"location":"lib/lib/#MPSKit.FiniteMPS","page":"Library documentation","title":"MPSKit.FiniteMPS","text":"mutable struct FiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor} <: AbstractMPS\n\nRepresents a finite matrix product state\n\nWhen queried for AL/AR/AC/CL it will check if it is missing.     If not, return     If it is, calculate it, store it and return\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.InfiniteMPS","page":"Library documentation","title":"MPSKit.InfiniteMPS","text":"struct InfiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor}\n\nRepresents an infinite matrix product state The state is stored in the centergauge where     state.AL[i]state.CR[i] = state.AC[i] = state.CR[i-1]state.AR[i]\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSComoving","page":"Library documentation","title":"MPSKit.MPSComoving","text":"MPSComoving(leftstate,window,rightstate)\n\nmuteable window of tensors on top of an infinite chain\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Operators-1","page":"Library documentation","title":"Operators","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPOHamiltonian\nInfiniteMPO","category":"page"},{"location":"lib/lib/#MPSKit.MPOHamiltonian","page":"Library documentation","title":"MPSKit.MPOHamiltonian","text":"MPOHamiltonian\n\nrepresents a general periodic quantum hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.InfiniteMPO","page":"Library documentation","title":"MPSKit.InfiniteMPO","text":"Represents a periodic statmech mpo\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Environments-1","page":"Library documentation","title":"Environments","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPSKit.AbstractInfEnv\nMPSKit.PerMPOInfEnv\nMPSKit.MPOHamInfEnv\nMPSKit.FinEnv\nMPSKit.SimpleEnv\nMPSKit.OvlEnv","category":"page"},{"location":"lib/lib/#MPSKit.AbstractInfEnv","page":"Library documentation","title":"MPSKit.AbstractInfEnv","text":"Abstract environment for an infinite state\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PerMPOInfEnv","page":"Library documentation","title":"MPSKit.PerMPOInfEnv","text":"This object manages the periodic mpo environments for an MPSMultiline\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPOHamInfEnv","page":"Library documentation","title":"MPSKit.MPOHamInfEnv","text":"This object manages the hamiltonian environments for an InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.FinEnv","page":"Library documentation","title":"MPSKit.FinEnv","text":"FinEnv keeps track of the environments for FiniteMPS / MPSComoving\nIt automatically checks if the queried environment is still correctly cached and if not - recalculates\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Generic-actions-1","page":"Library documentation","title":"Generic actions","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"c_prime\nac_prime\nac2_prime\nexpectation_value","category":"page"},{"location":"lib/lib/#MPSKit.c_prime","page":"Library documentation","title":"MPSKit.c_prime","text":"Zero-site derivative (the C matrix to the right of pos)\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac_prime","page":"Library documentation","title":"MPSKit.ac_prime","text":"One-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac2_prime","page":"Library documentation","title":"MPSKit.ac2_prime","text":"Two-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.expectation_value","page":"Library documentation","title":"MPSKit.expectation_value","text":"calculates the expectation value of op, where op is a plain tensormap where the first index works on site at\n\n\n\n\n\ncalculates the expectation value of op = op1op2op3*... (ie an N site operator) starting at site at\n\n\n\n\n\ncalculates the expectation value for the given operator/hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#Algorithms-1","page":"Library documentation","title":"Algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"find_groundstate\ntimestep\nleading_boundary\ndynamicaldmrg\nchangebonds\nexcitations\napproximate","category":"page"},{"location":"lib/lib/#MPSKit.timestep","page":"Library documentation","title":"MPSKit.timestep","text":"function timestep(psi, operator, dt, alg,envs = environments(psi,operator))\n\ntime evolves psi by timestep dt using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.leading_boundary","page":"Library documentation","title":"MPSKit.leading_boundary","text":"leading_boundary(state,opp,alg,envs=environments(state,ham))\n\napproximate the leading eigenvector for opp\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.dynamicaldmrg","page":"Library documentation","title":"MPSKit.dynamicaldmrg","text":"https://arxiv.org/pdf/cond-mat/0203500.pdf\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.excitations","page":"Library documentation","title":"MPSKit.excitations","text":"excitations(H::Hamiltonian, alg::QuasiparticleAnsatz, args...; kwargs...)\n\nCompute the first excited states and their energy gap above a groundstate.\n\nThis is an implementation of the algorithm found here.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#lib_gs_alg-1","page":"Library documentation","title":"Groundstate algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Vumps\nIdmrg1\nIdmrg2\nDmrg\nDmrg2\nGradientGrassmann","category":"page"},{"location":"lib/lib/#MPSKit.Vumps","page":"Library documentation","title":"MPSKit.Vumps","text":"see https://arxiv.org/abs/1701.07035\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Idmrg1","page":"Library documentation","title":"MPSKit.Idmrg1","text":"onesite infinite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Idmrg2","page":"Library documentation","title":"MPSKit.Idmrg2","text":"twosite infinite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg","page":"Library documentation","title":"MPSKit.Dmrg","text":"onesite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg2","page":"Library documentation","title":"MPSKit.Dmrg2","text":"twosite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.GradientGrassmann","page":"Library documentation","title":"MPSKit.GradientGrassmann","text":"GradientGrassmann is an optimisation methdod that keeps the MPS in left-canonical form, and treats the tensors as points on Grassmann manifolds. It then applies one of the standard gradient optimisation methods, e.g. conjugate gradient, to the MPS, making use of the Riemannian manifold structure. A preconditioner is used, so that effectively the metric used on the manifold is that given by the Hilbert space inner product.\n\nThe arguments to the constructor are method = OptimKit.ConjugateGradient     The gradient optimisation method to be used. Should either be an instance or a subtype     of OptimKit.OptimizationAlgorithm. If it's an instance, this method is simply used     to do the optimisation. If it's a subtype, then an instance is constructed as     method(; maxiter=maxiter, verbosity=verbosity, gradtol=tol)\n\nfinalize! = OptimKit._finalize!     A function that gets called once each iteration. See OptimKit for details.\n\ntol = Defaults.tol maxiter = Defaults.maxiter verbosity = 2     Arguments passed to the method constructor. If method is an instance of     OptimKit.OptimizationAlgorithm, these argument are ignored.\n\nIn other words, by default conjugate gradient is used. One can easily set tol, maxiter and verbosity for it, or switch to LBFGS or gradient descent by setting method. If more control is wanted over things like specifics of the linesearch, CG flavor or the m parameter of LBFGS, then the user should create the OptimKit.OptimizationAlgorithm instance manually and pass it as method.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_time_alg-1","page":"Library documentation","title":"Time evolution algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Tdvp\nTdvp2","category":"page"},{"location":"lib/lib/#MPSKit.Tdvp","page":"Library documentation","title":"MPSKit.Tdvp","text":"onesite tdvp\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Tdvp2","page":"Library documentation","title":"MPSKit.Tdvp2","text":"twosite tdvp (works for finite mps's)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_bound_alg-1","page":"Library documentation","title":"Leading boundary algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Vumps\nPowerMethod","category":"page"},{"location":"lib/lib/#lib_bc_alg-1","page":"Library documentation","title":"Bond change algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"OptimalExpand\nRandExpand\nVumpsSvdCut\nSvdCut","category":"page"},{"location":"lib/lib/#MPSKit.OptimalExpand","page":"Library documentation","title":"MPSKit.OptimalExpand","text":"expands the given mps using the algorithm given in the vumps paper\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.RandExpand","page":"Library documentation","title":"MPSKit.RandExpand","text":"expands the bond dimension by adding random unitary vectors\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.VumpsSvdCut","page":"Library documentation","title":"MPSKit.VumpsSvdCut","text":"use an idmrg2 step to truncate/expand the bond dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SvdCut","page":"Library documentation","title":"MPSKit.SvdCut","text":"Truncate a given state using svd\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#[Excitations]-1","page":"Library documentation","title":"[Excitations]","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"QuasiparticleAnsatz\nFiniteExcited","category":"page"},{"location":"tut/timeev/#DQPT-in-ising-1","page":"DQPT in ising","title":"DQPT in ising","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"In this tutorial we will try to reproduce the results from this paper. The needed packages are","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"using MPSKit,MPSKitModels,TensorKit,ProgressMeter","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Dynamical quantum phase transitions (DQPT in short) are signatures of equilibrium phase transitions in a dynamical quantity - the loschmidth echo. This quantity is given by L(t) = frac-2N ln(  psi(t)  psi(0)  ) where N is the system size. One typically starts from a groundstate and then quenches the hamiltonian to a different point. Non analycities in the loschmidth echo are called 'dynamical quantum phase transitions'.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"In the mentioned paper they work with H(g) = - sum^N-1_i=1 sigma^z_i sigma^z_i+1 + g sum_i=1^N sigma^x_i and show that divergences occur when quenching across the critical point (g₀→g₁) for t^*_n = t^*(n+frac12) with t^* = pie(g_1k^*), cos(k^*) = (1+g_0 g_1)  (g_0 + g_1), e(gk) = sqrt(g-cos k)^2 + sin^2 k.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"The outline of the tutorial is as follows. We will pick g₀ = 0.5, g₁ = 2.0, perform the time evolution at different system sizes and compare with the thermodynamic limit. For those g we expect non-analicities to occur at t_n  235 (n + 12).","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"First we construct the hamiltonian in mpo form:","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function ising_ham(g)\n    (σˣ,σʸ,σᶻ) = nonsym_spintensors(1//2).*2;\n\n    data = Array{Any,3}(missing,1,3,3);\n    data[1,1,1] = one(σˣ); data[1,end,end] = one(σˣ);\n    data[1,1,2] = -σᶻ;\n    data[1,2,end] = σᶻ;\n    data[1,1,end] = g*σˣ;\n\n    MPOHamiltonian(data);\nend","category":"page"},{"location":"tut/timeev/#Finite-MPS-quenching-1","page":"DQPT in ising","title":"Finite MPS quenching","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Construct an initial finite system","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"len = 20;\ninit = FiniteMPS(rand,ComplexF64,len,ℂ^2,ℂ^10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Find the pre-quench groundstate","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(ψ₀,_) = find_groundstate(init,ising_ham(0.5),Dmrg());","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"We can define a help function that measures the loschmith echo","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"echo(ψ₀::FiniteMPS,ψₜ::FiniteMPS) = -2*log(abs(dot(ψ₀,ψₜ)))/length(ψ₀)\n@assert isapprox(echo(ψ₀,ψ₀),0,atol=1e-10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"we will initially use a 2site tdvp scheme to increase the bond dimension while time evolving, and later on switch to a faster one-site scheme. A single timestep can be done using","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"ψₜ = deepcopy(ψ₀);\ndt = 0.01;\n\n(ψₜ,envs) = timestep(ψₜ,ising_ham(2),dt,Tdvp2(trscheme=truncdim(20)));","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"\"envs\" is a kind of cache object that keeps track of all environments in ψ. It is often advantageous to re-use the environment, so that mpskit doesn't need to recalculate everything.","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Putting it all together, we get","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function finite_sim(len; dt = 0.05, finaltime = 5.0)\n    ψ₀ = FiniteMPS(rand,ComplexF64,len,ℂ^2,ℂ^10);\n    (ψ₀,_) = find_groundstate(ψ₀,ising_ham(0.5),Dmrg());\n\n    post_quench_ham = ising_ham(2);\n    ψₜ = deepcopy(ψ₀);\n    envs = environments(ψₜ,post_quench_ham);\n\n    echos = [echo(ψₜ,ψ₀)];\n    times = collect(0:dt:finaltime);\n\n    @showprogress for t = times[2:end]\n        alg = t > 3*dt ? Tdvp() : Tdvp2(trscheme = truncdim(50))\n        (ψₜ,envs) = timestep(ψₜ,post_quench_ham,dt,alg,envs);\n        push!(echos,echo(ψₜ,ψ₀))\n    end\n\n    return (times,echos)\nend","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(Image: )","category":"page"},{"location":"tut/timeev/#Infinite-MPS-quenching-1","page":"DQPT in ising","title":"Infinite MPS quenching","text":"","category":"section"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"Similarly we start with an initial infinite state","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"init = InfiniteMPS([ℂ^2],[ℂ^10]);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"and find the pre-quench groundstate","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(ψ₀,_) = find_groundstate(init,ising_ham(0.5),Vumps());","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"The dot product of two infinite matrix product states scales as  alpha ^N where α is the dominant eigenvalue of the transfer matrix. It is this α that is returned when calling","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"dot(ψ₀,ψ₀)","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"so the loschmidth echo takes on the pleasant form","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"echo(ψ₀::InfiniteMPS,ψₜ::InfiniteMPS) = -2*log(abs(dot(ψ₀,ψₜ)))\n@assert isapprox(echo(ψ₀,ψ₀),0,atol=1e-10);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"This time we cannot use a 2site scheme to grow the bond dimension, as this isn't implemented (yet). Instead, we have to make use of the changebonds machinery. Multiple algorithms are available, but we will only focus on OptimalEpand(). Growing the bond dimension by 5 can be done by calling:","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"ψₜ = deepcopy(ψ₀);\n(ψₜ,envs) = changebonds(ψₜ,ising_ham(2),OptimalExpand(trscheme=truncdim(5)));","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"a single timestep is easy","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"dt = 0.01;\n\n(ψₜ,envs) = timestep(ψₜ,ising_ham(2),dt,Tdvp(),envs);","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"With performance in mind we should once again try to re-use these \"envs\" cache objects. The final code is","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"function infinite_sim(dt = 0.05, finaltime = 5.0)\n    ψ₀ = InfiniteMPS([ℂ^2],[ℂ^10]);\n    (ψ₀,_) = find_groundstate(ψ₀,ising_ham(0.5),Vumps());\n\n    post_quench_ham = ising_ham(2);\n    ψₜ = deepcopy(ψ₀);\n    envs = environments(ψₜ,post_quench_ham);\n\n    echos = [echo(ψₜ,ψ₀)];\n    times = collect(0:dt:finaltime);\n\n    @showprogress for t = times[2:end]\n        if t < 50*dt # if t is sufficiently small, we increase the bond dimension\n            (ψₜ,envs) = changebonds(ψₜ,post_quench_ham,OptimalExpand(trscheme=truncdim(1)),envs)\n        end\n        (ψₜ,envs) = timestep(ψₜ,post_quench_ham,dt,Tdvp(),envs);\n        push!(echos,echo(ψₜ,ψ₀))\n    end\n\n    return (times,echos)\nend","category":"page"},{"location":"tut/timeev/#","page":"DQPT in ising","title":"DQPT in ising","text":"(Image: )","category":"page"},{"location":"man/environments/#um_environments-1","page":"Environments","title":"Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"In many tensor network algorithms we encounter partially contracted tensor networks. In dmrg for example, one needs to know the sum of all the hamiltonian contributions left and right of the site that we want to optimize. If you then optimize the neighboring site to the right, you only need to add one new contribution to the previous sum of hamiltonian contributions.","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This kind of information is stored in the environment objects (at the moment called \"Cache\" in our code, but the name is subject to change). The goal is that the user should preferably never have to deal with the caches, but being aware of the inner workings may allow you to write more efficient code. That is why they are nonetheless included in the manual.","category":"page"},{"location":"man/environments/#Finite-Environments-1","page":"Environments","title":"Finite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"When you create a state and a hamiltonian:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"an environment object can be created by calling","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache = environments(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"The partially contracted mpohamiltonian left of site i can then be queried using:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This may take some time, but a subsequent call to","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i-1,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Should pretty much be free. Behind the scenes the cache stored all tensors it used to calculate leftenv (state.AL[1 .. i]) and when queried again, it checks if the tensors it previously used are identical (using ===). If so, it can simply return the previously stored results. If not, it will recalculate again. If you update a tensor in-place, the caches cannot know using === that the actual tensors have changed. If you do this, you have to call poison!(state,i).","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"As an optional argument, many algorithms allow you to pass in an environment object, and they also return an updated one. Therefore, for time evolution code, it is more efficient to give it the updated caches every time step, instead of letting it recalculate.","category":"page"},{"location":"man/environments/#Infinite-Environments-1","page":"Environments","title":"Infinite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Infinite Environments are very similar :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\ncache = environments(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"There are also some notable differences. Infinite environments typically require solving linear problems or eigenvalue problems iteratively with finite precision. To find out what precision we used we can type:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"(cache.tol,cache.maxiter)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"To recalculate with a different precision :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache.tol=1e-8;\nrecalculate!(cache,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Unlike their finite counterparts, recalculating is not done automatically. To get the environment for a different state one has to recalculate explicitly!","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"different_state = InfiniteMPS([ℂ^2],[ℂ^10]);\nrecalculate!(cache,different_state)\nleftenv(cache,3,different_state)","category":"page"},{"location":"man/conventions/#Conventions-1","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"MPSKit is build on top of TensorKit, which in turn defines general (codomain ← domain) tensormaps. It is necessary to concretely define what we should consider an mps tensor (for example - what leg is its physical leg?), a bond tensor, and an mpo tensor.","category":"page"},{"location":"man/conventions/#MPS-tensors-1","page":"Conventions","title":"MPS tensors","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"The general definition of an mps tensor is as follows","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"(Image: )","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"mps tensors are well defined for any amount of physical legs and InfiniteMPS/FiniteMPS handle these general N-leg tensors just fine. This is necessary in for example peps code, where the number of physical spaces of a boundary mps tensor is 2.","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"However our operators MPOHamiltonian/InfiniteMPO both only work on mps tensors with one leg. There is no fundamental problem, anyone is free to implement new operators working on the more general mps tensors.","category":"page"},{"location":"man/conventions/#Bond-tensors-1","page":"Conventions","title":"Bond tensors","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"The mps bond tensors are square tensormaps, mapping a virtual space to the same virtual space. (Image: )","category":"page"},{"location":"man/conventions/#MPO-tensors-1","page":"Conventions","title":"MPO tensors","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"MPO tensors are used in both statistical mechanics problems and in the definition of quantum hamiltonians. Graphically, they can be represented as follows","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"(Image: )","category":"page"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"The numbering of spaces results in an at first glance not very intuitive ordering of (virtual,physical,physical,virtual) spaces.","category":"page"},{"location":"man/conventions/#Planarity-1","page":"Conventions","title":"Planarity","text":"","category":"section"},{"location":"man/conventions/#","page":"Conventions","title":"Conventions","text":"MPSKit tries to be as planar as possible, braidings are avoided as often as possible. As a result, it can handle anyonic/fermionic symmetries. Behind the scenes we always check if a contraction is done with tensors for which the braiding rules are trivial - and if not we use TensorKit's @planar macro. The logic of this switching between normal and planar tensor contractions is contained in a private @plansor macro. This is mostly an implementation detail, and the user should not have to worry about this.","category":"page"},{"location":"tut/haldane/#tut_haldane-1","page":"The haldane gap","title":"The haldane gap","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"In this tutorial we will calculate the haldane gap (the energy gap in spin 1 heisenberg) in 2 different ways. To follow the tutorial you need the following packages.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"using MPSKit,MPSKitModels,TensorKit,Plots","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"We will enforce the su(2) symmetry, our hamiltonian will therefore be","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"ham = su2_xxx_ham(spin=1);","category":"page"},{"location":"tut/haldane/#Finite-size-extrapolation-1","page":"The haldane gap","title":"Finite size extrapolation","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The first step is always the same, we want to find the groundstate of our system.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"len = 10;\nphysical_space = Rep[SU₂](1=>1);\nvirtual_space = Rep[SU₂](0=>20,1=>20,2=>10,3=>10,4=>5);\n\ninitial_state = FiniteMPS(rand,ComplexF64,len,physical_space,virtual_space);\n(gs,envs,delta) = find_groundstate(initial_state,ham,Dmrg());","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The typical way to find excited states is to minmize the energy while adding an error term lambda  gs   gs . Here we will instead use the quasiparticle ansatz.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"In steven white's original DMRG paper it was remarked that the S=1 excitations correspond to edge states, and that one should define the haldane gap as the difference in energy between the S=2 and S=1 states. This can be done as follows.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(En_1,st_1) = excitations(ham,QuasiparticleAnsatz(),gs,envs,sector = SU₂(1))\n(En_2,st_2) = excitations(ham,QuasiparticleAnsatz(),gs,envs,sector = SU₂(2))\nfinite_haldane_gap = En_2[1]-En_1[1]","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"We can go even further and doublecheck the claim that S=1 is an edge excitation, by plotting the energy density.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"pl = plot(xaxis=\"position\",yaxis=\"energy density\")\nplot!(pl,real.(expectation_value(st_1[1],ham)-expectation_value(gs,ham)),label = \"S=1\")\nplot!(pl,real.(expectation_value(st_2[1],ham)-expectation_value(gs,ham)),label = \"S=2\")","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"Extrapolating for different len gives an approximate haldane gap.","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#Thermodynamic-limit-1","page":"The haldane gap","title":"Thermodynamic limit","text":"","category":"section"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"A much nicer way of obtaining the haldane gap is by working directly in the thermodynamic limit. We must be careful in selecting the symmetry sectors, the only correct choice is to work with half-integer charges (this is an SPT phase).","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"virtual_space = Rep[SU₂](1//2=>20,3//2=>20,5//2=>10,7//2=>10,9//2=>5); # this is bond dimension 300!\ninitial_state = InfiniteMPS([physical_space],[virtual_space]);\n(gs,envs,delta) = find_groundstate(initial_state,ham,Vumps());","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"One difference with the finite size case is that we not only can - but also have to - specify a momentum label. We can scan for k = 0 to pi by calling:","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"kspace = 0:0.1:pi\n(Energies,_) = excitations(ham,QuasiparticleAnsatz(),kspace,gs,envs,sector=SU₂(1));","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(Image: )","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"The minimima sits at k = pi, with corresponding value","category":"page"},{"location":"tut/haldane/#","page":"The haldane gap","title":"The haldane gap","text":"(En,_) = excitations(ham,QuasiparticleAnsatz(),Float64(pi),gs,envs,sector=SU₂(1));\n@assert En[1]  ≈ 0.41047925 atol=1e-4","category":"page"},{"location":"man/states/#um_states-1","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/#FiniteMPS-1","page":"States","title":"FiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A FiniteMPS is - at its core - a chain of mps tensors.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"(Image: )","category":"page"},{"location":"man/states/#Usage-1","page":"States","title":"Usage","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A FiniteMPS can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^1),10);\nFiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Or alternatively by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"len = 10;\nmax_bond_dimension = ℂ^10;\nphysical_space = ℂ^2;\nFiniteMPS(rand,ComplexF64,len,physical_space,max_bond_dimension);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can take dot products, renormalize!, expectation values,....","category":"page"},{"location":"man/states/#Gauging-1","page":"States","title":"Gauging","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"There is residual gauge freedom in such a finite mps :","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"(Image: )","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"which is often exploited in mps algorithms. The gauging logic is handled behind the scenes, if you call","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"then the state will be gauged such that the third tensor is a left isometry (similarly for state.AR).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AC[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"gauges the state in such a way that all tensors to the left are left isometries, and to the right will be right isometries.As a result you should have","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"lastly there is also the CR field, with the following property:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"@tensor a[-1 -2;-3] := state.AL[3][-1 -2;1]*state.CR[3][1;-3]\n@tensor b[-1 -2;-3] := state.CR[2][-1;1]*state.AR[3][1 -2;-3]\na ≈ state.AC[3];\nb ≈ state.AC[3];","category":"page"},{"location":"man/states/#Implementation-details-1","page":"States","title":"Implementation details","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Behind the scenes, a finite mps has 4 fields","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"ALs::Vector{Union{Missing,A}}\nARs::Vector{Union{Missing,A}}\nACs::Vector{Union{Missing,A}}\nCLs::Vector{Union{Missing,B}}","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"calling state.AC returns an \"orthoview\" instance, which is a very simple dummy object. When you call get/setindex on an orthoview, it will move the gauge for the underlying state, and return the result. The idea behind this construction is that one never has to worry about how the state is gauged, as this gets handled automagically.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The following bit of code shows the logic in action:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state = FiniteMPS(10,ℂ^2,ℂ^10); # a random initial state\n@show ismissing.(state.ALs) # all AL fields are already calculated\n@show ismissing.(state.ARs) # all AR fields are missing\n\n#if we now query state.AC[2], it should calculate and store all AR fields left of position 2\nstate.AC[2];\n@show ismissing.(state.ARs)","category":"page"},{"location":"man/states/#InfiniteMPS-1","page":"States","title":"InfiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"An infinite mps can be thought of as a finite mps, where the set of tensors is repeated periodically.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2);\nInfiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The above code would create an infinite mps with an A-B structure (a 2 site unit cell).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"much like a finite mps, we can again query the fields state.AL, state.AR, state.AC and state.CR. The implementation is much easier, as they are now just plain fields in the struct","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"AL::PeriodicArray{A,1}\nAR::PeriodicArray{A,1}\nCR::PeriodicArray{B,1}\nAC::PeriodicArray{A,1}","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The periodic array is an array-like type where all indices are repeated periodically.","category":"page"},{"location":"man/states/#MPSComoving-1","page":"States","title":"MPSComoving","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"MPSComoving is a bit of a mix between an infinite mps and a finite mps. It represents a window of mutable tensors embedded in an infinite mps.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created using:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"mpco = MPSComoving(left_infinite_mps,window_of_tensors,right_infinite_mps)","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Algorithms will then act on this window of tensors, while leaving the left and right infinite mps's invariant.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Behind the scenes it uses the same orthoview logic as finitemps.","category":"page"},{"location":"man/states/#Multiline-1","page":"States","title":"Multiline","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Statistical physics partition functions can be represented by an infinite tensor network which then needs to be contracted. This is done by finding approximate fixpoint infinite matrix product states. However, there is no good reason why a single mps should suffice and indeed we find in practice that this can require a nontrivial unit cell in both dimensions.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In other words, the fixpoints can be well described by a set of matrix product states.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Such a set can be created by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2,2);\nMPSMultiline(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline is also used extensively in as of yet unreleased peps code.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can access properties by calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[row,collumn]\nstate.AC[row,collumn]\nstate.AR[row,collumn]\nstate.CR[row,collumn]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Behind the scenes, we have a type called Multiline, defined as:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"struct Multiline{T}\n    data::PeriodicArray{T,1}\nend","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline/MPOMultiline are then defined as ```julia const MPSMultiline = Multiline{<:InfiniteMPS} const MPOMultiline = Multiline{<:InfiniteMPO}","category":"page"},{"location":"man/intro/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"The following few sections should help you on your way to setting up and running simulations.","category":"page"},{"location":"man/intro/#TensorKit-1","page":"Basics","title":"TensorKit","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"MPSKit works on \"TensorMap\" objects defined in TensorKit.jl. These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Initializing a TensorMap can be done using","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(initializer,eltype,codomain,domain);\nTensorMap(inputdat,codomain,domain);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Similarly, the following creates a symmetric tensor","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,Rep[U₁](0=>1)*Rep[U₁](1//2=>3),Rep[U₁](1//2=>1,-1//2=>2))","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorKit defines a number of operations on TensorMap objects","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n\n3*a; # multiply by a scalar\n\na+a; #addition of tensormaps\n\na*a; #multiplication of tensormaps\n\na*adjoint(a); #taking the adjoint\n\ndot(a,a); #inner product\n\npermute(a,(1,2),()); # create a new tensormap ℂ^10 * (ℂ^10)' ← nothing\n\n...","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"for more complicated operations, we can use the same @tensor macro defined in TensorOperations.jl","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\nb = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n@tensor c[-1;-2]:=a[-1,1]*b[1,-2];","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"creates a new TensorMap c equal to a*b.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"For more information, check out the TensorKit documentation!","category":"page"},{"location":"man/intro/#Overview-1","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Within MPSKit we defined a set of states, a number of operators and some algorithms which combine the two in a nontrivial way.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As a simple example we can define a FiniteMPS","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"state = FiniteMPS(rand,ComplexF64,10,ℂ^2,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"A hamiltonian operator","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"opp = nonsym_ising_ham();","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"And use this to find the groundstate","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"(groundstate,_) = find_groundstate(state,opp,DMRG());","category":"page"},{"location":"man/intro/#Tips-and-tricks-1","page":"Basics","title":"Tips & tricks","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"There is an examples folder\nJulia inference is taxed a lot; the first time any function is run takes a really long time\nThere are predefined hamiltonians in MPSKitModels.jl","category":"page"},{"location":"tut/isingcft/#The-ising-cft-spectrum-1","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"In this tutorial we will try to plot the finite size cft spectrum for quantum ising, first with exact diagonalization and then going to larger system sizes using mps techniques. The required packages are","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"using MPSKit, MPSKitModels, TensorKit, Plots, KrylovKit\nusing LinearAlgebra:eigen,diagm,Hermitian;","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"The ising hamiltonian has already been implemented:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"nonsym_ising_ham();","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"MPSKit does not support periodic matrix product states, we only deal with the 'usual' open boundary mps's. However we can still impose periodic boundary conditions on the hamiltonian itself, and the mps will then restore translation invariance. To impose periodic boundary conditions you should call:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"circumference = 12;\nham = periodic_boundary_conditions(nonsym_ising_ham(),circumference);","category":"page"},{"location":"tut/isingcft/#exact-diagonalization-1","page":"The ising cft spectrum","title":"exact diagonalization","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"We implemented rudimentary support for exact diagonalization using a trick - by again representing it as a matrix product state but without truncating the bond dimension. The idea is illustrated below.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Optimizing the middle tensor is then equivalent to optimizing a state in the entire hilbert space.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"To call it in julia, do:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(energies,states) = exact_diagonalization(ham,num=18,alg=Lanczos(krylovdim=200));\nplot(real.(energies),seriestype=:scatter,legend=false,yaxis=\"energy\",xaxis=\"#eigenvalue\")","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Note the large krylov dimension - degenerate eigenvalues are notoriously difficult for iterative methods.","category":"page"},{"location":"tut/isingcft/#extracting-momentum-1","page":"The ising cft spectrum","title":"extracting momentum","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Given a state, we would like to assign a momentum label. A natural way to do this is by creating the translation operator, as an mpo:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"id = complex(isomorphism(ℂ^2,ℂ^2));\n@tensor O[-1 -2;-3 -4] := id[-1,-3]*id[-2,-4]\nmpo = InfiniteMPO(O);","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"We don't quite want an infinite mpo - which simply repeats this mpo ad infinitum, but would rather want to impose periodic boundary conditions to this mpo:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"mpo = periodic_boundary_conditions(mpo,circumference);","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"You can now simply calculate the momentum of the groundstate as:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"angle(dot(states[1],mpo*states[1]))","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"However, there is a subtlety because of the degenerate energy eigenvalues. The eigensolver will find an orthonormal basis within every energy subspace, so states within an energy subspace will not necessarily be momentum eigenstates. To assign a momentum label, we would have to diagonalize the translation operator.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"function fix_degeneracies(basis)\n    N = fill(0.0+0im,length(basis),length(basis));\n    T = fill(0.0+0im,length(basis),length(basis));\n    for i in 1:length(basis), j in 1:length(basis)\n        T[i,j] = dot(basis[i],mpo*basis[j]);\n        N[i,j] = dot(basis[i],basis[j]);\n    end\n\n\n    (vals,vecs) = eigen(Hermitian(N));\n    T = vecs'*T*vecs\n    T/=diagm(vals);\n\n    (vals,vecs) = eigen(T);\n    angle.(vals);\n\nend\n\nmomenta = Float64[];\n\n\nappend!(momenta,fix_degeneracies(states[1:1]));\nappend!(momenta,fix_degeneracies(states[2:2]));\nappend!(momenta,fix_degeneracies(states[3:3]));\nappend!(momenta,fix_degeneracies(states[4:5]));\nappend!(momenta,fix_degeneracies(states[6:9]));\nappend!(momenta,fix_degeneracies(states[10:11]));\nappend!(momenta,fix_degeneracies(states[12:12]));\nappend!(momenta,fix_degeneracies(states[13:16]));\nappend!(momenta,fix_degeneracies(states[17:18]));\n\nplot(momenta,real.(energies[1:18]),seriestype=:scatter,xaxis=\"momentum\",yaxis=\"energy\",legend=false)","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/isingcft/#finite-bond-dimension-1","page":"The ising cft spectrum","title":"finite bond dimension","text":"","category":"section"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Not much changes at finite bond dimension, except we can now reach higher system sizes.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"circumference = 20;\nham = periodic_boundary_conditions(nonsym_ising_ham(),circumference);\n\nstate = FiniteMPS(circumference,ℂ^2,ℂ^50 #=bond dimension=#);\n\n(gs,envs) = find_groundstate(state,ham,Dmrg());","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"Excitations on top of the groundstate can be found using the quasiparticle ansatz. This returns quasiparticle states, which you can just convert back to the usual finite mps's.","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(ens,qps) = excitations(ham,QuasiparticleAnsatz(),gs,envs,num=16);\nqpstates = map(qp->convert(FiniteMPS,qp),qps);","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"And we get the spectrum:","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"states = [gs;qpstates];\nenergies = map(x->sum(expectation_value(x,ham)),states);\n\nmpo = periodic_boundary_conditions(InfiniteMPO(O),circumference);\n\nmomenta = Float64[];\n\nappend!(momenta,fix_degeneracies(states[1:1]));\nappend!(momenta,fix_degeneracies(states[2:2]));\nappend!(momenta,fix_degeneracies(states[3:3]));\nappend!(momenta,fix_degeneracies(states[4:5]));\nappend!(momenta,fix_degeneracies(states[6:9]));\nappend!(momenta,fix_degeneracies(states[10:11]));\nappend!(momenta,fix_degeneracies(states[12:12]));\nappend!(momenta,fix_degeneracies(states[13:16]));\n\nplot(momenta,real.(energies[1:16]),seriestype=:scatter,xaxis=\"momentum\",yaxis=\"energy\",legend=false)","category":"page"},{"location":"tut/isingcft/#","page":"The ising cft spectrum","title":"The ising cft spectrum","text":"(Image: )","category":"page"},{"location":"tut/anyonic_statmech/#tut_hardhex-1","page":"The hard hexagon model","title":"The hard hexagon model","text":"","category":"section"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"Tensor networks are a natural way to do statistical mechanics on a lattice. As an example of this we will extract the central charge of the hard hexagon model. This model is known to have central charge 0.8, and has very peculiar non-local (anyonic) symmetries. Because TensorKit supports anyonic symmetries, so does MPSKit. To follow the tutorial you need the following packages.","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"using MPSKit,TensorKit,Polynomials","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"The hard hexagon mpo is given by","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"physical = Vect[FibonacciAnyon](:τ => 1);\nt = TensorMap(ones,ComplexF64,physical*physical,physical*physical);\nblocks(t)[FibonacciAnyon(:I)] *= 0;\n\nmpo = InfiniteMPO(t);","category":"page"},{"location":"tut/anyonic_statmech/#The-leading-boundary-1","page":"The hard hexagon model","title":"The leading boundary","text":"","category":"section"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"One way to do statmech in infinite systems with tensor networks is by approximating the dominant eigenvector of the transfer matrix by an mps. In MPSKit one should first define an initial guess for this eigenvector:","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"virtual = Vect[FibonacciAnyon](:τ => 5, :I => 5);\ninit = InfiniteMPS([physical],[virtual]);","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"and then pass it on to \"leading_boundary\":","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"(dominant,_) = leading_boundary(init,mpo,Vumps());","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"This dominant eigenvector contains a lot of hidden information, for example the following calculates the free energy:","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"expectation_value(dominant,mpo)","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"In this tutorial we will be focussing on the entanglement entropy and the correlation length:","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"S = entropy(dominant);\ncor_len = correlation_length(dominant);","category":"page"},{"location":"tut/anyonic_statmech/#The-scaling-hypothesis-1","page":"The hard hexagon model","title":"The scaling hypothesis","text":"","category":"section"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"The dominant eigenvector is of course only an approximation. The finite bond dimension enforces a finite correlation length, which effectively introduces a length scale in the system. This can be exploited to formulate a scaling hypothesis, which in turn allows you to extract the central charge!","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"First we need to know the entropy and correlation length at a bunch of different bond dimensions. Our approach will be to re-use the previous approximated dominant eigenvector, by simply expanding its bond dimension and re-running vumps.","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"entropies = [real(S[1])];\ncorlens = [cor_len];\nenvs = environments(dominant,mpo);\n\n#this will take a fairly long time\nfor Ds in 5:5:50\n    (dominant,envs) = changebonds(dominant,mpo,OptimalExpand(trscheme = truncdim(5)),envs);\n    (dominant,envs) = leading_boundary(dominant,mpo,Vumps(maxiter=200));\n    push!(entropies,real(entropy(dominant)[1]));\n    push!(corlens,correlation_length(dominant));\nend","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"According to the scaling hypothesis we should have S propto fracc6 log(corlen). Therefore we should find c using","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"f = fit(log.(corlens),6*entropies,1);\nf.coeffs[2]","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"Which indeed nicely agrees with the known result of 0.8.","category":"page"},{"location":"tut/anyonic_statmech/#","page":"The hard hexagon model","title":"The hard hexagon model","text":"(Image: )","category":"page"},{"location":"man/algorithms/#um_algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms/#minimizing-the-energy-1","page":"Algorithms","title":"minimizing the energy","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"There are a number of different possible energy-minimization algorithms, depending on the system size. Exclusive to finite systems are","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"- Dmrg\n\n- Dmrg2","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Exclusive to infinite systems are","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"- Idmrg\n\n- Idmrg2\n\n- Vumps","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"with a last algorithm - GradientGrassmann - implemented for both finite and infinite systems.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"MPSComoving, which is a finite patch of mutable tensors embedded in an infinite mps, is handled as a finite system where we only optimize over the match of mutable tensors.","category":"page"},{"location":"man/algorithms/#dmrg-1","page":"Algorithms","title":"dmrg","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate!(state,operator,Dmrg())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The dmrg algorithm sweeps through the system, optimizing every site. Because of its single-site behaviour, this will always keep the bond dimension fixed. If you do want to increase the bond dimension dynamically, then there are two options. Either you use the two-site variant of dmrg (Dmrg2()), or you make use of the finalize option. Finalize is a function that gets called at the end of every dmrg iteration. Within that function call one can modify the state.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"function my_finalize(iter,state,ham,envs)\n    println(\"Hello from iteration $iter\")\n    return state,envs;\nend\n\n(groundstate,environments,delta) = find_groundstate!(state,operator,Dmrg(finalize = my_finalize))","category":"page"},{"location":"man/algorithms/#dmrg2-1","page":"Algorithms","title":"dmrg2","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate!(state,operator,Dmrg2(trscheme=truncbelow(1e-7)));","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The twosite variant of dmrg, which optimizes blocks of two sites and then decomposes them into 2 mps tensors using the svd decomposition. By truncating the singular values up to a desired precision, one can dynamically grow and shrink the bond dimension as needed. However, this truncation in turn introduces an error. This is why a state converged with dmrg2 can often be slightly further converged by subsequently using dmrg.","category":"page"},{"location":"man/algorithms/#idmrg-1","page":"Algorithms","title":"idmrg","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,Idmrg1())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The dmrg algorithm for finite systems can be generalized to infinite mps. The idea is to start with a finite system and grow the system size, while we are sweeping through the system. This is again a single site algorithm, and therefore preserves the initial bond dimension.","category":"page"},{"location":"man/algorithms/#idmrg2-1","page":"Algorithms","title":"idmrg2","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2,ℂ^2],[ℂ^10,ℂ^10]);\noperator = repeat(nonsym_ising_ham(),2);\n(groundstate,environments,delta) = find_groundstate(state,operator,Idmrg2(trscheme=truncbelow(1e-5)))","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The generalization of dmrg2 to infinite systems has the same caveats as its finite counterpart. We also require a unitcell ≥ 2. As a rule of thumb, a truncation cutoff of 1e-5 is already really good.","category":"page"},{"location":"man/algorithms/#vumps-1","page":"Algorithms","title":"vumps","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Vumps is a dmrg inspired algorithm that can be used to find the groundstate of infinite matrix product states","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,Vumps())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"much like dmrg, it cannot modify the bond dimension, and this has to be done manually in the finalize function.","category":"page"},{"location":"man/algorithms/#gradient-descent-1","page":"Algorithms","title":"gradient descent","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Both finite and infinite matrix product states can be parametrized by a set of unitary matrices, and we can then perform gradient descent on this unitary manifold. Due to some technical reasons (gauge freedom), this manifold further restricts to a grassmann manifold.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,GradientGrassmann())","category":"page"},{"location":"man/algorithms/#time-evolution-1","page":"Algorithms","title":"time evolution","text":"","category":"section"},{"location":"man/algorithms/#Tdvp-1","page":"Algorithms","title":"Tdvp","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"There is an implementation of the one-site tdvp scheme for finite mps and infinite mps:","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"(newstate,environments) = timestep(state,operator,dt,Tdvp())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"and the two-site scheme for finite mps (Tdvp2()). Similarly to dmrg, the one site scheme will preserve the bond dimension, and expansion has to be done manually.","category":"page"},{"location":"man/algorithms/#Time-evolution-mpo-1","page":"Algorithms","title":"Time evolution mpo","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"We have rudimentary support for turning an mpo hamiltonian into a time evolution mpo.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"make_time_mpo(ham,dt,alg::WI)\nmake_time_mpo(ham,dt,alg::WII)","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"two algorithms are available, corresponding to different orders of precision. It is possible to then multiply a state by this mpo, or to approximate (mpo,state) by a new state","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\nmpo = make_time_mpo(operator,0.1,WII());\napproximate(state,(state,mpo),Vumps())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"This feature is at the moment not very well supported.","category":"page"},{"location":"man/algorithms/#excitations-1","page":"Algorithms","title":"excitations","text":"","category":"section"},{"location":"man/algorithms/#Quasiparticle-ansatz-1","page":"Algorithms","title":"Quasiparticle ansatz","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"We export code that implements the quasiparticle excitation ansatz for finite and infinite systems. For example, the following calculates the haldane gap for spin-1 heisenberg.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_xxz_ham()\nts = InfiniteMPS([ℂ^3],[ℂ^48]);\n(ts,envs,_) = find_groundstate(ts,th,Vumps(maxiter=400,verbose=false));\n(energies,Bs) = excitations(th,QuasiparticleAnsatz(),Float64(pi),ts,envs);\n@test energies[1] ≈ 0.41047925 atol=1e-4","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For infinite systems you have to specify the momentum of your particle. In contrast, momentum is not a well defined quantum number and you therefore do not have to specify it when finding excitations on top of a finite mps.","category":"page"},{"location":"man/algorithms/#Finite-excitations-1","page":"Algorithms","title":"Finite excitations","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For finite systems we can also do something else - find the groundstate of the hamiltonian + weight sum_i  psi_i   psi_i. This is also supported by calling","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_ham()\nts = FiniteMPS(10,ℂ^2,ℂ^12);\n(ts,envs,_) = find_groundstate(ts,th,Dmrg(verbose=false));\n(energies,Bs) = excitations(th,FiniteExcited(),ts,envs);","category":"page"},{"location":"man/algorithms/#changebonds-1","page":"Algorithms","title":"changebonds","text":"","category":"section"},{"location":"man/algorithms/#optimal-expand-1","page":"Algorithms","title":"optimal expand","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"One possible way to expand the bond dimension is described in the original vumps paper. The idea is to look at the 2site derivative and add the most important blocks orthogonal to the current mps. From the point of view of a local 2site update, this procedure is 'optimal'.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The state will remain physically unchanged, but a one-site scheme will now be able to push the optimization further.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_ham()\nts = FiniteMPS(10,ℂ^2,ℂ^12);\nchangebonds(ts,OptimalExpand(trscheme = truncdim(1))) # expand the bond dimension by 1","category":"page"},{"location":"man/algorithms/#random-expand-1","page":"Algorithms","title":"random expand","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"This algorithm is almost identical to optimal expand, except we don't try to do anything 'clever'. The unitary blocks that get added are chosen at random.","category":"page"},{"location":"man/algorithms/#svd-cut-1","page":"Algorithms","title":"svd cut","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"It is possible to truncate a state using the svd decomposition, this is implemented in svdcut.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_ham()\nts = FiniteMPS(10,ℂ^2,ℂ^12);\nchangebonds(ts,SvdCut(trscheme = truncdim(10))) # truncate the state to one with bond dimension 10","category":"page"},{"location":"man/algorithms/#vumps-svd-cut-1","page":"Algorithms","title":"vumps svd cut","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"A particularly simple scheme useful when doing vumps is to do a 2site update, and then truncating this back down. It changes the state itself, so cannot be used to do time evolution, but that is no problem for energy minimization.","category":"page"},{"location":"man/algorithms/#leading-boundary-1","page":"Algorithms","title":"leading boundary","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"For statmech partition functions we want to find the approximate leading boundary mps.  Again this can be done with vumps:","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"th = nonsym_ising_mpo()\nts = InfiniteMPS([ℂ^2],[ℂ^20]);\n(ts,envs,_) = leading_boundary(ts,th,Vumps(maxiter=400,verbose=false));","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"if the mpo satisfies certain properties (positive and hermitian), it may also be possible to use GradientGrassmann.","category":"page"},{"location":"man/algorithms/#approximate-1","page":"Algorithms","title":"approximate","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Sometimes we want to approximate the product of an mpo and a state by another state (for example during time evolution). The call signature is","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"    approximate(initial_guess,(state,mpo),alg)","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"for finite systems alg can be Dmrg,Dmrg2 while for infinite systems we have Idmrg1,Idmrg2 and vumps. It's important to mention that the actual implementation differs a bit from the usual  Dmrg,Dmrg2,... for energy minimization but is rather inspired by it. For example, calling approximate with Vumps actually uses an algorithm that has been described as vomps.","category":"page"},{"location":"man/algorithms/#varia-1","page":"Algorithms","title":"varia","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"What follows is a medley of lesser known (or used) algorithms and don't entirely fit under one of the above categories.","category":"page"},{"location":"man/algorithms/#dynamicaldmrg-1","page":"Algorithms","title":"dynamicaldmrg","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Dynamical dmrg has been described in other papers and is a way to find the propagator. The basic idea is that to calculate G(z) =  V  (H-z)^-1  V  , one can variationally find (H-z) W  =  V  and then the propagator simply equals G(z) =  V  W .","category":"page"},{"location":"man/algorithms/#fidelity-susceptibility-1","page":"Algorithms","title":"fidelity susceptibility","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"The fidelity susceptibility measures how much the groundstate changes when tuning a parameter in your hamiltonian. Divergences occur at phase transitions, making it a valuable measure when no order parameter is known.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"fidelity_susceptibility(groundstate,H_0,perturbing_Hams::AbstractVector)","category":"page"},{"location":"man/algorithms/#periodic-boundary-conditions-1","page":"Algorithms","title":"periodic boundary conditions","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"You can impose periodic boundary conditions on the hamiltonian itself, while still using a normal OBC finite matrix product states. This is straightforward to implement but competitive with more advanced PBC mps algorithms.","category":"page"},{"location":"man/algorithms/#exact-diagonalization-1","page":"Algorithms","title":"exact diagonalization","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"As a side effect, our code support exact diagonalization. The idea is to construct a finite matrix product state with maximal bond dimension, and then optimize the middle site. Because we never truncated the bond dimension, this single site effectively parametrizes the entire hilbert space.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"exact_diagonalization(periodic_boundary_conditions(su2_xxx_ham(spin=1),10),which=:SR) # find the groundstate on 10 sites","category":"page"},{"location":"tut/xxz_groundstate/#Analyzing-the-xxz-model-1","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"In this file we will give step by step instructions on how to analyze the spin 1/2 xxz model. The necessary packages to follow this tutorial are :","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"using MPSKit, MPSKitModels, TensorKit, Plots","category":"page"},{"location":"tut/xxz_groundstate/#Failure-1","page":"Analyzing the xxz model","title":"Failure","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"First we should define the hamiltonian we want to work with. The following code does so in the mpo representation of the hamiltonian.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\nham_data = fill(zero(id),1,5,5);\nham_data[1,1,1] = id; ham_data[1,end,end] = id;\nham_data[1,1,2] = sx; ham_data[1,2,end] = sx;\nham_data[1,1,3] = sy; ham_data[1,3,end] = sy;\nham_data[1,1,4] = sz; ham_data[1,4,end] = sz;\nham = MPOHamiltonian(ham_data);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We then need an intial state, which we shall later optimize. In this example we work directly in the thermodynamic limit.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"random_data = TensorMap(rand,ComplexF64,ℂ^20*ℂ^2,ℂ^20);\nstate = InfiniteMPS([random_data]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"The groundstate can then be found by calling find_groundstate.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Vumps());","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"As you can see, vumps strugles to converge. On it's own, that is already quite curious. Maybe we can do better using another algorithm, such as gradient descent.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,GradientGrassmann(maxiter=20));","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Convergence is quite slow and even fails after sufficiently many iterations. To understand why, we can look at the transfer matrix spectrum.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"    transferplot(groundstate,groundstate)","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(Image: )","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We can clearly see multiple eigenvalues close to the unit circle. Our state is close to being non-injective, and represents the sum of multiple injective states. This is numerically very problematic, but also indicates that we used an incorrect ansatz to approximate the groundstate. We should retry with a larger unit cell.","category":"page"},{"location":"tut/xxz_groundstate/#Success-1","page":"Analyzing the xxz model","title":"Success","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Let's initialize a different initial state, this time with a 2-site unit cell:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"A = TensorMap(rand,ComplexF64,ℂ^20*ℂ^2,ℂ^20);\nB = TensorMap(rand,ComplexF64,ℂ^20*ℂ^2,ℂ^20);\nstate = InfiniteMPS([A,B]);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"In MPSKit, we require that the periodicity of the hamiltonian equals that of the state it is applied to. This is not a big obstacle, you can simply repeat the original hamiltonian:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"ham = repeat(ham,2);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Running vumps","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Vumps(maxiter=100,tol_galerkin=1e-12));","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"we get convergence, but it takes an enormous amount of iterations. The reason behind this becomes more obvious at higher bond dimensions","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Idmrg2(trscheme=truncdim(100),maxiter=100,tol_galerkin=1e-12));\n\nentanglementplot(groundstate)","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(Image: )","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"We see that some eigenvalues clearly belong to a group, and are almost degenerate. This implies 2 things:     - there is superfluous information, if those eigenvalues are the same anyway     - poor convergence if we cut off within such a subspace","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"It are precisely those problems that we can solve by using symmetries.","category":"page"},{"location":"tut/xxz_groundstate/#Symmetries-1","page":"Analyzing the xxz model","title":"Symmetries","text":"","category":"section"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"The xxz hamiltonian is su(2) symmetric and we can exploit this to greatly speed up the simulation.","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"It is cumbersome to construct symmetric hamiltonians, but luckily su(2) symmetric xxz is already implemented:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"ham = repeat(su2_xxx_ham(spin=1//2),2);","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Our initial state should also be su(2) symmetric. It now becomes apparent why we have to use a 2 site periodic state. The physical space carries a half-integer charge and the first tensor maps the first virtual space ⊗ the physical space to the second virtual space. Half integer virtual charges will therefore map only to integer charges, and vice versa. The staggering happens on the virtual level!","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"An alternative constructor for the initial state is","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"D1 = Rep[SU₂](1//2 => 10,3//2=>5,5//2=>2);\nD2 = Rep[SU₂](0=>15,1=>10,2=>5);\nstate = InfiniteMPS([Rep[SU₂](1//2 => 1),Rep[SU₂](1//2 => 1)],[D1,D2])","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Even though the bond dimension is higher then in the non symmetric example:","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"@assert dim(D1) == 52;\n@assert dim(D2) == 70;","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"Vumps converges much much faster","category":"page"},{"location":"tut/xxz_groundstate/#","page":"Analyzing the xxz model","title":"Analyzing the xxz model","text":"(groundstate,cache,delta) = find_groundstate(state,ham,Vumps(maxiter=400,tol_galerkin=1e-12));","category":"page"},{"location":"man/operators/#um_operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/#MPOHamiltonian-1","page":"Operators","title":"MPOHamiltonian","text":"","category":"section"},{"location":"man/operators/#usage-1","page":"Operators","title":"usage","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"We represent all quantum hamiltonians in their mpo form. As an example, the following bit of code constructs the ising hamiltonian.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\ndata = Array{Any,3}(missing,1,3,3);\ndata[1,1,1] = id;\ndata[1,1,2] = -sz;\ndata[1,2,3] = sz;\ndata[1,1,3] = 3*sx;\nham = MPOHamiltonian(data);","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"When we work with symmetries, it is often not possible to represent the entire hamiltonian as a sum of a product of one-body operators. In xxz for examples, only the sum (sx sx + sy sy + sz sz) is su(2) symmetric, but individually none of the terms are. It is for this reason that we use 4 leg mpo tensors in this hamiltonian object. The following bit of code","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"ham[1,1,1]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Will print out a tensormap mapping (virtual space x physical space) to (physical space x virtual space). The conversion to mpo tensors was done automagically behind the scenes!","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"MPOHamiltonian are always assumed to be periodic in the first index (position). In this way, we can both represent periodic infinite hamiltonians and place dependent finite hamiltonians.","category":"page"},{"location":"man/operators/#implementation-details-1","page":"Operators","title":"implementation details","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"The mpohamiltonian has 3 fields:","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Os::PeriodicArray{Union{E,T},3}\ndomspaces::PeriodicArray{S,2}\npspaces::PeriodicArray{S,1}\n\nWhere T<:MPOTensor, E<:Number","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"When indexing the hamiltonian at index [i,j,k], the code looks up the corresponding field in Os[i,j,k]. Either that element is a tensormap, in which case it gets returned. If it equals zero(E), then we return a tensormap","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"domspaces[i,j]*pspaces[i] ← pspaces[i]*domspaces[i+1,k]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"wither norm zero. If the element is a nonzero number, then implicitly we have the identity operator there (multiplied by that element). Of course in that case,","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"domspaces[i,j] == domspaces[i+1,k]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Otherwise the identity operator can't be uniquely defined.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"The overarching idea is that the user never has to worry about these inner fields, and can act as if the mpohamiltonian is a 3 dimensional array of tensormaps, while we optimize behind the scenes for the special cases where the operator is zero or the identity.","category":"page"},{"location":"man/operators/#InfiniteMPO-1","page":"Operators","title":"InfiniteMPO","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"This operator is used for statistical physics problems. It is simply a periodic array of mpo tensors.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Can be created using","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"InfiniteMPO(t::AbstractArray{T,1}) where T<:MPOTensor","category":"page"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#User-manual-1","page":"Home","title":"User manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\",\"man/conventions.md\",\"man/states.md\",\"man/operators.md\",\"man/algorithms.md\"]\nDepth = 2","category":"page"},{"location":"#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"tut/anyonic_statmech.md\",\"tut/isingcft.md\",\"tut/xxz_groundstate.md\",\"tut/timeev.md\",\"tut/haldane.md\"]\nDepth = 1","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/lib.md\"]\nDepth = 1","category":"page"}]
}
