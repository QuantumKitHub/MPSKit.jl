<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MPSKit.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MPSKit.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Key-Features"><span>Key Features</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/intro/">Prerequisites</a></li><li><a class="tocitem" href="man/states/">States</a></li><li><a class="tocitem" href="man/operators/">Operators</a></li><li><a class="tocitem" href="man/algorithms/">Algorithms</a></li><li><a class="tocitem" href="man/environments/">Environments</a></li><li><a class="tocitem" href="man/parallelism/">Parallelism in julia</a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li><li><a class="tocitem" href="lib/lib/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maartenvd/MPSKit.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MPSKit.jl"><a class="docs-heading-anchor" href="#MPSKit.jl">MPSKit.jl</a><a id="MPSKit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MPSKit.jl" title="Permalink"></a></h1><p><strong>Efficient and versatile tools for working with matrix product states</strong></p><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="man/intro/#Prerequisites">Prerequisites</a></li><li><a href="man/states/#um_states">States</a></li><li><a href="man/operators/#um_operators">Operators</a></li><li><a href="man/algorithms/#um_algorithms">Algorithms</a></li><li><a href="man/parallelism/#Parallelism-in-julia">Parallelism in julia</a></li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>MPSKit.jl is a part of the general registry, and can be installed via the package manager as:</p><pre><code class="nohighlight hljs">pkg&gt; add MPSKit</code></pre><h2 id="Key-Features"><a class="docs-heading-anchor" href="#Key-Features">Key Features</a><a id="Key-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Features" title="Permalink"></a></h2><ul><li>Construction and manipulation of Matrix Product States (MPS)</li><li>Calculation of observables and expectation values</li><li>Various optimization methods for obtaining MPS fixed points</li><li>Support for both finite and infinite MPS</li><li>Support for wide variety of symmetries, including Abelian, non-Abelian, fermionic and anyonic symmetries</li></ul><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>To get started with MPSKit, we recommend also including <a href="https://github.com/Jutho/TensorKit.jl">TensorKit.jl</a> and <a href="https://github.com/maartenvd/MPSKitModels.jl">MPSKitModels.jl</a>. The former defines the tensor backend which is used throughout MPSKit, while the latter includes some common operators and models.</p><pre><code class="language-julia hljs">using TensorOperations
using TensorKit
using MPSKit
using MPSKitModels
using LinearAlgebra: norm</code></pre><h3 id="Finite-Matrix-Product-States"><a class="docs-heading-anchor" href="#Finite-Matrix-Product-States">Finite Matrix Product States</a><a id="Finite-Matrix-Product-States-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Matrix-Product-States" title="Permalink"></a></h3><p>Finite MPS are characterised by a set of tensors, one for each site, which each have 3 legs. They can be constructed by specifying the virtual spaces and the physical spaces, i.e. the dimensions of each of the legs. These are then contracted to form the MPS. In MPSKit, they are represented by <code>FiniteMPS</code>, which can be constructed either by passing in the tensors directly, or by specifying the dimensions of the legs.</p><pre><code class="language-julia hljs">d = 2 # physical dimension
D = 5 # virtual dimension
L = 10 # number of sites

mps = FiniteMPS(L, ComplexSpace(d), ComplexSpace(D)) # random MPS with maximal bond dimension D</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-site FiniteMPS:
┌ CL[11]: TensorMap(ProductSpace(ℂ^1) ← ProductSpace(ℂ^1))
├── AL[10]: TensorMap((ℂ^2 ⊗ ℂ^2) ← ProductSpace(ℂ^1))
├── AL[9]: TensorMap((ℂ^4 ⊗ ℂ^2) ← ProductSpace(ℂ^2))
├── AL[8]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^4))
├── AL[7]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AL[6]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AL[5]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AL[4]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AL[3]: TensorMap((ℂ^4 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AL[2]: TensorMap((ℂ^2 ⊗ ℂ^2) ← ProductSpace(ℂ^4))
└── AL[1]: TensorMap((ℂ^1 ⊗ ℂ^2) ← ProductSpace(ℂ^2))
</code></pre><p>The <code>FiniteMPS</code> object then handles the gauging of the MPS, which is necessary for many of the algorithms. This is done automatically when needed, and the user can access the gauged tensors by getting and setting the <code>AL</code>, <code>AR</code>, <code>CR</code>/<code>CL</code> and <code>AC</code> fields, which each represent a vector of these tensors.</p><pre><code class="language-julia hljs">al = mps.AL[3] # left gauged tensor of the third site
@tensor E[a; b] := al[c, d, b] * conj(al[c, d, a])
@show isapprox(E, id(left_virtualspace(mps, 3)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">ar = mps.AR[3] # right gauged tensor of the third site
@tensor E[a; b] := ar[a, d, c] * conj(ar[b, d, c])
@show isapprox(E, id(right_virtualspace(mps, 2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>As the mps will be kept in a gauged form, updating a tensor will also update the gauged tensors. For example, we can set the tensor of the third site to the identity, and the gauged tensors will be updated accordingly.</p><pre><code class="language-julia hljs">mps.CR[3] = id(domain(mps.CR[3]))
println(mps)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌── AR[10]: TensorMap((ℂ^2 ⊗ ℂ^2) ← ProductSpace(ℂ^1))
├── AR[9]: TensorMap((ℂ^4 ⊗ ℂ^2) ← ProductSpace(ℂ^2))
├── AR[8]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^4))
├── AR[7]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AR[6]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AR[5]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AR[4]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
│ CL[4]: TensorMap(ProductSpace(ℂ^5) ← ProductSpace(ℂ^5))
├── AL[3]: TensorMap((ℂ^4 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
├── AL[2]: TensorMap((ℂ^2 ⊗ ℂ^2) ← ProductSpace(ℂ^4))
└── AL[1]: TensorMap((ℂ^1 ⊗ ℂ^2) ← ProductSpace(ℂ^2))</code></pre><p>These objects can then be used to compute observables and expectation values. For example, the expectation value of the identity operator at the third site, which is equal to the norm of the MPS, can be computed as:</p><pre><code class="language-julia hljs">N1 = LinearAlgebra.norm(mps)
N2 = expectation_value(mps, id(physicalspace(mps, 3)), 3)
println(&quot;‖mps‖ = $N1&quot;)
println(&quot;&lt;mps|𝕀₃|mps&gt; = $N2&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">‖mps‖ = 2.236067977499789
&lt;mps|𝕀₃|mps&gt; = 5.0 - 6.711439842957172e-18im</code></pre><p>Finally, the MPS can be optimized in order to determine groundstates of given Hamiltonians. Using the pre-defined models in <code>MPSKitModels</code>, we can construct the groundstate for the transverse field Ising model:</p><pre><code class="language-julia hljs">H = transverse_field_ising(; J=1.0, g=0.5)
find_groundstate!(mps, H, DMRG(; maxiter=10))
E0 = expectation_value(mps, H)
println(&quot;&lt;mps|H|mps&gt; = $(sum(real(E0)) / length(mps))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Iteraton 0 error 0.06616405019394016
[ Info: Iteraton 1 error 0.0037896067179077017
[ Info: Iteraton 2 error 5.202637920525381e-5
[ Info: Iteraton 3 error 2.221176345537133e-5
[ Info: Iteraton 4 error 9.60588960093582e-6
[ Info: Iteraton 5 error 4.200620523917149e-6
[ Info: Iteraton 6 error 2.157842944596171e-6
[ Info: Iteraton 7 error 1.143819532580261e-6
[ Info: Iteraton 8 error 6.071540948042546e-7
[ Info: Iteraton 9 error 3.224749661972834e-7
&lt;mps|H|mps&gt; = -0.9765503487689496</code></pre><h3 id="Infinite-Matrix-Product-States"><a class="docs-heading-anchor" href="#Infinite-Matrix-Product-States">Infinite Matrix Product States</a><a id="Infinite-Matrix-Product-States-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Matrix-Product-States" title="Permalink"></a></h3><p>Similarly, an infinite MPS can be constructed by specifying the tensors for the unit cell, characterised by the spaces (dimensions) thereof.</p><pre><code class="language-julia hljs">d = 2 # physical dimension
D = 5 # virtual dimension
mps = InfiniteMPS(d, D) # random MPS</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">single site InfiniteMPS:
│   ⋮
│ CR[1]: TensorMap(ProductSpace(ℂ^5) ← ProductSpace(ℂ^5))
├── AL[1]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
│   ⋮
</code></pre><p>The <code>InfiniteMPS</code> object then handles the gauging of the MPS, which is necessary for many of the algorithms. This is done automatically upon creation of the object, and the user can access the gauged tensors by getting and setting the <code>AL</code>, <code>AR</code>, <code>CR</code>/<code>CL</code> and <code>AC</code> fields, which each represent a (periodic) vector of these tensors.</p><pre><code class="language-julia hljs">al = mps.AL[1] # left gauged tensor of the third site
@tensor E[a; b] := al[c, d, b] * conj(al[c, d, a])
@show isapprox(E, id(left_virtualspace(mps, 1)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">ar = mps.AR[1] # right gauged tensor of the third site
@tensor E[a; b] := ar[a, d, c] * conj(ar[b, d, c])
@show isapprox(E, id(right_virtualspace(mps, 2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>As regauging the MPS is not possible without recomputing all the tensors, setting a single tensor is not supported. Instead, the user should construct a new mps object with the desired tensor, which will then be gauged upon construction.</p><pre><code class="language-julia hljs">als = 3 .* mps.AL
mps = InfiniteMPS(als)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">single site InfiniteMPS:
│   ⋮
│ CR[1]: TensorMap(ProductSpace(ℂ^5) ← ProductSpace(ℂ^5))
├── AL[1]: TensorMap((ℂ^5 ⊗ ℂ^2) ← ProductSpace(ℂ^5))
│   ⋮
</code></pre><p>These objects can then be used to compute observables and expectation values. For example, the norm of the MPS, which is equal to the expectation value of the identity operator can be computed by:</p><pre><code class="language-julia hljs">N1 = norm(mps)
N2 = expectation_value(mps, id(physicalspace(mps, 1)), 1)
println(&quot;‖mps‖ = $N1&quot;)
println(&quot;&lt;mps|𝕀₁|mps&gt; = $N2&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">‖mps‖ = 1.0
&lt;mps|𝕀₁|mps&gt; = 1.0 - 3.1554477847506763e-19im</code></pre><div class="admonition is-info"><header class="admonition-header">Normalization of infinite MPS</header><div class="admonition-body"><p>Because infinite MPS cannot sensibly be normalized to anything but <span>$1$</span>, the <code>norm</code> of an infinite MPS is always set to be <span>$1$</span> at construction. If this were not the case, any observable computed from the MPS would either blow up to infinity or vanish to zero.</p></div></div><p>Finally, the MPS can be optimized in order to determine groundstates of given Hamiltonians. Using the pre-defined models in <code>MPSKitModels</code>, we can construct the groundstate for the transverse field Ising model:</p><pre><code class="language-julia hljs">H = transverse_field_ising(; J=1.0, g=0.5)
mps, = find_groundstate(mps, H, VUMPS(; maxiter=10))
E0 = expectation_value(mps, H)
println(&quot;&lt;mps|H|mps&gt; = $(sum(real(E0)) / length(mps))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: vumps @iteration 1 galerkin = 0.03731843523828751
[ Info: vumps @iteration 2 galerkin = 0.0003422459678145641
[ Info: vumps @iteration 3 galerkin = 8.309750435076909e-7
[ Info: vumps @iteration 4 galerkin = 1.7321049881325525e-8
[ Info: vumps @iteration 5 galerkin = 1.4308991001254934e-9
[ Info: vumps @iteration 6 galerkin = 1.505966059333823e-10
[ Info: vumps @iteration 7 galerkin = 1.617562257044797e-11
[ Info: vumps @iteration 8 galerkin = 1.7395246565193932e-12
[ Info: vumps @iteration 9 galerkin = 1.8870849099980735e-13
&lt;mps|H|mps&gt; = -1.0635444099732512</code></pre><h3 id="Additional-Resources"><a class="docs-heading-anchor" href="#Additional-Resources">Additional Resources</a><a id="Additional-Resources-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Resources" title="Permalink"></a></h3><p>For more detailed information on the functionality and capabilities of MPSKit, refer to the Manual section, or have a look at the <a href="examples/#Examples">Examples</a> page.</p><p>Keep in mind that the documentation is still a work in progress, and that some features may not be fully documented yet. If you encounter any issues or have questions, please check the library&#39;s <a href="https://github.com/maartenvd/MPSKit.jl/issues">issue tracker</a> on the GitHub repository and open a new issue.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/intro/">Prerequisites »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 14 August 2023 09:41">Monday 14 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
