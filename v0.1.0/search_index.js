var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library-documentation-1","page":"Library documentation","title":"Library documentation","text":"","category":"section"},{"location":"lib/lib/#lib_states-1","page":"Library documentation","title":"States","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"FiniteMPS\nInfiniteMPS\nMPSComoving\nMPSMultiline","category":"page"},{"location":"lib/lib/#MPSKit.FiniteMPS","page":"Library documentation","title":"MPSKit.FiniteMPS","text":"mutable struct FiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor} <: AbstractMPS\n\nRepresents a finite matrix product state\n\nWhen queried for AL/AR/AC/CL it will check if it is missing.     If not, return     If it is, calculate it, store it and return\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.InfiniteMPS","page":"Library documentation","title":"MPSKit.InfiniteMPS","text":"struct InfiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor}\n\nRepresents an infinite matrix product state The state is stored in the centergauge where     state.AL[i]state.CR[i] = state.AC[i] = state.CR[i-1]state.AR[i]\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSComoving","page":"Library documentation","title":"MPSKit.MPSComoving","text":"MPSComoving(leftstate,window,rightstate)\n\nmuteable window of tensors on top of an infinite chain\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSMultiline","page":"Library documentation","title":"MPSKit.MPSMultiline","text":"2d extension of InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Operators-1","page":"Library documentation","title":"Operators","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPOHamiltonian\nComAct\nPeriodicMPO","category":"page"},{"location":"lib/lib/#MPSKit.MPOHamiltonian","page":"Library documentation","title":"MPSKit.MPOHamiltonian","text":"MPOHamiltonian\n\nrepresents a general periodic quantum hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.ComAct","page":"Library documentation","title":"MPSKit.ComAct","text":"ComAct(ham1,ham2)\n\nActs on an mpo with mpo hamiltonian 'ham1' from below + 'ham2' from above.\nCan therefore represent the (anti) commutator.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PeriodicMPO","page":"Library documentation","title":"MPSKit.PeriodicMPO","text":"Represents a periodic (in 2 directions) statmech mpo\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Environments-1","page":"Library documentation","title":"Environments","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPSKit.AbstractInfEnv\nMPSKit.PerMPOInfEnv\nMPSKit.MPOHamInfEnv\nMPSKit.FinEnv\nMPSKit.SimpleEnv\nMPSKit.OvlEnv","category":"page"},{"location":"lib/lib/#MPSKit.AbstractInfEnv","page":"Library documentation","title":"MPSKit.AbstractInfEnv","text":"Abstract environment for an infinite state\ndistinct from finite, because we have to recalculate everything when the state changes\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PerMPOInfEnv","page":"Library documentation","title":"MPSKit.PerMPOInfEnv","text":"This object manages the periodic mpo environments for an MPSMultiline\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPOHamInfEnv","page":"Library documentation","title":"MPSKit.MPOHamInfEnv","text":"This object manages the hamiltonian environments for an InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.FinEnv","page":"Library documentation","title":"MPSKit.FinEnv","text":"FinEnv keeps track of the environments for FiniteMPS / MPSComoving\nIt automatically checks if the queried environment is still correctly cached and if not - recalculates\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SimpleEnv","page":"Library documentation","title":"MPSKit.SimpleEnv","text":"SimpleEnv does nothing fancy to ensure the correctness of the environments it returns.\nSupports setleftenv! and setrightenv!\nOnly used internally (in idmrg); no public constructor is provided\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Generic-actions-1","page":"Library documentation","title":"Generic actions","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"c_prime\nac_prime\nac2_prime\nexpectation_value","category":"page"},{"location":"lib/lib/#MPSKit.c_prime","page":"Library documentation","title":"MPSKit.c_prime","text":"Zero-site derivative (the C matrix to the right of pos)\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac_prime","page":"Library documentation","title":"MPSKit.ac_prime","text":"One-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac2_prime","page":"Library documentation","title":"MPSKit.ac2_prime","text":"Two-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.expectation_value","page":"Library documentation","title":"MPSKit.expectation_value","text":"calculates the expectation value for the given operator/hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#Algorithms-1","page":"Library documentation","title":"Algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"find_groundstate\ntimestep\nleading_boundary\ndynamicaldmrg\nquasiparticle_excitation\nchangebonds","category":"page"},{"location":"lib/lib/#MPSKit.find_groundstate","page":"Library documentation","title":"MPSKit.find_groundstate","text":"find_groundstate(state,ham,alg,pars=params(state,ham))\n\nfind the groundstate for ham using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.timestep","page":"Library documentation","title":"MPSKit.timestep","text":"function timestep(psi, operator, dt, alg,pars = params(psi,operator))\n\ntime evolves psi by timestep dt using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.leading_boundary","page":"Library documentation","title":"MPSKit.leading_boundary","text":"leading_boundary(state,opp,alg,pars=params(state,ham))\n\napproximate the leading eigenvector for opp\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.dynamicaldmrg","page":"Library documentation","title":"MPSKit.dynamicaldmrg","text":"https://arxiv.org/pdf/cond-mat/0203500.pdf\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.quasiparticle_excitation","page":"Library documentation","title":"MPSKit.quasiparticle_excitation","text":"quasiparticle_excitation calculates the energy of the first excited state at momentum 'moment'\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#lib_gs_alg-1","page":"Library documentation","title":"Groundstate algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Vumps\nIdmrg1\nDmrg\nDmrg2\nGradientGrassmann","category":"page"},{"location":"lib/lib/#MPSKit.Vumps","page":"Library documentation","title":"MPSKit.Vumps","text":"see https://arxiv.org/abs/1701.07035\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Idmrg1","page":"Library documentation","title":"MPSKit.Idmrg1","text":"onesite infinite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg","page":"Library documentation","title":"MPSKit.Dmrg","text":"onesite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg2","page":"Library documentation","title":"MPSKit.Dmrg2","text":"twosite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.GradientGrassmann","page":"Library documentation","title":"MPSKit.GradientGrassmann","text":"GradientGrassmann is an optimisation methdod that keeps the MPS in left-canonical form, and treats the tensors as points on Grassmann manifolds. It then applies one of the standard gradient optimisation methods, e.g. conjugate gradient, to the MPS, making use of the Riemannian manifold structure. A preconditioner is used, so that effectively the metric used on the manifold is that given by the Hilbert space inner product.\n\nThe arguments to the constructor are method = OptimKit.ConjugateGradient     The gradient optimisation method to be used. Should either be an instance or a subtype     of OptimKit.OptimizationAlgorithm. If it's an instance, this method is simply used     to do the optimisation. If it's a subtype, then an instance is constructed as     method(; maxiter=maxiter, verbosity=verbosity, gradtol=tol)\n\nfinalize! = OptimKit._finalize!     A function that gets called once each iteration. See OptimKit for details.\n\ntol = Defaults.tol maxiter = Defaults.maxiter verbosity = 2     Arguments passed to the method constructor. If method is an instance of     OptimKit.OptimizationAlgorithm, these argument are ignored.\n\nIn other words, by default conjugate gradient is used. One can easily set tol, maxiter and verbosity for it, or switch to LBFGS or gradient descent by setting method. If more control is wanted over things like specifics of the linesearch, CG flavor or the m parameter of LBFGS, then the user should create the OptimKit.OptimizationAlgorithm instance manually and pass it as method.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_time_alg-1","page":"Library documentation","title":"Time evolution algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Tdvp\nTdvp2","category":"page"},{"location":"lib/lib/#MPSKit.Tdvp","page":"Library documentation","title":"MPSKit.Tdvp","text":"onesite tdvp\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Tdvp2","page":"Library documentation","title":"MPSKit.Tdvp2","text":"twosite tdvp (works for finite mps's)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_bound_alg-1","page":"Library documentation","title":"Leading boundary algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"Vumps\nPowerMethod","category":"page"},{"location":"lib/lib/#MPSKit.PowerMethod","page":"Library documentation","title":"MPSKit.PowerMethod","text":"PowerMethod way of finding the leading boundary mps\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#lib_bc_alg-1","page":"Library documentation","title":"Bond change algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"OptimalExpand\nVumpsSvdCut\nSvdCut","category":"page"},{"location":"lib/lib/#MPSKit.OptimalExpand","page":"Library documentation","title":"MPSKit.OptimalExpand","text":"expands the given mps using the algorithm given in the vumps paper\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.VumpsSvdCut","page":"Library documentation","title":"MPSKit.VumpsSvdCut","text":"use an idmrg2 step to truncate/expand the bond dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SvdCut","page":"Library documentation","title":"MPSKit.SvdCut","text":"Truncate a given state using svd\n\n\n\n\n\n","category":"type"},{"location":"man/states/#um_states-1","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/#FiniteMPS-1","page":"States","title":"FiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A FiniteMPS can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^1),10);\nFiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Or alternatively by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"len = 10;\nmax_bond_dimension = ℂ^10;\nphysical_space = ℂ^2;\nFiniteMPS(rand,ComplexF64,len,physical_space,max_bond_dimension);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can take dot products, renormalize!, expectation values,....","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In our algorithms we typically make use of the fields .AC/.AR/.AL. Calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AC[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"gauges the state such that every tensor left of 3 is a left unitary matrix and to the right we have right unitary matrices. As a result you should have","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Note that every tensor should be a map from the virtual space to the virtual space ⊗ physical space. In other words, we need the input tensormaps to be of the type AbstractTensorMap{S,N,1}.","category":"page"},{"location":"man/states/#InfiniteMPS-1","page":"States","title":"InfiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"An infinite mps can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2);\nInfiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The above code would create an infinite mps with an A-B structure (a 2 site unit cell).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Very analogous to the finite mps case we have:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#MPSComoving-1","page":"States","title":"MPSComoving","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"MPSComoving is a bit of a mix between an infinite mps and a finite mps. It represents a window of mutable tensors embedde in an infinite mps.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created using:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"mpco = MPSComoving(left_infinite_mps,window_of_tensors,right_infinite_mps)","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Algorithms will then act on this window of tensors, while leaving the left and right infinite mps'es invariant.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"This state can be used to study impurities or local quenches.","category":"page"},{"location":"man/states/#MPSMultiline-1","page":"States","title":"MPSMultiline","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Statistical physics partition functions can be represented by an infinite tensor network which then needs to be contracted. This is done by finding approximate fixpoint infinite matrix product states. However, there is no good reason why a single mps should suffice and indeed we find in practice that this can also be periodic.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In other words, the fixpoints can be well described by a set of matrix product states.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Such a set can be created by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2,2);\nMPSMultiline(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline is also used extensively in as of yet unreleased peps code.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can access properties by calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[row,collumn]","category":"page"},{"location":"man/intro/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"The following few sections should help you on your way to setting up and running simulations.","category":"page"},{"location":"man/intro/#TensorKit-1","page":"Basics","title":"TensorKit","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"MPSKit works on \"TensorMap\" objects defined in TensorKit.jl. These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Initializing a TensorMap can be done using","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(initializer,eltype,codomain,domain);\nTensorMap(inputdat,codomain,domain);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\ndat = rand(ComplexF64,10,10); TensorMap(dat,ℂ^10,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Similarly, the following creates a symmetric tensor","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ[U₁](0=>1)*ℂ[U₁](1//2=>3),ℂ[U₁](1//2=>1,-1//2=>2))","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorKit defines a number of operations on TensorMap objects","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n3*a; a+a; a*a; a*adjoint(a); a-a; dot(a,a); norm(a);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"but the primary workhorse is the @tensor macro","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\nb = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n@tensor c[-1;-2]:=a[-1,1]*b[1,-2];","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"creates a new TensorMap c equal to a*b.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"For more information, check out the tensorkit documentation!","category":"page"},{"location":"man/intro/#Overview-1","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Within MPSKit we defined a set of states, a number of operators and some algorithms which combine the two in a nontrivial way.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As a simple example we can define a FiniteMPS","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"state = FiniteMPS(rand,ComplexF64,10,ℂ^2,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"A hamiltonian operator","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"opp = nonsym_ising_ham();","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"And use this to find the groundstate","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"(groundstate,_) = find_groundstate(state,opp,DMRG());","category":"page"},{"location":"man/intro/#Tips-and-tricks-1","page":"Basics","title":"Tips & tricks","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"There is an examples folder\nJulia inference is taxed a lot; so use (jupyter notebooks / Revise ) instead of re-running a script everytime","category":"page"},{"location":"man/environments/#um_environments-1","page":"Environments","title":"Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"In many tensor network algorithms we encounter partially contracted tensor networks. In dmrg for example, one needs to know the sum of all the hamiltonian contributions left and right of the site that we want to optimize. If you then optimize the neighboring site to the right, you only need to add one new contribution to the previous sum of hamiltonian contributions.","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This kind of information is stored in the environment objects (at the moment called \"Cache\" in our code, but the name is subject to change). The goal is that the user should preferably never have to deal with the caches, but being aware of the inner workings may allow you to write more efficient code. That is why they are nonetheless included in the manual.","category":"page"},{"location":"man/environments/#Finite-Environments-1","page":"Environments","title":"Finite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"When you create a state and a hamiltonian:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"an environment object can be created by calling","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache = params(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"The partially contracted mpohamiltonian left of site i can then be queried using:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"This may take some time, but a subsequent call to","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"leftenv(cache,i-1,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Should pretty much be free. Behind the scenes the cache stored all tensors it used to calculate leftenv (state.AL[1 .. i]) and when queried again, it checks if the tensors it previously used are identical (using ===). If so, it can simply return the previously stored results. If not, it will recalculate again. If you update a tensor in-place, the caches cannot know using === that the actual tensors have changed. If you do this, you have to call poison!(state,i).","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"As an optional argument, many algorithms allow you to pass in an environment object, and they also return an updated one. Therefore, for time evolution code, it is more efficient to give it the updated caches every time step, instead of letting it recalculate.","category":"page"},{"location":"man/environments/#Infinite-Environments-1","page":"Environments","title":"Infinite Environments","text":"","category":"section"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Infinite Environments are very similar :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"state = InfiniteMPS([ℂ^2],[ℂ^10]);\noperator = nonsym_ising_ham();\ncache = params(state,operator)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"There are also some notable differences. Infinite environments typically require solving linear problems or eigenvalue problems iteratively with finite precision. To find out what precision we used we can type:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"(cache.tol,cache.maxiter)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"To recalculate with a different precision :","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"cache.tol=1e-8;\nrecalculate!(cache,state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"Similar to finite environments, when queried with a different state:","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"different_state = InfiniteMPS([ℂ^2],[ℂ^10]);\nleftenv(cache,3,different_state)","category":"page"},{"location":"man/environments/#","page":"Environments","title":"Environments","text":"the cache will simply check if the states match up and if not, recalculate! behind the scenes.","category":"page"},{"location":"man/algorithms/#um_algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms/#minimizing-the-energy-1","page":"Algorithms","title":"minimizing the energy","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(groundstate,environments,delta) = find_groundstate(state,operator,Dmrg())","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"will use dmrg to minimize the energy. Sometimes it can be useful to do more extensive logging or to perform dynamical bond dimension expansion. That's why the Dmrg() constructor allows you to specify a finalize function","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"function finalize(iter,state,ham,pars)\n    println(\"Hello from iteration $iter\")\n    return state,pars;\nend\n\nDmrg(finalize=my_finalize)","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Similar functionality is provided (or soon to be implemented) in other groundstate algorithms. Other algorithms are provided and can be found in the library documentation.","category":"page"},{"location":"man/algorithms/#timestep-1","page":"Algorithms","title":"timestep","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"state = FiniteMPS(rand,ComplexF64,20,ℂ^2,ℂ^10);\noperator = nonsym_ising_ham();\n(newstate,environments) = timestep(state,operator,0.3,Tdvp2(trscheme=truncdim(20)))","category":"page"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"will evolve 'state' forwards in time by 0.3 seconds. Here we use a 2 site update scheme, which will truncate the 2site tensor back down, truncating at bond dimension 20. An overview of all time evolution algorithms is in the library documentation.","category":"page"},{"location":"man/algorithms/#dynamicaldmrg-1","page":"Algorithms","title":"dynamicaldmrg","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Dynamical dmrg has been described in other papers and is a way to find the propagator. The basic idea is that to calculate G(z) =  V  (H-z)^-1  V  , one can variationally find (H-z) W  =  V  and then the propagator simply equals G(z) =  V  W .","category":"page"},{"location":"man/operators/#um_operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/#MPOHamiltonian-1","page":"Operators","title":"MPOHamiltonian","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"We represent all quantum hamiltonians in their mpo form. As an example, the following bit of code constructs the ising hamiltonian.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"(sx,sy,sz,id) = nonsym_spintensors(1//2);\ndata = Array{Any,3}(missing,1,3,3);\ndata[1,1,1] = id;\ndata[1,1,2] = -sz;\ndata[1,2,3] = sz;\ndata[1,1,3] = 3*sx;\nham = MPOHamiltonian(data);","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"When we work with symmetries, it is often not possible to represent the entire hamiltonian as a sum of a product of one-body operators. In xxz for examples, only the sum (sx sx + sy sy + sz sz) is su(2) symmetric, but individually none of the terms are. It is for this reason that we use 4 leg mpo tensors in this hamiltonian object. The following bit of code","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"ham[1,1,1]","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Will print out a tensormap mapping (virtual space x physical space) to (virtual space x physical space). The conversion to mpo tensors was done automagically behind the scenes!","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"MPOHamiltonian are always assumed to be periodic in the first index (position). In this way, we can both represent periodic infinite hamiltonians and place dependent finite hamiltonians.","category":"page"},{"location":"man/operators/#PeriodicMPO-1","page":"Operators","title":"PeriodicMPO","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"This operator is used for statistical physics problems. It is simply a 2 dimensional periodic array of mpo tensors.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Can be created using","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"PeriodicMPO(t::AbstractArray{T,2}) where T<:MPOTensor","category":"page"},{"location":"man/operators/#ComAct-1","page":"Operators","title":"ComAct","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"We can deal with thermal density matrices by mapping them back to a state with hilbert space p*p'. Time evolution is then done using the (anti)commutator of the original hamiltonian. ComAct represents this object and can be created by calling","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"anticommutator(ham)\ncommutator(ham)","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Only finite density matrices are supported at the moment. If you want to do finite temperature stuff in the thermodynamic limit, then you should manually fuse p*p' and construct the the commutator in this space.","category":"page"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This code track contains the numerical research and development of the Ghent Quantum Group with regard to tensor network simulation in the julia language. The purpose of this package is to facilitate efficient collaboration between different members of the group.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Topics of research on tensor networks within the realm of this track include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tensor network algorithms (excitations, tdvp, vumps, ...)\nMPS routines (MPS diagonalization, Schmidt Decomposition, MPS left and right multiplication, ...)\nThe study of several useful models (nearest neighbour interactions, MPO's, long range interactions, ...)","category":"page"},{"location":"#User-manual-1","page":"Home","title":"User manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\",\"man/states.md\",\"man/operators.md\",\"man/algorithms.md\"]\nDepth = 3","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/lib.md\"]\nDepth = 1","category":"page"}]
}
